<!DOCTYPE html>
<html lang="en">

<head>
    <title>Yolah!</title>   
    <style>
        #grid {
            padding: 0; 
            /* margin: 12px; */
            display: grid;
            grid-template-columns: 600px 200px;
            grid-template-rows: 600px;
            grid-gap: 30px;
        }
        #right_grid {            
            display: grid;
            grid-template-columns: 80px 40px;
            grid-template-rows: 70px 30px;
        }
        #black {
            font-size: 20px;
            font-weight: bold;
            grid-column: 1;
            grid-row: 2;
        }
        #black_score {      
            font-size: 20px;      
            grid-column: 2;
            grid-row: 2;
        }
        #white {
            font-size: 20px;
            font-weight: bold;
            grid-column: 1;
            grid-row: 3;
        }
        #white_score {      
            font-size: 20px;      
            grid-column: 2;
            grid-row: 3;
        }
        #turn {
            font-size: 20px;
            font-weight: bold;      
            grid-column: 1;
            grid-row: 1;
        }
        #to_play {
            font-size: 20px;
            font-weight: bold;      
            grid-column: 2;
            grid-row: 1;
        }
    </style> 
    <script>        
        const FREE = 3;
        const EMPTY = 2;
        const BLACK = 0;
        const WHITE = 1;
        const GRID_DIM = 8;        
        const BACKGROUND_COLOR = "black";
        const RADIUS_FACTOR = 0.5 * 0.7;
        const BOARD_DIM_FACTOR = 1;
        let blackBb;
        let whiteBb;
        let emptyBb;
        let currentPlayer;
        let blackScore;
        let whiteScore;
        let canvas;
        let ctx;
        let fromSquare;
        let toSquare;
        let moves;
        let grid;
        let state;

        function canvasWidth() {
            return Math.round(BOARD_DIM_FACTOR * canvas.width);
        }

        function canvasHeight() {
            return Math.round(BOARD_DIM_FACTOR * canvas.height);
        }

        function squareToCoordinate(square) {
            return [Math.floor(square / GRID_DIM), square % GRID_DIM];
        }

        function possiblePosition(grid, i, j) {
            return i >= 0 && i < GRID_DIM && j >= 0 && j < GRID_DIM && grid[i][j] === FREE;
        }

        function possibleMoves(grid, square) {
            let res = [];
            let [i, j] = squareToCoordinate(square);
            function line(di, dj) {
                let res = [];
                let ii = i + di;
                let jj = j + dj;
                while (possiblePosition(grid, ii, jj)) {
                    res.push([ii, jj]);
                    ii += di;
                    jj += dj;
                }
                return res;
            }
            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    if (di === 0 && dj === 0) continue;
                    res = res.concat(line(di, dj));    
                }
            } 
            return res;
        }

        function atLeastOneMove(grid, bitboard) {
            let square = 0;
            while (bitboard) {
                if (bitboard & 1n) {
                    if (possibleMoves(grid, square).length !== 0) {
                        return true;
                    }
                }
                square++;
                bitboard >>= 1n;
            } 
            return false;
        }

        function fromSquareState(event) {
            console.log("fromSquareState");            
            fromSquare = clickToSquare(event);
            if (possibleMoves(grid, fromSquare).length === 0 || isSet(emptyBb, fromSquare)) {
                return;
            } 
            if (currentPlayer === "Black") {
                if (!isSet(blackBb, fromSquare)) return;
                blackBb = unsetBitboard(blackBb, fromSquare);
                blackScore++;
            } else {
                if (!isSet(whiteBb, fromSquare)) return;
                whiteBb = unsetBitboard(whiteBb, fromSquare);
                whiteScore++;
            }
            emptyBb = setBitboard(emptyBb, fromSquare);
            grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
            moves = possibleMoves(grid, fromSquare);    
            state = toSquareState;
            draw();
        }

        function toSquareState(event) {
            console.log("toSquareState");
            const square = clickToSquare(event);
            let [i, j] = squareToCoordinate(square);            
            if (!moves.some(([i1, j1]) => i === i1 && j === j1)) return;
            if (currentPlayer === "Black") {
                blackBb = setBitboard(blackBb, square);
                grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
                if (atLeastOneMove(grid, whiteBb)) {
                    currentPlayer = "White";
                }
            } else {
                whiteBb = setBitboard(whiteBb, square);
                grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
                if (atLeastOneMove(grid, blackBb)) {
                    currentPlayer = "Black";
                }
            }
            moves = [];            
            state = gameOver(grid, blackBb, whiteBb) ? gameOverState : fromSquareState;
            draw();
        }

        function gameOver(grid, blackBb, whiteBb) {
            return !(atLeastOneMove(grid, blackBb) || atLeastOneMove(grid, whiteBb));
        }
        
        function gameOverState(event) {
            console.log("gameOverState");
        }

        function bitboardsToGrid(blackBb, whiteBb, emptyBb) {
            let grid = Array(GRID_DIM).fill().map(() => Array(GRID_DIM).fill(FREE));
            for (let i = 0; i < GRID_DIM; i++) {
                for (let j = 0; j < GRID_DIM; j++) {
                    const idx = 1n << BigInt(i * GRID_DIM + j);
                    if (blackBb & idx) grid[i][j] = BLACK;
                    else if (whiteBb & idx) grid[i][j] = WHITE;
                    else if (emptyBb & idx) grid[i][j] = EMPTY;
                }
            }
            return grid;
        }

        function drawStone(x, y, radius, player) {
            ctx.fillStyle = "black";
            if (player === "White") ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();          
            ctx.strokeStyle = "white";
            if (player === "White") ctx.strokeStyle = "black";
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawSquareContent(i, j, content, dx, dy) {
            if (content === EMPTY) {
                ctx.fillStyle = BACKGROUND_COLOR;
                ctx.fillRect(j * dx, i * dy, dx, dy);    
            } else if (content === BLACK || content === WHITE) {
                drawStone(j * dx + dx / 2, i * dy + dy / 2, Math.min(dx, dy) * RADIUS_FACTOR, content === BLACK ? "Black" : "White");                 
            }
        }

        function drawLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawPossibleMoves(moves) {
            const dx = canvasWidth() / GRID_DIM;
            const dy = canvasHeight() / GRID_DIM;
            ctx.save();
            ctx.strokeStyle = "DarkOrange";
            ctx.lineWidth = 4;
            for (const idx in moves) {
                let [i, j] = moves[idx];                
                ctx.beginPath();
                ctx.rect(dx * j, dy * (GRID_DIM - 1 - i), dx, dy);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawScore(blackScore, whiteScore) {
            let b = document.getElementById("black_score");
            b.textContent = blackScore.toString();
            let w = document.getElementById("white_score");
            w.textContent = whiteScore.toString();
        }

        function drawTurn(player) {
            let turn = document.getElementById("to_play");
            if (state === gameOverState) {
                turn.textContent = "";
            } else {                
                if (player === "Black") {
                    turn.textContent = "\u2B24";
                } else {
                    turn.textContent = "\u25EF";
                }
            }
        }

        function draw() {
            drawScore(blackScore, whiteScore);
            drawTurn(currentPlayer);
            drawGrid(grid);
            if (state === toSquareState) {
                drawPossibleMoves(moves);
            } else if (state === gameOverState) {
                ctx.font = "58px Brush Script MT";
                ctx.fillStyle = "white";
                let txt = "Draw";
                if (blackScore > whiteScore) {
                    txt = "Black won";
                } else if (blackScore < whiteScore) {
                    txt = "White won";
                }              
                let dx = (canvas.width - ctx.measureText(txt).width) / 2;  
                ctx.fillText(txt, dx, canvas.height / 2);
                ctx.strokeStyle = "black";
                ctx.strokeText(txt, dx, canvas.height / 2);
            }
        }

        function drawGrid(grid) {           
            const dx = canvasWidth() / GRID_DIM;
            const dy = canvasHeight() / GRID_DIM;
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvasWidth(), canvasHeight());            
            for (let i = 0; i < GRID_DIM; i++) {                
                for (let j = 0; j < GRID_DIM; j++) {
                    if ((i + j) & 1) ctx.fillStyle = "maroon";
                    else ctx.fillStyle = "grey";
                    ctx.fillRect(j * dx, i * dy, dx, dy);
                }
            }
            for (let i = 0; i < GRID_DIM; i++) {                
                for (let j = 0; j < GRID_DIM; j++) {
                    drawSquareContent(GRID_DIM - 1 - i, j, grid[i][j], dx, dy);
                }
            }
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            for (let i = 0; i < GRID_DIM; i++) {                
                drawLine(0, i * dy, canvasWidth(), i * dy);                
            }
            for (let j = 0; j < GRID_DIM; j++) {
                drawLine(j * dx, 0, j * dx, canvasHeight());
            }
        }

        function clickToSquare(event) {
            const dx = canvasWidth() / GRID_DIM;
            const dy = canvasHeight() / GRID_DIM;
            const x = event.clientX;
            const y = event.clientY;
            return Math.floor(x / dx) + (GRID_DIM - Math.floor(y / dy)) * GRID_DIM;
        }

        function squareToBitboard(square) {
            return 1n << BigInt(square);
        }

        function isSet(bitboard, square) {
            return (bitboard & squareToBitboard(square)) !== 0n;
        }

        function setBitboard(bitboard, square) {
            return bitboard | squareToBitboard(square); 
        }

        function unsetBitboard(bitboard, square) {
            return bitboard & ~squareToBitboard(square); 
        }

        function bitboardToSquare(bitboard) {
            let pos = 0;
            while (!(bitboard & 1n)) {
                bitboard = bitboard >> 1n;
                pos++;
            }
            return pos;
        }

        function choice(event) {
            console.log(event);
            console.log("choice");
            state(event);
        }

        // function mouseMove(event) {
        //     console.log(event);
        //     console.log("mouseMove");
        //     if (state === toSquareState) {
        //         const dx = canvas.width / GRID_DIM;
        //         const dy = canvas.height / GRID_DIM;
        //         draw();
        //         drawStone(event.offsetX, event.offsetY, Math.min(dx, dy) * RADIUS_FACTOR, currentPlayer);
        //     }
        // }

        function init() {    
            canvas = document.getElementById("canvas");
            ctx = canvas.getContext("2d");
            //canvas.addEventListener("mousemove", mouseMove);
            blackBb = 0b1000000000000000000000000000100000010000000000000000000000000001n;
            whiteBb = 0b0000000100000000000000000001000000001000000000000000000010000000n;
            emptyBb = 0n;
            currentPlayer = "Black";
            blackScore = 0;
            whiteScore = 0;
            grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
            state = fromSquareState;
            canvas.addEventListener("click", choice);
            draw();
        }
    </script>
</head>

<body onLoad="init();">
    Server URI: <input class="draw-border" id="uri" size="47" value="ws://localhost:8080" style="margin-bottom: 5px;">
    <button class="echo-button" id="connect">Connect</button>
    <button class="echo-button" id="disconnect">Disconnect</button><br>
    Your name: <input class="draw-border" id="userName" size=47 style="margin-bottom: 5px;"><br>    
    <div id="grid">
        <div class="left">
            <canvas id="canvas" width="600px" height="600px" style="border:3px solid black">
                Your browser doesn't support the HTML5 element canvas.
            </canvas>
        </div>
        <div id="right_grid">
            <p id="turn">Turn</p><p id="to_play">&#11044;</p> 
            <!-- &#9711; -->
            <p id="black">Black</p> <p id="black_score">0</p>
            <p id="white">White</p> <p id="white_score">0</p>
        </div>
    </div>
    <pre id="messages" style="width: 600px; height: 180px; white-space: normal; overflow: auto; border: solid 1px #cccccc; margin-bottom: 5px;"></pre>    
    <div style="margin-bottom: 5px;">
        Message<br>
        <input class="draw-border" id="sendMessage" size="74" value="">
        <button class="echo-button" id="send">Send</button>
    </div>
</body>

</html>