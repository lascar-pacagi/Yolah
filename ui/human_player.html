<!DOCTYPE html>
<html lang="en">

<head>
    <title>Yolah!</title>   
    <style>
        #grid {
            padding: 0; 
            /* margin: 12px; */
            display: grid;
            grid-template-columns: 600px 200px;
            grid-template-rows: 600px;
            grid-gap: 30px;
        }
        #rightGrid {            
            display: grid;
            grid-template-columns: 80px 40px;
            grid-template-rows: 70px 30px;
        }
        #black {
            font-size: 20px;
            font-weight: bold;
            grid-column: 1;
            grid-row: 2;
        }
        #blackScore {      
            font-size: 20px;      
            grid-column: 2;
            grid-row: 2;
        }
        #white {
            font-size: 20px;
            font-weight: bold;
            grid-column: 1;
            grid-row: 3;
        }
        #whiteScore {      
            font-size: 20px;      
            grid-column: 2;
            grid-row: 3;
        }
        #turn {
            font-size: 20px;
            font-weight: bold;      
            grid-column: 1;
            grid-row: 1;
        }
        #toPlay {
            font-size: 20px;
            font-weight: bold;      
            grid-column: 2;
            grid-row: 1;
        }
    </style> 
    <script src="common.js"></script>
    <script>        
        let blackBb;
        let whiteBb;
        let emptyBb;
        let currentPlayer;
        let blackScore;
        let whiteScore;
        let fromSquare;
        let toSquare;
        let moves;
        let grid;
        let state;
        let ws;
        let uri;
        let connect;        
        let disconnect;
        let send;
        let sendMessage;
        let messages;
        let arrow;
        let uid;
        const NONE_MOVE = "a1:a1";
        const PATTERN = /^\[([^\]]*)\]\s?(.*)/;
        
        function drawScore(blackScore, whiteScore) {
            let b = document.getElementById("blackScore");
            b.textContent = blackScore.toString();
            let w = document.getElementById("whiteScore");
            w.textContent = whiteScore.toString();
        }

        function drawTurn(player) {
            let turn = document.getElementById("toPlay");
            if (state === gameOverState) {
                turn.textContent = "";
            } else {                
                if (player === "Black") {
                    turn.textContent = "\u2B24";
                } else {
                    turn.textContent = "\u25EF";
                }
            }
        }

        function draw() {
            drawScore(blackScore, whiteScore);
            drawTurn(currentPlayer);
            drawGrid(grid);            
            if (state === toSquareState) {
                drawPossibleMoves(moves);
            }
            if (arrow.length !== 0) {
                drawArrowBetweenSquares(arrow, 10, "DarkOrange");
            }
            if (state === gameOverState) {
                ctx.font = "58px Brush Script MT";
                ctx.fillStyle = "white";
                let txt = "Draw";
                if (blackScore > whiteScore) {
                    txt = "Black won";
                } else if (blackScore < whiteScore) {
                    txt = "White won";
                }              
                let dx = (canvas.width - ctx.measureText(txt).width) / 2;  
                ctx.fillText(txt, dx, canvas.height / 2);
                ctx.strokeStyle = "black";
                ctx.strokeText(txt, dx, canvas.height / 2);
            }
        }

        function choice(event) {
            console.log(event);
            console.log("choice");
            state(event);
        }
                
        function showMessage(msg) {
            messages.innerText += msg + "\n";
            messages.scrollTop = messages.scrollHeight - messages.clientHeight;
        }        

        function waitingForConnexion() {
            console.log("waiting for connexion");
        }

        function getGameState() {
            console.log("get game state");
        }

        function fromSquareState(event) {
            console.log("from square state");            
            fromSquare = clickToSquare(event);
            if (possibleMoves(grid, fromSquare).length === 0 || isSet(emptyBb, fromSquare)) {
                return;
            } 
            if (currentPlayer === "Black") {
                if (!isSet(blackBb, fromSquare)) return;
                blackBb = unsetBitboard(blackBb, fromSquare);
                blackScore++;
            } else {
                if (!isSet(whiteBb, fromSquare)) return;
                whiteBb = unsetBitboard(whiteBb, fromSquare);
                whiteScore++;
            }
            emptyBb = setBitboard(emptyBb, fromSquare);
            grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
            moves = possibleMoves(grid, fromSquare);    
            state = toSquareState;
            draw();
        }

        function toSquareState(event) {
            console.log("to square state");
            const square = clickToSquare(event);
            let [i, j] = squareToCoordinates(square);         
            if (!moves.some(([i1, j1]) => i === i1 && j === j1)) return;
            toSquare = square;
            if (currentPlayer === "Black") {
                const move = squaresToMove(fromSquare, toSquare)
                showMessage(`[black move] ${move}`);
                ws.send(MESSAGE.my_move(move));
                blackBb = setBitboard(blackBb, square);                
                grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
                if (atLeastOneMove(grid, whiteBb)) {
                    currentPlayer = "White";
                }
            } else {
                const move = squaresToMove(fromSquare, toSquare);
                showMessage(`[white move] ${move}`);
                ws.send(MESSAGE.my_move(move));
                whiteBb = setBitboard(whiteBb, square);
                grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
                if (atLeastOneMove(grid, blackBb)) {
                    currentPlayer = "Black";
                }
            }
            moves = [];
            state = gameOver(grid, blackBb, whiteBb) ? gameOverState : getGameState;
            draw();
        }

        function gameOverState(event) {
            console.log("game over state");
        }

        function onOpenConnexion(ev) {
            showMessage("[connexion opened]");
            initGame();
            state = getGameState;
            draw();            
        }
                
        function onCloseConnexion(ev) {
            showMessage(`[connexion closed, code=${ev.code}, reason=${ev.reason}]`);
            draw();
        }
         
        function onMessage(ev) {
            console.log(ev.data);
            try {
                const msg = JSON.parse(ev.data)
                switch (messageType(msg)) {
                    case MESSAGE.Error: 
                        showMessage(`[error]: ${MESSAGE.getError(msg)}`);
                        break;
                    case MESSAGE.Init: 
                        showMessage(`[join key]  ${MESSAGE.getJoinKey(msg)}`);
                        showMessage(`[watch key] ${MESSAGE.getWatchKey(msg)}`);
                        break;
                    case MESSAGE.New: break;
                    case MESSAGE.Join: break;
                    case MESSAGE.Watch: break;
                    case MESSAGE.Chat: 
                        showMessage(MESSAGE.getChat(msg));
                        break;
                    case MESSAGE.Info: break;
                    case MESSAGE.GameState: {
                        const gameState = MESSAGE.getGameState(msg);
                        if (gameState) {
                            const black = BigInt(gameState["black"]);
                            const white = BigInt(gameState["white"]);
                            const empty = BigInt(gameState["empty"]);
                            const ply   = BigInt(gameState["ply"]);
                            const wScore = BigInt(gameState["white score"]);
                            const bScore = BigInt(gameState["black score"]);
                            const move = lastMove(blackBb, whiteBb, black, white);
                            if (move !== "") {
                                showMessage(move);
                                arrow = lastMoveCoordinates(blackBb, whiteBb, black, white);                            
                            }
                            blackBb = black;
                            whiteBb = white;
                            emptyBb = empty;
                            whiteScore = wScore;
                            blackScore = bScore;
                            currentPlayer = ply & 1n ? "White" : "Black";               
                            grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
                            if (gameOver(grid, blackBb, whiteBb)) {
                                state = gameOverState;
                            }
                            draw();
                        }
                        break;
                    }
                    case MESSAGE.YourMove:
                        if (atLeastOneMove(grid, (currentPlayer === "White" ? whiteBb : blackBb))) {
                            state = fromSquareState;
                        } else {
                            showMessage(`[${currentPlayer === "White" ? "white" : "black"} move] ${NONE_MOVE}`);
                            ws.send(Message.my_move(NONE_MOVE));
                            currentPlayer = currentPlayer === "White" ? "Black" : "White";
                        }
                        draw();
                        break;                    
                }
            } catch (error) {                
                showMessage(`[error: ${error.name} ${error.message}]`);
            }
        }
        
        function onError(ev) {
            showMessage(`[error, code=${ev.code}, reason=${ev.reason}]`);
        }

        function initGame() {
            blackBb = INITIAL_BLACK_BB;
            whiteBb = INITIAL_WHITE_BB;
            emptyBb = 0n;
            blackScore = 0;
            whiteScore = 0;
            currentPlayer = "Black";
            arrow = [];
            grid = bitboardsToGrid(blackBb, whiteBb, emptyBb);
        }

        function getUserName() {
            return userName.value + "_p_" + uid;
        }

        function init() {
            state = waitingForConnexion;
            canvas = document.getElementById("canvas");
            ctx = canvas.getContext("2d");
            initGame();
            connect     = document.getElementById("connect");
            disconnect  = document.getElementById("disconnect");
            send        = document.getElementById("send");
            sendMessage = document.getElementById("sendMessage");
            messages    = document.getElementById("messages");
            uri         = document.getElementById("uri");
            uid         = makeId(ID_LENGTH);
            connect.onclick = function() {            
                ws = new WebSocket(uri.value);            
                ws.onopen = function(ev) {
                    onOpenConnexion(ev);
                };
                ws.onclose = function(ev) {
                    onCloseConnexion(ev);
                };
                ws.onmessage = function(ev) {
                    onMessage(ev);
                };
                ws.onerror = function(ev) {
                    onError(ev);
                };
            };
            disconnect.onclick = function() {
                ws.close();
            };
            send.onclick = function() {
                let msg = "";
                let command = PATTERN.exec(sendMessage.value);       
                if (command) {
                    switch (command[1]) {
                        case "new":
                            msg = MESSAGE.new(getUserName());
                            initGame();
                            state = getGameState;
                            draw();
                            break;
                        case "join key":
                            msg = MESSAGE.join(command[2], getUserName());
                            initGame();
                            state = getGameState;
                            draw();
                            break;
                    }
                } else {
                    msg = MESSAGE.chat(`[${getUserName()}]: ${sendMessage.value}`);                    
                }             
                ws.send(msg);             
                sendMessage.value = "";
            };
            sendMessage.onkeyup = function(ev) {
                ev.preventDefault();
                if (ev.keyCode === 13) {
                    send.click();
                }
            };
            canvas.addEventListener("click", choice);
            draw();
        }
    </script>
</head>

<body onLoad="init();">
    Server URI: <input class="draw-border" id="uri" size="47" value="ws://localhost:8001" style="margin-bottom: 5px;">
    <button class="echo-button" id="connect">Connect</button>
    <button class="echo-button" id="disconnect">Disconnect</button><br>
    Your name: <input class="draw-border" id="userName" size=47 style="margin-bottom: 5px;"><br>    
    <div id="grid">
        <div class="left">
            <canvas id="canvas" width="600px" height="600px" style="border:3px solid black">
                Your browser doesn't support the HTML5 element canvas.
            </canvas>
        </div>
        <div id="rightGrid">
            <p id="turn">Turn</p><p id="toPlay">&#11044;</p> 
            <!-- &#9711; -->
            <p id="black">Black</p> <p id="blackScore">0</p>
            <p id="white">White</p> <p id="whiteScore">0</p>
        </div>
    </div>
    <pre id="messages" style="width: 600px; height: 180px; white-space: normal; overflow: auto; border: solid 1px #cccccc; margin-bottom: 5px;"></pre>    
    <div style="margin-bottom: 5px;">
        Message<br>
        <input class="draw-border" id="sendMessage" size="74" value="">
        <button class="echo-button" id="send">Send</button>
    </div>
</body>

</html>

<!-- 
    
   1. waiting for connexion
   2. get game state
   3. from square
   4. to square
   5. game over

   1 -> 2 +-> 3 -> 4 +-> 2
          |          |
          |          +-> 5 -> 2
          |
          +-> 5 -> 2      
    
-->


