%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Complete Book Template - Yolah Game AI Engine
%
% A comprehensive single-file template for writing a technical book
% This template includes all necessary packages, custom environments,
% and example content to get you started quickly.
%
% USAGE:
% 1. Copy this file: cp book_template.tex book.tex
% 2. Edit book.tex with your content
% 3. Compile: make pdf (or pdflatex --shell-escape book.tex)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% you were helping me translating the book from french to english. I write in french because it is easier for me and you correct my french, put it in comments and translate into english


\documentclass[12pt,a4paper,twoside,openright]{book}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Encoding and Language
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

% Page Layout
\usepackage[
    top=1in,
    bottom=1in,
    left=1.25in,
    right=1in,
    headheight=15pt
]{geometry}

% Math
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

% Graphics and Colors
\usepackage{graphicx}
\graphicspath{{figures/}}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc}

% Tables
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{colortbl}

% Code Listings
\usepackage{minted}
\usemintedstyle{friendly}
\setminted{
    breaklines,
    fontsize=\small,
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    tabsize=4
}
\setmintedinline{breaklines}
\usepackage{mdframed}

% Define code background color
\definecolor{codebg}{RGB}{248,248,248}
\definecolor{terminalaccent}{RGB}{76,175,80}  % Green accent for terminal

% Font for terminal output with box-drawing characters
\usepackage{fontspec}
\setmonofont{DejaVu Sans Mono}[Scale=0.9]

% Custom breakable inline code command
\newcommand{\code}[1]{\texttt{\detokenize{#1}}}

% Algorithms
\usepackage{algorithm}
\usepackage{algpseudocode}

% Bibliography
\usepackage[
    backend=biber,
    style=numeric,
    sorting=none,
    maxbibnames=99
]{biblatex}
\addbibresource{references.bib}

% Glossary
\usepackage[acronym,toc]{glossaries}
\makeglossaries

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue!50!black,
    citecolor=green!50!black,
    urlcolor=blue!50!black,
    bookmarksdepth=3,
    pdfstartview=FitH
}

% Headers and Footers
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE]{\leftmark}
\fancyhead[RO]{\rightmark}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Other Useful Packages
\usepackage{float}              % Better float control
\usepackage{caption}            % Better captions
\captionsetup[listing]{skip=2pt} % Reduce space between listing and caption
\usepackage{subcaption}         % Subfigures
\usepackage{enumitem}           % Better lists
\usepackage{footnote}           % Better footnotes
\usepackage{csquotes}           % Quotations
\usepackage{eso-pic}            % Background images
\usepackage{transparent}        % Transparency for images

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUSTOM COLORS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\definecolor{boxborder}{RGB}{52,101,164}
\definecolor{boxbg}{RGB}{232,241,250}
\definecolor{algoborder}{RGB}{46,125,50}
\definecolor{algobg}{RGB}{232,245,233}
\definecolor{resultborder}{RGB}{183,28,28}
\definecolor{resultbg}{RGB}{255,235,238}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CUSTOM ENVIRONMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important Box
\usepackage{tcolorbox}
\tcbuselibrary{most}

\newtcolorbox{importantbox}{
    colback=boxbg,
    colframe=boxborder,
    fonttitle=\bfseries,
    title=Important,
    boxrule=1.5pt,
    arc=3pt
}

% Algorithm Box
\newtcolorbox{algorithmbox}{
    colback=algobg,
    colframe=algoborder,
    fonttitle=\bfseries,
    title=Algorithm,
    boxrule=1.5pt,
    arc=3pt
}

% Result Box
\newtcolorbox{resultbox}{
    colback=resultbg,
    colframe=resultborder,
    fonttitle=\bfseries,
    title=Key Result,
    boxrule=1.5pt,
    arc=3pt
}

\usepackage{wasysym}
\usepackage{fontawesome}
\usepackage{hhline}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
    {\fontsize{40}{60}\selectfont\textbf{Yolah Board Game}} \\
    \vspace{0.5cm}
    \huge Building a Two-Player Perfect-Information Game and Artificial Players\\
}

\author{
    \Large Pascal Garcia \\
    % \vspace{0.3cm}
    % \normalsize INSA Rennes
}

\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLOSSARY ENTRIES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Acronyms
\newacronym{smt}{SMT}{Satisfiability Modulo Theories}
\newacronym{ai}{AI}{Artificial Intelligence}
\newacronym{cpu}{CPU}{Central Processing Unit}
\newacronym{gpu}{GPU}{Graphics Processing Unit}
\newacronym{z3}{Z3}{Z3 Theorem Prover}
\newacronym{ipc}{IPC}{Instructions Per Cycle}
\newacronym{ilp}{ILP}{Instruction Level Parallelism}
\newacronym{pmu}{PMU}{Performance Monitoring Unit}
\newacronym{mlp}{MLP}{Memory Level Parallelism}
\newacronym{llc}{LLC}{Last Level Cache}
\newacronym{bmi2}{BMI2}{Bit Manipulation Instruction Set 2}

% Terms
\newglossaryentry{bitboard}{
    name=bitboard,
    description={A data structure using bit arrays to represent game board positions, where each bit corresponds to a square on the board}
}

\newglossaryentry{magicbitboard}{
    name=magic bitboard,
    description={A technique using specially chosen multiplication constants (magic numbers) and bit shifting to create a minimal perfect hash for efficiently mapping occupied squares to move lookup tables}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frontmatter

% Title Page
\AddToShipoutPictureBG*{%
    \AtPageCenter{%
        \makebox(0,0){\includegraphics[height=\paperheight]{initial_board_faded.png}}%
    }%
}
\maketitle

\thispagestyle{empty}
\vspace*{\fill}
% \begin{center}
% \reflectbox{\copyright} \the\year{} Pascal Garcia
% \end{center}
\begin{center}
    \includegraphics[width=10cm]{logo.png}
\end{center}
\vspace*{\fill}
\clearpage


% Copyright Page
\thispagestyle{empty}
\vspace*{\fill}
% \begin{center}
% \reflectbox{\copyright} \the\year{} Pascal Garcia
% \end{center}
\begin{center}
{\ttfamily\Huge\textcolor{black}{C'est en forgeant qu'on devient forgeron}}
\end{center}
\vspace*{\fill}
\clearpage

% Dedication (Optional)
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
\textit{À Sarah, Hugo et C\'elya \textcolor{red}{\faHeart}}\\
% \textit{\textbf{ahholy}}\\
% \textit{\textbf{aholy}}\\
% \textit{\textbf{yolah}}\\
\end{center}
\vspace*{\fill}
\clearpage

% Table of Contents
\tableofcontents

% List of Figures
\listoffigures

% List of Tables
\listoftables

% Preface (Optional)
%\chapter{Preface}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MAIN MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CHAPTER 1: INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:introduction}

\section{The Yolah Game}

% Nous avons créé le jeu Yolah dans le but d'illustrer des techniques efficaces d'implémentation de jeux de plateaux
% et d'intelligences artificielles pour nos étudiants. Yolah est une variante du jeu des pingouins dont vous pouvez voir la boîte dans la figure \ref{fig:pingouins} (nous le conseillons \smiley)

We designed Yolah, a variant of the Pingouins game, to illustrate effective techniques for implementing board games
and artificial players for our students. You can see the Pingouins game box in Figure~\ref{fig:pingouins}.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.4\textwidth]{pingouins.png}
\caption{The Pingouins game box}
% \caption{La boîte du jeu des pingouins}
\label{fig:pingouins}
\end{figure}

\begin{importantbox}
% Nous avons fait de notre mieux avec nos connaissances actuelles (\emph{ars longa, vita brevis}) pour implémenter notre jeu et les IA associées. Mais comme tout bon scientifique, il faudra regarder notre travail avec un œil critique.
We have done our best with our current knowledge (\emph{ars longa, vita brevis}) to implement our game and the associated artificial players. But like any good scientist, you should look at our work with a critical eye.
% Nous avons écrit le livre en français (plus facile pour nous) et nous avons demandé à un assistant (Claude) de le traduire pour nous.
We wrote the book in French (easier for us) and asked an AI assistant (Claude~\cite{anthropic2025claude}) to translate it for us.
\end{importantbox}

% Nous allons maintenant décrire les règles du jeu, puis nous expliquerons pourquoi nous avons choisi ces règles, nous donnerons un exemple de partie entre deux IA et nous présenterons la suite du livre.
We will now describe the rules of the game, then we will explain why we chose these rules, we will give an example of a game between two artificial players and then we will present the rest of the book.

\subsection{Game Rules}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.7\textwidth]{yolah_initial_configuration.png}
\caption{The initial configuration of the Yolah game}
% \caption{La configuration initiale du jeu Yolah}
\label{fig:yolah_initial_configuration}
\end{figure}

% Le plateau du jeu Yolah est représenté dans la figure \ref{fig:yolah_initial_configuration}.
% On peut y voir quatre pions noirs et quatre pions blancs placés de manière symétrique. Les noirs commencent en choisissant une de leurs pièces parmi
% les quatre. Une pièce ne pourra jamais disparaître du plateau car Yolah est un jeu sans possibilité de captures. Une pièce se déplace dans les huit directions
% aussi loin qu'elle le souhaite tant qu'elle n'est pas bloquée par une autre pièce ou un trou (notion que nous allons bientôt aborder). Par exemple, si les noirs
% choisissent de déplacer leur pièce qui se situe en {\ttfamily d5}, les cases où elle peut atterrir sont indiquées par de petites croix noires dans la figure \ref{fig:yolah_moves1}.

The Yolah game board is shown in Figure~\ref{fig:yolah_initial_configuration}.
You can see four black pieces and four white pieces placed symmetrically. Black starts by choosing one of their four pieces.
A piece can never disappear from the board because Yolah is a game without captures. A piece moves in all eight directions
as far as it wishes as long as it is not blocked by another piece or a hole (a concept we will soon discuss). For example, if black
chooses to move their piece located at {\ttfamily d5}, the squares where it can land are indicated by black crosses in Figure~\ref{fig:yolah_moves1}.\\

\begin{figure}[htpb]
\centering
\includegraphics[width=0.67\textwidth]{yolah_moves1.pdf}
% \caption{Mouvements possibles (petites croix noires) pour le pion noir situé sur la case {\ttfamily d5})}
\caption{Possible moves (black crosses) for the black piece located on square {\ttfamily d5}}
\label{fig:yolah_moves1}
\end{figure}

% Maintenant, si le pion noir en {\ttfamily d5} se déplace en {\ttfamily b7}, ce que nous noterons par {\ttfamily d5:b7}, nous obtenons la configuration représentée dans la figure \ref{fig:yolah_moves2}. On peut remarquer que la case de départ du pion noir disparaît et devient un trou~! Cette case (ce trou) devient inaccessible et infranchissable pour le reste de la partie~! Ceci va créer des opportunités pour bloquer l'adversaire et essayer de créer des zones où l'adversaire ne pourra pas aller.

Now, if the black piece at {\ttfamily d5} moves to {\ttfamily b7}, which we will denote as {\ttfamily d5:b7}, we get the configuration shown in Figure~\ref{fig:yolah_moves2}. Notice that the starting square of the black piece disappears and becomes a hole! This square (this hole) becomes inaccessible and impassable for the rest of the game! This will create opportunities to block the opponent and try to create areas where the opponent cannot go.\\

\begin{figure}[htpb]
\centering
\includegraphics[width=0.6\textwidth]{yolah_moves2.png}
\caption{Black just moved from {\ttfamily d5} to {\ttfamily b7}. The starting square {\ttfamily d5} becomes inaccessible and impassable for the rest of the game}
% \caption{Noir vient de se déplacer de {\ttfamily d5} en {\ttfamily b7}. La case de départ {\ttfamily d5} devient inaccessible et infranchissable pour le reste de la partie}
\label{fig:yolah_moves2}
\end{figure}

% Un déplacement rapporte un point au joueur qui vient de se déplacer. Par exemple, dans la configuration de la figure \ref{fig:yolah_moves2}, le joueur noir a un point et le joueur blanc qui ne s'est pas encore déplacé a zéro point. Le but du jeu est assez simple à résumer~: il faut se déplacer plus longtemps que son adversaire~!

A move earns one point for the player who just moved. For example, in the configuration of Figure~\ref{fig:yolah_moves2}, the black player has one point and the white player who has not yet moved has zero points. The goal of the game is quite simple to summarize: you must make more moves than your opponent!\\

% Maintenant c'est au tour des blancs de jouer. Ils doivent décider du pion blanc qu'ils vont bouger. Supposons que ce soit le pion en {\ttfamily e5}.
% Les déplacements possibles de ce pion blanc sont indiqués dans la figure \ref{fig:yolah_moves3}. Si blanc décide d'effectuer le coup {\ttfamily e5:f5}, on se retrouve dans la configuration de la figure \ref{fig:yolah_moves4} et le score est d'un point partout (chaque joueur a joué un coup).

Now it is white's turn to play. They must decide which white piece they will move. Suppose it is the piece at {\ttfamily e5}.
The possible moves for this white piece are shown in Figure~\ref{fig:yolah_moves3}. If white decides to make the move {\ttfamily e5:f5}, we end up in the configuration of Figure~\ref{fig:yolah_moves4} and the score is one point each (each player has played one move).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.67\textwidth]{yolah_moves3.pdf}
% \caption{Mouvements possibles (petites croix blanches) pour le pion blanc situé sur la case {\ttfamily e5})}
\caption{Possible moves (white crosses) for the white piece located on square {\ttfamily e5}}
\label{fig:yolah_moves3}
\end{figure}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.6\textwidth]{yolah_moves4.png}
\caption{White just moved from {\ttfamily e5} to {\ttfamily f5}. The starting square {\ttfamily e5} becomes inaccessible and impassable for the rest of the game. The score is one point each (each player has moved once)}
% \caption{Blanc vient de se déplacer de {\ttfamily e5} en {\ttfamily f5}. La case de départ {\ttfamily e5} devient inaccessible et infranchissable pour le reste de la partie. Le score est d'un point partout (chaque joueur s'est déplacé une fois)}
\label{fig:yolah_moves4}
\end{figure}

% Pour résumer, les règles du jeu Yolah sont les suivantes~:

To summarize, the rules of Yolah are as follows:
\begin{itemize}
% \item Le jeu est un jeu à deux joueurs (les noirs et les blancs) au tour par tour.
\item The game is a two-player game (black and white) played in turns.
% \item Chaque joueur dispose de quatre pions.
\item Each player has four pieces.
% \item À son tour, le joueur choisit un des pions qui peut encore bouger, si aucun pion ne peut bouger il passe son tour (on indiquera par le coup {\ttfamily a1:a1} le fait de passer son tour).
\item On their turn, the player chooses one of the pieces that can still move; if no piece can move, they pass their turn (we will denote by the move {\ttfamily a1:a1} to skip one's turn).
% \item Il doit déplacer le pion choisi dans une des huit directions, d'autant de cases qu'il le souhaite, mais il ne doit pas atterrir ou être bloqué par un pion ou un trou.
\item They must move the chosen piece in one of the eight directions, as many squares as desired, but must not land on or be blocked by a piece or a hole.
% \item Après le déplacement du pion choisi, la case de départ du coup devient un trou et on ne peut plus alors la franchir ou se poser dessus.
\item After moving the chosen piece, the starting square of the move becomes a hole and can no longer be crossed or landed on.
% \item Après chaque déplacement le joueur gagne un point.
\item After each move, the player earns one point.
% \item La partie se termine lorsque les deux joueurs ne peuvent plus se déplacer.
\item The game ends when both players can no longer move.
% \item Le joueur qui a le plus de points gagne la partie.
\item The player with the most points wins the game.
% \item Si les deux joueurs ont le même nombre de points, la partie est déclarée nulle.
\item If both players have the same number of points, the game is declared a draw.
\end{itemize}

% \subsection{Caractéristiques intéressantes de Yolah pour développer des IA}
\subsection{Interesting Characteristics of Yolah for Developing AIs}

% Nous avons choisi de modifier les règles du jeu des pingouins et d'obtenir les règles de notre variante Yolah pour pouvoir réutiliser des concepts utilisés pour l'implémentation du jeu d'échecs. C'est pour cela que nous utilisons un plateau identique à celui des échecs, et pas les cases hexagonales du jeu des Pingouins.
% Le déplacement des pions devient ainsi identique au déplacement d'une Dame.
% Comme dans le jeu des pingouins, il n'y a pas de cycle dans le jeu, et il n'y a donc pas besoin de règles spéciales pour qu'une partie se termine.
% Le nombre de coups à disposition de chacun des joueurs est assez important, mais raisonnable, au début (plus important que pour le jeu des Pingouins) \footnote{56 coups possibles pour le joueur noir en début de partie.}, mais il va diminuer petit à petit avec l'apparition des trous \footnote{Le nombre de coups possibles ne diminue pas forcément après chaque coup, il existe des configurations où le joueur a plus de 56 coups à sa disposition.}. Cela permet aux joueurs artificiels de pouvoir regarder un nombre assez important de coups à l'avance.
% Par rapport au jeu des Pingouins nous avons éliminé les valeurs différentes entre certaines cases et nous avons fixé une configuration de départ pour simplifier le jeu et le rendre symétrique.

We chose to modify the rules of the Pingouins game to create our Yolah variant, allowing us to reuse concepts from chess implementation. This is why we use a board identical to that of chess, rather than the hexagonal tiles of the Pingouins game.
Piece movement thus becomes identical to that of a Queen in chess.
As in the Pingouins game, there are no cycles in the game, so there is no need for special rules to ensure a game terminates.
The number of moves available to each player is quite large, but reasonable, at the start (larger than for the Pingouins game) \footnote{56 possible moves for the black player at the start of the game.}, but it gradually decreases as holes appear \footnote{The number of possible moves does not necessarily decrease after each move; there are configurations where a player has more than 56 moves available.}. This allows artificial players to look ahead a fairly large number of moves.
Compared to the Pingouins game, we removed the varying point values of tiles and defined a fixed starting configuration to simplify the game and make it symmetric. 

% Nous avons choisi les règles précédentes pour Yolah, d'une part parce que nous aimions bien la dynamique du jeu des Pingouins, mais aussi parce qu'il n'y a pas de cycle dans le jeu, il n'y a donc pas besoin de règles spéciales pour éviter qu'une partie ne se termine pas. Le nombre de coups à disposition de chacun des joueurs est assez important au début (mais raisonnable) \footnote{56 coups possibles pour le joueur noir en début de partie.}, mais il va diminuer petit à petit avec l'apparition des trous \footnote{Le nombre de coups possibles ne diminue pas forcément après chaque coup, il existe des configurations où le joueur a plus de 56 coups à sa disposition.}. Cela permet aux IA de pouvoir regarder un nombre assez important de coups à l'avance.


%  Nous voulions aussi pouvoir réutiliser des concepts utilisés pour l'implémentation efficace du jeu d'échecs, et la taille du plateau et le déplacement des pions (même façon de se déplacer qu'une Dame aux échecs) nous permettent de faire cela.


% \subsection{Exemple de partie}
\subsection{Game Example}

% Pour avoir une idée du déroulement d'une partie du jeu Yolah, nous allons faire jouer deux intelligences artificielles entre elles. La première IA sera basée sur la recherche arborescente Monte-Carlo et la deuxième sera basée sur le MinMax avec réseau neuronal. Nous étudierons ces deux IA dans la suite du livre. La seconde IA est plus forte et vous allez voir sa stratégie d'isolement de zones en action~!

To get an idea of how a Yolah game unfolds, we will have two artificial intelligences play against each other. The first AI will be based on Monte Carlo Tree Search and the second will be based on Minimax with a neural network. We will study both of these artificial players later in the book. The second AI is stronger and you will see its zone isolation strategy in action!\\

% Le déroulement de la partie est décrit dans les figures \ref{fig:game_example_opening}, \ref{fig:game_example_middle} et \ref{fig:game_example_end}.

The progression of the game is described in Figures~\ref{fig:game_example_opening}, \ref{fig:game_example_middle} and \ref{fig:game_example_end}.\\

% L'IA des blancs estime qu'elle est gagnante à partir du coup 10 (voir figure \ref{fig:game_example_move10}). On peut voir au coup 30 (voir figure \ref{fig:game_example_move30}) qu'elle a réussi à isoler une zone où les noirs ne pourront plus accéder. Au coup 32 (voir figure \ref{fig:game_example_move32}) elle sort un de ses pions de la zone qu'elle a isolée car l'autre pion pourra collecter tous les points de celle-ci. Il est plus utile d'utiliser l'autre pion pour glaner des points autre part. Notons qu'à partir du coup 47 (voir à partir de la figure \ref{fig:game_example_move47}) les noirs n'ont plus aucun coup disponible et doivent donc passer leur tour.

The white AI estimates that it is winning starting from move 10 (see Figure~\ref{fig:game_example_move10}). We can see at move 30 (see Figure~\ref{fig:game_example_move30}) that it has successfully isolated a zone that black can no longer access. At move 32 (see Figure~\ref{fig:game_example_move32}) it moves one of its pieces out of the isolated zone because the other piece will be able to collect all the points from that zone. It is more useful to use the other piece to gather points elsewhere. Note that starting from move 47 (see Figure~\ref{fig:game_example_move47} onward), black has no more available moves and must therefore pass their turn.\\

% La partie est gagnée par le joueur blanc 32 à 24, ce qui est un très bon score car le jeu Yolah nous semble être à l'avantage des noirs.

The game is won by the white player 32 to 24, which is a very good score because the Yolah game seems to favor black.

% a1:a2 h1:f3 h8:f6 a8:c6 d5:d6 d4:b2 d6:e6 e5:g5 f6:f5 f3:g4 f5:h7 g5:h5 e4:f4 h5:f7 e6:e8 g4:g1 e8:b8
% b2:d2 a2:a3 g1:f2 a3:a6 d2:d3 f4:h2 d3:b5 a6:a4 b5:b3 a4:c4 b3:c3 h2:g2 f2:f1 b8:c7 c3:a5 c4:c5
% c6:d7 g2:g3 f7:g7 c5:b4 a5:b6 g3:h4 b6:b7 h7:g8 d7:d8 c7:c8 f1:b1 g8:f8 d8:e7 h4:h3 b1:c1 c1:e1
% e1:e3 e3:e2 e2:d1 d1:c2 g7:g6 g6:h6 b7:a7

\begin{figure}[htpb] %H
\centering
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{board.png}
    % \caption{Position initiale}
    \caption{Initial position}
    \label{fig:game_example_init}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move1.png}
    % \caption{Coup 1 (Noir)}
    \caption{Move 1 (Black)}
    \label{fig:game_example_move1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move2.png}
    % \caption{Coup 2 (Blanc)}
    \caption{Move 2 (White)}
    \label{fig:game_example_move2}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move3.png}
    % \caption{Coup 3 (Noir)}
    \caption{Move 3 (Black)}
    \label{fig:game_example_move3}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move4.png}
    % \caption{Coup 4 (Blanc)}
    \caption{Move 4 (White)}
    \label{fig:game_example_move4}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move5.png}
    % \caption{Coup 5 (Noir)}
    \caption{Move 5 (Black)}
    \label{fig:game_example_move5}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move6.png}
    % \caption{Coup 6 (Blanc)}
    \caption{Move 6 (White)}
    \label{fig:game_example_move6}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move7.png}
    % \caption{Coup 7 (Noir)}
    \caption{Move 7 (Black)}
    \label{fig:game_example_move7}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move8.png}
    % \caption{Coup 8 (Blanc)}
    \caption{Move 8 (White)}
    \label{fig:game_example_move8}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move9.png}
    % \caption{Coup 9 (Noir)}
    \caption{Move 9 (Black)}
    \label{fig:game_example_move9}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move10.png}
    % \caption{Coup 10 (Blanc)}
    \caption{Move 10 (White)}
    \label{fig:game_example_move10}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move11.png}
    % \caption{Coup 11 (Noir)}
    \caption{Move 11 (Black)}
    \label{fig:game_example_move11}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move12.png}
    % \caption{Coup 12 (Blanc)}
    \caption{Move 12 (White)}
    \label{fig:game_example_move12}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move13.png}
    % \caption{Coup 13 (Noir)}
    \caption{Move 13 (Black)}
    \label{fig:game_example_move13}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move14.png}
    % \caption{Coup 14 (Blanc)}
    \caption{Move 14 (White)}
    \label{fig:game_example_move14}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move15.png}
    % \caption{Coup 15 (Noir)}
    \caption{Move 15 (Black)}
    \label{fig:game_example_move15}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move16.png}
    % \caption{Coup 16 (Blanc)}
    \caption{Move 16 (White)}
    \label{fig:game_example_move16}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move17.png}
    % \caption{Coup 17 (Noir)}
    \caption{Move 17 (Black)}
    \label{fig:game_example_move17}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move18.png}
    % \caption{Coup 18 (Blanc)}
    \caption{Move 18 (White)}
    \label{fig:game_example_move18}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move19.png}
    % \caption{Coup 19 (Noir)}
    \caption{Move 19 (Black)}
    \label{fig:game_example_move19}
\end{subfigure}

% \caption{Example de partie entre deux IA - coups 1 à 19}
\caption{Game example between two AIs - moves 1 to 19}
\label{fig:game_example_opening}
\end{figure}

\begin{figure}[htpb]
\centering

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move20.png}
    % \caption{Coup 20 (Blanc)}
    \caption{Move 20 (White)}
    \label{fig:game_example_move20}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move21.png}
    % \caption{Coup 21 (Noir)}
    \caption{Move 21 (Black)}
    \label{fig:game_example_move21}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move22.png}
    % \caption{Coup 22 (Blanc)}
    \caption{Move 22 (White)}
    \label{fig:game_example_move22}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move23.png}
    % \caption{Coup 23 (Noir)}
    \caption{Move 23 (Black)}
    \label{fig:game_example_move23}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move24.png}
    % \caption{Coup 24 (Blanc)}
    \caption{Move 24 (White)}
    \label{fig:game_example_move24}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move25.png}
    % \caption{Coup 25 (Noir)}
    \caption{Move 25 (Black)}
    \label{fig:game_example_move25}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move26.png}
    % \caption{Coup 26 (Blanc)}
    \caption{Move 26 (White)}
    \label{fig:game_example_move26}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move27.png}
    % \caption{Coup 27 (Noir)}
    \caption{Move 27 (Black)}
    \label{fig:game_example_move27}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move28.png}
    % \caption{Coup 28 (Blanc)}
    \caption{Move 28 (White)}
    \label{fig:game_example_move28}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move29.png}
    % \caption{Coup 29 (Noir)}
    \caption{Move 29 (Black)}
    \label{fig:game_example_move29}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move30.png}
    % \caption{Coup 30 (Blanc)}
    \caption{Move 30 (White)}
    \label{fig:game_example_move30}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move31.png}
    % \caption{Coup 31 (Noir)}
    \caption{Move 31 (Black)}
    \label{fig:game_example_move31}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move32.png}
    % \caption{Coup 32 (Blanc)}
    \caption{Move 32 (White)}
    \label{fig:game_example_move32}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move33.png}
    % \caption{Coup 33 (Noir)}
    \caption{Move 33 (Black)}
    \label{fig:game_example_move33}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move34.png}
    % \caption{Coup 34 (Blanc)}
    \caption{Move 34 (White)}
    \label{fig:game_example_move34}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move35.png}
    % \caption{Coup 35 (Noir)}
    \caption{Move 35 (Black)}
    \label{fig:game_example_move35}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move36.png}
    % \caption{Coup 36 (Blanc)}
    \caption{Move 36 (White)}
    \label{fig:game_example_move36}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move37.png}
    % \caption{Coup 37 (Noir)}
    \caption{Move 37 (Black)}
    \label{fig:game_example_move37}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move38.png}
    % \caption{Coup 38 (Blanc)}
    \caption{Move 38 (White)}
    \label{fig:game_example_move38}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move39.png}
    % \caption{Coup 39 (Noir)}
    \caption{Move 39 (Black)}
    \label{fig:game_example_move39}
\end{subfigure}\\

% \caption{Example de partie entre deux IA - coups 20 à 39}
\caption{Game example between two AIs - moves 20 to 39}
\label{fig:game_example_middle}
\end{figure}


\begin{figure}[htpb]
\centering

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move40.png}
    % \caption{Coup 40 (Blanc)}
    \caption{Move 40 (White)}
    \label{fig:game_example_move40}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move41.png}
    % \caption{Coup 41 (Noir)}
    \caption{Move 41 (Black)}
    \label{fig:game_example_move41}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move42.png}
    % \caption{Coup 42 (Blanc)}
    \caption{Move 42 (White)}
    \label{fig:game_example_move42}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move43.png}
    % \caption{Coup 43 (Noir)}
    \caption{Move 43 (Black)}
    \label{fig:game_example_move43}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move44.png}
    % \caption{Coup 44 (Blanc)}
    \caption{Move 44 (White)}
    \label{fig:game_example_move44}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move45.png}
    % \caption{Coup 45 (Noir)}
    \caption{Move 45 (Black)}
    \label{fig:game_example_move45}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move46.png}
    % \caption{Coup 46 (Blanc)}
    \caption{Move 46 (White)}
    \label{fig:game_example_move46}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move47.png}
    % \caption{Coup 47 (Noir)}
    \caption{Move 47 (Black)}
    \label{fig:game_example_move47}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move48.png}
    % \caption{Coup 48 (Blanc)}
    \caption{Move 48 (White)}
    \label{fig:game_example_move48}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move49.png}
    % \caption{Coup 49 (Blanc)}
    \caption{Move 49 (White)}
    \label{fig:game_example_move49}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move50.png}
    % \caption{Coup 50 (Blanc)}
    \caption{Move 50 (White)}
    \label{fig:game_example_move50}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move51.png}
    % \caption{Coup 51 (Blanc)}
    \caption{Move 51 (White)}
    \label{fig:game_example_move51}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move52.png}
    % \caption{Coup 52 (Blanc)}
    \caption{Move 52 (White)}
    \label{fig:game_example_move52}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move53.png}
    % \caption{Coup 53 (Blanc)}
    \caption{Move 53 (White)}
    \label{fig:game_example_move53}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move54.png}
    % \caption{Coup 54 (Blanc)}
    \caption{Move 54 (White)}
    \label{fig:game_example_move54}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move55.png}
    % \caption{Coup 55 (Blanc)}
    \caption{Move 55 (White)}
    \label{fig:game_example_move55}
\end{subfigure}\\

\begin{subfigure}[b]{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{yolah_game_example_move56.png}
    % \caption{Coup 56 (Blanc)}
    \caption{Move 56 (White)}
    \label{fig:game_example_move56}
\end{subfigure}
\hfill

% \caption{Example de partie entre deux IA - coups 39 à 56. Blanc gagne 32 à 24}
\caption{Example game between two artificial players -- moves 40 to 56. White wins 32 to 24}
\label{fig:game_example_end}
\end{figure}

% \subsection{La suite}
\section{What's Next}

% Dans le prochain chapitre, nous allons étudier l'implémentation du jeu Yolah en C++ \cite{cppreference}, cette implémentation se veut efficace car il sera important pour les IA de pouvoir jouer beaucoup de parties à la seconde~; leur niveau de jeu va en dépendre.

In the next chapter, we will study the implementation of the Yolah game in C++ \cite{cppreference}. This implementation is designed to be efficient because it will be important for the artificial players to be able to play many games per second; their level of play will depend on it. We develop on a Linux operating system, and occasionally use instructions specific to the x86-64 architecture.\\

% Le chapitre \ref{ch:ai} décrit l'interface commune de nos différentes IA, le chapitre \ref{ch:monte_carlo} présente une IA très simple basée sur une recherche Monte-Carlo. L'IA suivante, décrite au chapitre \ref{fig:mcts}, est une évolution de la précédente et permettra, contrairement à l'IA Monte-Carlo, de développer un arbre de jeu. Notons que ces deux IA ne nécessiteront pas d'heuristiques apportées par l'humain et n'ont besoin que des règles du jeu. Le chapitre \ref{ch:minmax} présente une IA basée sur une recherche arborescente minmax avec des heuristiques fournies par l'humain. L'heuristique utilisée par l'IA est une combinaison linéaire des heuristiques fournies par l'humain~; les pondérations de chacune des heuristiques dans cette combinaison linéaire sont apprises grâce à un algorithme génétique. Notre dernière, et plus forte IA, est présentée au chapitre \ref{ch:nnue}. Un réseau de neurones est utilisé à la place des heuristiques. Ce réseau de neurones est entraîné sur un ensemble de parties jouées par l'IA précédente.

Chapter~\ref{ch:ai} describes the common interface for our different AIs. Chapter~\ref{ch:monte_carlo} presents a very simple AI based on Monte Carlo search. The next AI, described in Chapter~\ref{fig:mcts}, is an evolution of the previous one and, unlike the Monte Carlo AI, will allow the development of a game tree. Note that these two AIs do not require human-provided heuristics and only need the rules of the game. Chapter~\ref{ch:minmax} presents an AI based on minimax tree search with heuristics provided by humans. The heuristic used by the AI is a linear combination of the heuristics provided by humans; the weights of each heuristic in this linear combination are learned using a genetic algorithm. Our last and strongest AI is presented in Chapter~\ref{ch:nnue}. A neural network is used instead of heuristics. This neural network is trained on a set of games played by the previous AI.\\

% Le chapitre \ref{ch:tournament} évalue alors toutes ces IA, en les faisant se rencontrer dans un tournoi. Nous conclurons ensuite et proposerons différentes directions pour créer d'autres joueurs artificiels.

Chapter~\ref{ch:tournament} then evaluates all these AIs by having them compete in a tournament. We will then conclude and propose various directions for creating other artificial players.\\

% Bonne lecture~!

Happy reading!


% \subsection{Why Yolah for AI Research?}

% Yolah provides several advantages as a platform for AI development:

% \begin{itemize}
%     \item \textbf{Moderate complexity}: Complex enough to be interesting, simple enough to be tractable
%     \item \textbf{Clear evaluation}: Position quality can be measured objectively
%     \item \textbf{Strategic depth}: Multiple viable strategies and playing styles
%     \item \textbf{Computational feasibility}: Playable with various AI techniques
% \end{itemize}

% \section{Overview of Game AI}

% Game-playing has been a cornerstone of artificial intelligence research since the field's inception. From early checkers programs to modern systems that master Go and Chess, game AI has driven innovation in search, learning, and decision-making.

% \subsection{Historical Context}

% The evolution of game AI can be traced through several key milestones:

% \begin{table}[H]
% \centering
% \begin{tabular}{lp{8cm}}
% \toprule
% \textbf{Year} & \textbf{Achievement} \\
% \midrule
% 1950s & Early checkers programs \\
% 1970s & Chess programs reach amateur level \\
% 1997 & Deep Blue defeats world champion Garry Kasparov \\
% 2016 & AlphaGo defeats world champion Lee Sedol \\
% 2017 & AlphaZero masters Chess, Go, and Shogi through self-play \\
% \bottomrule
% \end{tabular}
% \caption{Key milestones in game-playing AI}
% \label{tab:milestones}
% \end{table}

% \subsection{Categories of Game AI Techniques}

% Game AI techniques can be broadly categorized as:

% \begin{description}
%     \item[Search-based methods] Use game tree exploration (Minimax, Alpha-Beta)
%     \item[Sampling methods] Use Monte Carlo simulations (MCTS)
%     \item[Learning-based methods] Use neural networks and reinforcement learning
%     \item[Hybrid approaches] Combine multiple techniques for optimal performance
% \end{description}

% \section{Book Structure}

% This book is organized into three main parts:

% \textbf{Part I: Foundations} covers the basic game engine, data structures, and move generation.

% \textbf{Part II: Classical Algorithms} explores traditional search-based AI techniques.

% \textbf{Part III: Modern Approaches} delves into neural networks and learning methods.

% Each chapter builds upon previous concepts, with complete code examples and performance analysis.

\chapter{Game Engine}
\label{ch:engine}

% Nous allons implémenter la gestion du jeu en C++ en essayant de créer une implémentation efficace pour pouvoir réaliser un maximum de parties à la seconde, ce qui sera important pour obtenir des IA de bons niveaux. Nous testerons notre implémentation en générant un maximum de parties aléatoires en un temps donné à la fin de ce chapitre.
% Nous allons nous inspirer de l'excellent moteur de jeu d'échecs Stockfish pour les structures de données de Yolah.
We will implement game management in C++, striving to create an efficient implementation capable of running as many games per second as possible—this will be crucial for developing high-level AIs. We will test our implementation by generating as many random games as possible within a given time, at the end of this chapter.
We will draw inspiration from the excellent Stockfish chess engine \cite{stockfish2025} for Yolah's data structures.

\section{Data Structures}

% Nous allons représenter la position des noirs, des blancs et des cases détruites par des des entiers non signés sur 64 bits : uint64_t. Nous appelerons bitboard ces entiers. Nous prenons des uint64_t car le plateau de Yolah contient 64 cases, nous avons donc un bit par case. La table donne la position de chaque cases du plateau dans le bitboard. Cette information est représentée dans le code par l'énumération du listing.
We will represent the positions of black pieces, white pieces, and destroyed squares using $64$-bit unsigned integers: \mintinline{c++}{uint64_t}. We call these integers bitboards. We use \mintinline{c++}{uint64_t} because the Yolah board contains $64$ squares, giving us one bit per square. Table \ref{tab:bitboard_indices} shows the position of each board square in the bitboard. This information is represented in code by the enumeration in Listing \ref{lst:squares}\footnote{By default, the enumeration starts at value 0, so \mintinline{c++}{SQ_A1} equals 0, \mintinline{c++}{SQ_B1} equals 1, \ldots}.\\

\begin{table}[htpb]
\centering
% \caption{Positions de chaque cases du plateau dans le bitboard}
\caption{Position of each board square in the bitboard}
\label{tab:bitboard_indices}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & bit$_{56}$ & bit$_{57}$ & bit$_{58}$ & bit$_{59}$ & bit$_{60}$ & bit$_{61}$ & bit$_{62}$ & bit$_{63}$ \\ \hline
7 & bit$_{48}$ & bit$_{49}$ & bit$_{50}$ & bit$_{51}$ & bit$_{52}$ & bit$_{53}$ & bit$_{54}$ & bit$_{55}$ \\ \hline
6 & bit$_{40}$ & bit$_{41}$ & bit$_{42}$ & bit$_{43}$ & bit$_{44}$ & bit$_{45}$ & bit$_{46}$ & bit$_{47}$ \\ \hline
5 & bit$_{32}$ & bit$_{33}$ & bit$_{34}$ & bit$_{35}$ & bit$_{36}$ & bit$_{37}$ & bit$_{38}$ & bit$_{39}$ \\ \hline
4 & bit$_{24}$ & bit$_{25}$ & bit$_{26}$ & bit$_{27}$ & bit$_{28}$ & bit$_{29}$ & bit$_{30}$ & bit$_{31}$ \\ \hline
3 & bit$_{16}$ & bit$_{17}$ & bit$_{18}$ & bit$_{19}$ & bit$_{20}$ & bit$_{21}$ & bit$_{22}$ & bit$_{23}$ \\ \hline
2 & bit$_{8}$ & bit$_{9}$ & bit$_{10}$ & bit$_{11}$ & bit$_{12}$ & bit$_{13}$ & bit$_{14}$ & bit$_{15}$ \\ \hline
1 & bit$_{0}$ & bit$_{1}$ & bit$_{2}$ & bit$_{3}$ & bit$_{4}$ & bit$_{5}$ & bit$_{6}$ & bit$_{7}$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
enum Square : int8_t {
    SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
    SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
    SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
    SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
    SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
    SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
    SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
    SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
    SQ_NONE,
    SQUARE_ZERO = 0,
    SQUARE_NB   = 64
};
\end{minted}
\vspace{-0.5em}
% \captionof{listing}{Les cases du plateau de jeu}
\captionof{listing}{Board squares}
\label{lst:squares}
\end{mdframed}


\begin{figure}[htpb]
\centering
\includegraphics[width=0.5\textwidth]{yolah_game_example_move21.png}
% \caption{Configuration du plateau de jeu correspondant au coup 21 de la partie donnée en example dans le chapitre précédent (figure \ref{fig:game_example_move21})}
\caption{Board configuration corresponding to move 21 of the game given as an example in the previous chapter (Figure \ref{fig:game_example_move21})}
\label{fig:yolah_game_engine1}
\end{figure}

% Prenons comme exemple le plateau représenté dans la figure.
Let us take as an example the board shown in Figure \ref{fig:yolah_game_engine1}.\\
\begin{itemize}
% \item Les positions des pièces noires sur le plateau sont représentées par le bitboard :
\item The positions of black pieces on the board (Table \ref{tab:black_positions_game_example_move21}) are represented by the bitboard:
\mintinline{c++}{0b0000001010000000000000010000000000100000000000000000000000000000}.\\

\begin{table}[htpb]
\centering
% \caption{Positions des pièces noires}
\caption{Black piece positions}
\label{tab:black_positions_game_example_move21}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ \\ \hline
6 & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}


% \item Les positions des pièces blanches sur le plateau sont représentées par le bitboard :
\item The positions of white pieces on the board (Table \ref{tab:white_positions_game_example_move21}) are represented by the bitboard:
\mintinline{c++}{0b0000000000100000000001000000000000000000000000000010100000000000}.\\

\begin{table}[htpb]
\centering
% \caption{Positions des pièces blanches}
\caption{White piece positions}
\label{tab:white_positions_game_example_move21}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ \\ \hline
6 & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

% \item Les positions des trous sont représentées par le bitboard :
\item The positions of holes (Table \ref{tab:empty_positions_game_example_move21}) are represented by the bitboard:\\
\mintinline{c++}{0b1001000100000000001110001111100001011000001000010000001111000001}.\\

\begin{table}[htpb]
\centering
% \caption{Positions des cases détruites (les trous)}
\caption{Destroyed square positions (holes)}
\label{tab:empty_positions_game_example_move21}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
6 & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ \\ \hline
3 & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ \\ \hline
2 & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
1 & \raisebox{-0.3ex}{$\blacksquare$} & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\end{itemize}


% Les bitboards vont nous permettre une manipulation efficace du plateau, en utilisant des opérations bits à bits, et nécessiterons peu de place mémoire pour représenter celui-ci.
Bitboards allow us to efficiently manipulate the board using bitwise operations while requiring minimal memory to represent it.\\

% Nous représentons le plateau de jeu par la classe Yolah dont un extrait est donné dans le listing.
We represent the game board with the \mintinline{c++}{Yolah} class, an excerpt of which is given in Listing \ref{lst:yolah_class_attributes}.

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
constexpr uint64_t BLACK_INITIAL_POSITION =
0b10000000'00000000'00000000'00001000'00010000'00000000'00000000'00000001;
constexpr uint64_t WHITE_INITIAL_POSITION =
0b00000001'00000000'00000000'00010000'00001000'00000000'00000000'10000000;
class Yolah {
    uint64_t black = BLACK_INITIAL_POSITION;
    uint64_t white = WHITE_INITIAL_POSITION;
    uint64_t holes = 0;
    uint8_t black_score = 0;
    uint8_t white_score = 0;
    uint8_t ply = 0;
public:
    // ...
};
\end{minted}
\vspace{-0.5em}
% \captionof{listing}{Les attributs de la classe Yolah représentant le plateau de jeu}
\captionof{listing}{Attributes of the Yolah class representing the game board}
\label{lst:yolah_class_attributes}
\end{mdframed}

% Les attributs de la classe Yolah sont :
The attributes of the \mintinline{c++}{Yolah} class are:\\
\begin{itemize}
% \item Ligne 6, black : le bitboard pour les pièces noires.
\item Line 6, \mintinline{c++}{black}: the bitboard for black pieces.
% \item Ligne 7, white : le bitboard pour les pièces blanches.
\item Line 7, \mintinline{c++}{white}: the bitboard for white pieces.
% \item Ligne 8, holes : le bitboard pour les trous (les cases détruites).
\item Line 8, \mintinline{c++}{holes}: the bitboard for holes (destroyed squares).
% \item Ligne 9, black_score : le score, ou le nombre de déplacements, du joueur noir.
\item Line 9, \mintinline{c++}{black_score}: the score, or number of moves, of the black player.
% \item Ligne 10, white_score : le score, ou le nombre de déplacements, du joueur blanc.
\item Line 10, \mintinline{c++}{white_score}: the score, or number of moves, of the white player.
% \item Ligne 11, ply : le nombre de coups joués par les deux joueurs depuis le début de la partie.
\item Line 11, \mintinline{c++}{ply}: the number of moves played by both players since the start of the game.\\
\end{itemize}

% Un objet de type Yolah prendra en mémoire sizeof(Yolah) == 32 octets. Notons qu'avec le padding, il n'aurait pas été judicieux d'écrire, par exemple,
A \mintinline{c++}{Yolah} object will occupy \mintinline{c++}{sizeof(Yolah) == 32} bytes in memory. Note that due to padding\footnote{\url{https://en.wikipedia.org/wiki/Data_structure_alignment}.}, it would not have been wise to write, for example,

\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
class Yolah {
    uint64_t black = BLACK_INITIAL_POSITION;
    uint8_t black_score = 0;    
    uint64_t white = WHITE_INITIAL_POSITION;
    uint8_t white_score = 0;
    uint64_t holes = 0;
    uint8_t ply = 0;
public:
    // ...
};
\end{minted}

% car avec cette implémentation, nous aurions eu sizeof(Yolah) == 48 octets.
because with this implementation, we would have \mintinline{c++}{sizeof(Yolah) == 48} bytes.\\

% La représentation en bitboard permet d'obtenir efficacement des informations sur le jeu. Par exemple pour voir les cases occupées par les pièces noires et les pièces blanches, il suffit d'effectuer : black | white. Pour les positions des tables, on obtiendrait en une seule opération très efficace les positions des pièces noires et blanches. En notation binaire, on obtient :
The bitboard representation allows for efficiently obtaining game information. For example, to see the squares occupied by black and white pieces, simply perform: \mintinline{c++}{black | white}. For the positions in Tables \ref{tab:black_positions_game_example_move21} and \ref{tab:white_positions_game_example_move21}, we would obtain in a single highly efficient operation\footnote{You can find information on instruction latency and throughput for various processors at: \url{https://agner.org/optimize/instruction_tables.pdf}} the black and white piece positions shown in Table \ref{tab:black_white_positions_game_example_move21}. In binary notation, we get:\\
\begin{minted}[breaklines,fontsize=\small,frame=none]{cpp}
black | white
== 0000001010000000000000010000000000100000000000000000000000000000 |
   0000000000100000000001000000000000000000000000000010100000000000
== 0000001010100000000001010000000000100000000000000010100000000000
\end{minted}

\begin{table}[H]
\centering
% \caption{Positions des pièces noires et blanches que l'on obtient en faisant : black | white}
\caption{Black and white piece positions obtained by computing: \mintinline{c++}{black | white}}
\label{tab:black_white_positions_game_example_move21}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\bullet$ \\ \hline
6 & $\bullet$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

% Nous allons continuer d'utiliser des opérations bits-à-bits dans la suite de ce chapitre, pour tester notamment la fin d'une partie et la génération des coups possibles.
We will continue using bitwise operations throughout this chapter, particularly for testing game over conditions and generating possible moves.

\section{Game Over Test}

% Pour tester la fin de partie nous allons avoir besoin de quelques énumérations et constantes et de la fonction shift. La constante NORTH de l'énumération Direction est égale à 8. Pourquoi avoir choisi cette valeur ? Reprenons ci-dessous la table vue au chapitre précédent représentant la position de chaque bit d'un bitboard dans le plateau. On peut voir que si l'on ajoute 8 au numéro de bit contenu dans une des cases, on obtient le numéro de bit de la case au nord de cette dernière (sauf si l'on sort du plateau de jeu). Il en va de même pour les autres valeurs des constantes de l'énumération Direction.
To test for game over, we will need some enumerations and constants (Listings \ref{lst:directions} and \ref{lst:files_and_ranks}) and the \mintinline{c++}{shift} function (Listing \ref{lst:shift}). The \mintinline{c++}{NORTH} constant in the \mintinline{c++}{Direction} enumeration (Listing \ref{lst:directions}) equals $8$. Why this value? Let us revisit below, see Table \ref{tab:bitboard_indices2}, the table from the previous chapter showing the position of each bit in a bitboard on the board. We can see that adding $8$ to the bit number in any square gives us the bit number of the square to the north (unless we exit the board). The same applies to the other constant values in the \mintinline{c++}{Direction} enumeration (Listing \ref{lst:directions}). 
\begin{table}[htpb]
\centering
% \caption{Positions de chaque cases du plateau dans le bitboard. Remarquons que pour une case qui ne se trouve pas dans la rangée 8, bit$_{i+8}$ est le bit correspondant à la case au nord de la case du bit$_i$}
\caption{Position of each board square in the bitboard. Note that for a square not in rank 8, bit$_{i+8}$ corresponds to the square north of bit$_i$}
\label{tab:bitboard_indices2}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & bit$_{56}$ & bit$_{57}$ & bit$_{58}$ & bit$_{59}$ & bit$_{60}$ & bit$_{61}$ & bit$_{62}$ & bit$_{63}$ \\ \hline
7 & bit$_{48}$ & bit$_{49}$ & bit$_{50}$ & bit$_{51}$ & bit$_{52}$ & bit$_{53}$ & bit$_{54}$ & bit$_{55}$ \\ \hline
6 & bit$_{40}$ & bit$_{41}$ & bit$_{42}$ & bit$_{43}$ & bit$_{44}$ & bit$_{45}$ & bit$_{46}$ & bit$_{47}$ \\ \hline
5 & bit$_{32}$ & bit$_{33}$ & bit$_{34}$ & bit$_{35}$ & bit$_{36}$ & bit$_{37}$ & bit$_{38}$ & bit$_{39}$ \\ \hline
4 & bit$_{24}$ & bit$_{25}$ & bit$_{26}$ & bit$_{27}$ & bit$_{28}$ & bit$_{29}$ & bit$_{30}$ & bit$_{31}$ \\ \hline
3 & bit$_{16}$ & bit$_{17}$ & bit$_{18}$ & bit$_{19}$ & bit$_{20}$ & bit$_{21}$ & bit$_{22}$ & bit$_{23}$ \\ \hline
2 & bit$_{8}$ & bit$_{9}$ & bit$_{10}$ & bit$_{11}$ & bit$_{12}$ & bit$_{13}$ & bit$_{14}$ & bit$_{15}$ \\ \hline
1 & bit$_{0}$ & bit$_{1}$ & bit$_{2}$ & bit$_{3}$ & bit$_{4}$ & bit$_{5}$ & bit$_{6}$ & bit$_{7}$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
enum Direction : int8_t {
    NORTH = 8,
    EAST  = 1,
    SOUTH = -NORTH,
    WEST  = -EAST,
    NORTH_EAST = NORTH + EAST,
    SOUTH_EAST = SOUTH + EAST,
    SOUTH_WEST = SOUTH + WEST,
    NORTH_WEST = NORTH + WEST
};
\end{minted}
\captionof{listing}{Directions}
\label{lst:directions}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
template<Direction D>
constexpr uint64_t shift(uint64_t b) {
    if constexpr (D == NORTH)
        return b << NORTH;
    else if constexpr (D == SOUTH)      
        return b >> -SOUTH;
    else if constexpr (D == EAST)       
        return (b & ~FileHBB) << EAST;
    else if constexpr (D == WEST)       
        return (b & ~FileABB) >> -WEST;
    else if constexpr (D == NORTH_EAST) 
        return (b & ~FileHBB) << NORTH_EAST;
    else if constexpr (D == NORTH_WEST) 
        return (b & ~FileABB) << NORTH_WEST;
    else if constexpr (D == SOUTH_EAST) 
        return (b & ~FileHBB) >> -SOUTH_EAST;
    else if constexpr (D == SOUTH_WEST) 
        return (b & ~FileABB) >> -SOUTH_WEST;
    else return 0;
}
\end{minted}
% \captionof{listing}{Décalage selon une direction}
\captionof{listing}{Shift by direction}
\label{lst:shift}
\end{mdframed}


% La fonction shift(uint64_t b) donnée dans le listing nous permet de décaler tous les bits à 1 du bitboard en paramètre dans la direction D. Grâce aux if constexpr, lorsque l'on effectuera shift<NORTH>(b) par exemple, le compilateur transformera le code en : return b << NORTH;.
The \mintinline{c++}{shift(uint64_t b)} function given in Listing \ref{lst:shift} shifts all 1-bits in the bitboard parameter in direction \mintinline{c++}{D}\footnote{Thanks to \mintinline{c++}{if constexpr}, when we call \mintinline{c++}{shift<NORTH>(b)} for example, the compiler will transform the code to: \mintinline{c++}{return b << NORTH;}.}. Given
\begin{minted}[breaklines,fontsize=\small,frame=none]{cpp}
black == 1000000000000000000000000000100000100000000000000000000000000001
\end{minted}
% le bitboard représenté dans la table. Pour décaler les pièces noires d'une case vers le nord, on effectue : shift<NORTH>(black). On obtient alors le bitboard représenté dans la table. Notons que la pièce en h8 n'est plus sur le plateau.
the bitboard shown in Table \ref{tab:shift_north_before}. To shift the black pieces one square north, we perform: \mintinline{c++}{shift<NORTH>(black)}. We then get the bitboard
  \begin{minted}[breaklines,fontsize=\small,frame=none]{cpp}
1000000000000000000000000000100000100000000000000000000000000001
\end{minted}
shown in Table \ref{tab:shift_north_after}. Note that the piece on {\ttfamily h8} is no longer on the board.\\

\begin{table}[H]
\centering
\begin{minipage}{0.45\textwidth}
\centering
% \caption{Plateau de jeu avant d'effectuer shift<NORTH>}
\caption{Game board before applying \mintinline{c++}{shift<NORTH>}}
\label{tab:shift_north_before}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
6 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\centering
% \caption{Plateau de jeu après avoir effectué shift<NORTH>}
\caption{Game board after applying \mintinline{c++}{shift<NORTH>}}
\label{tab:shift_north_after}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
7 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
6 & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{minipage}
\end{table}

% On peut ainsi facilement obtenir toutes les cases directement au contact des pièces d'un plateau donné board, en effectuant l'opération suivante :
We can thus easily obtain all squares directly adjacent to the pieces on a given \mintinline{c++}{board} by performing the following operation:

\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
shift<NORTH>(board) | shift<SOUTH>(board) | shift<EAST>(board) | 
shift<WEST>(board) | shift<NORTH_EAST>(board) | shift<NORTH_WEST>(board) 
| shift<SOUTH_EAST>(board) | shift<SOUTH_WEST>(board)
\end{minted}

% Pour le plateau de la table on obtient les positions représentées par des étoiles dans la table.
For the board in Table \ref{tab:before_all_shift}, we get the positions represented by stars in Table \ref{tab:after_all_shift}.\\

\begin{table}[H]
\centering
\begin{minipage}{0.45\textwidth}
\centering
% \caption{Plateau de jeu}
\caption{Game board}
\label{tab:before_all_shift}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\circ$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\bullet$ \\ \hline
7 & $\cdot$ & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
6 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & $\circ$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & \raisebox{-0.3ex}{$\blacksquare$} & \raisebox{-0.3ex}{$\blacksquare$} & $\bullet$ & $\cdot$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
2 & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ \\ \hline
1 & $\bullet$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\cdot$ & $\circ$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\centering
% \caption{Positions autour des pièces}
\caption{Positions around the pieces}
\label{tab:after_all_shift}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
8 & $\ast$ & $\ast$ & $\ast$ & $\cdot$ & $\cdot$ & $\cdot$ & $\ast$ & $\cdot$ \\ \hline
7 & $\ast$ & $\ast$ & $\ast$ & $\cdot$ & $\cdot$ & $\cdot$ & $\ast$ & $\ast$ \\ \hline
6 & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\cdot$ & $\ast$ & $\cdot$ & $\cdot$ \\ \hline
5 & $\cdot$ & $\cdot$ & $\cdot$ & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\cdot$ \\ \hline
4 & $\cdot$ & $\cdot$ & $\cdot$ & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\cdot$ \\ \hline
3 & $\cdot$ & $\cdot$ & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\cdot$ \\ \hline
2 & $\ast$ & $\ast$ & $\ast$ & $\cdot$ & $\ast$ & $\cdot$ & $\ast$ & $\ast$ \\ \hline
1 & $\cdot$ & $\ast$ & $\ast$ & $\ast$ & $\ast$ & $\cdot$ & $\ast$ & $\cdot$ \\ \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{minipage}
\end{table}


% Dans le code de la fonction shift on peut voir l'utilisation des constantes FileHBB et FileABB (BB pour bitboard). Ces constantes vont nous permettre de masquer certains bits qui se retrouveraient après décalage dans une position incorrecte. Par exemple, si nous décalons dans la direction EAST le bitboard représenté dans la table, le pion blanc en h1 se retrouverait en a2. Pour éviter cela, avant le décalage, on élimine les éléments de la colonne h pour qu'ils ne se retrouvent pas dans la colonne a. Les constantes FileABB et FileHBB ainsi que les énumérations pour les rangées et colonnes sont définies dans le listing.
In the \mintinline{c++}{shift} function code (Listing \ref{lst:shift}), we can see the use of constants \mintinline{c++}{FileHBB} and \mintinline{c++}{FileABB} ({\ttfamily BB} for bitboard). These constants allow us to mask certain bits that would end up in incorrect positions after shifting. For example, if we shift the bitboard shown in Table \ref{tab:before_all_shift} in the \mintinline{c++}{EAST} direction, the white pawn on {\ttfamily h1} would end up on {\ttfamily a2}. To avoid this, before shifting, we eliminate elements from column {\ttfamily h} so they don't end up in column {\ttfamily a} (line 8 of Listing \ref{lst:shift}). The constants \mintinline{c++}{FileABB} and \mintinline{c++}{FileHBB} along with the rank and file enumerations are defined in Listing \ref{lst:files_and_ranks}.    

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
enum File : uint8_t {
    FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H,
    FILE_NB
};
enum Rank : uint8_t {
    RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8,
    RANK_NB
};
constexpr uint64_t FileABB = 0x0101010101010101;
//  0x0101010101010101
//==0b0000000100000001000000010000000100000001000000010000000100000001  
//           a8      a7      a6      a5      a4      a3      a2      a1 

constexpr uint64_t FileHBB = FileABB << 7;
//  0x8080808080808080
//==0b1000000010000000100000001000000010000000100000001000000010000000
//    h8      h7      h6      h5      h4      h3      h2      h1 
\end{minted}
% \captionof{listing}{Colonnes et rangées}
\captionof{listing}{Files and ranks}
\label{lst:files_and_ranks}
\end{mdframed}

% La fonction qui teste la fin de partie s'appelle game_over et elle est décrite dans le listing. Son implémentation est assez simple,
The function that tests for game over is called \mintinline{c++}{game_over} and is described in Listing \ref{lst:game_over}. Its implementation is straightforward:

\begin{itemize}

% \item À la ligne 2, on récupère dans possible le bitboard où il y a des 1 dans les positions libres.
\item On line 2, we retrieve in \mintinline{c++}{possible} the bitboard with $1$s in free positions.

% \item À la ligne 3, on crée le bitboard players qui contient des 1 dans les positions occupées par l'un des joueurs.
\item On line 3, we create the \mintinline{c++}{players} bitboard containing $1$s in positions occupied by either player.

% \item Les lignes 4 à 8 permettent de créer le bitboard around_players qui contient des 1 aux positions autour de chacune des pièces des joueurs.
\item Lines 4 to 8 create the \mintinline{c++}{around_players} bitboard containing $1$s at positions around each player's pieces.

% \item Enfin, à la ligne 8, on teste s'il n'existe aucune position libre à côté d'un des joueurs. En effet, le et bit-à-bit ne gardera un 1 dans un bit du résultat, que si et seulement s'il y a un 1 à cette position dans le bitboard possible et dans le bitboard around_players. Donc que la case correspondante est libre et accessible par le joueur. Si le résultat de around_players \& possible vaut 0, cela veut dire qu'aucune position n'est à la fois à côté d'un des joueurs et libre.
\item Finally, on line 9, we test whether no free position exists adjacent to either player. The bitwise AND will keep a $1$ in a result bit if and only if there is a $1$ at that position in both the \mintinline{c++}{possible} and \mintinline{c++}{around_players} bitboards—meaning the corresponding square is both free and accessible by a player. If \mintinline{c++}{around_players & possible} equals $0$, it means no position is both adjacent to a player and free.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
bool Yolah::game_over() const {
    uint64_t possible = ~holes & ~black & ~white;
    uint64_t players  = black | white;
    uint64_t around_players = shift<NORTH>(players) | 
        shift<SOUTH>(players) | shift<EAST>(players) | 
        shift<WEST>(players) | shift<NORTH_EAST>(players) | 
        shift<NORTH_WEST>(players) | shift<SOUTH_EAST>(players) | 
        shift<SOUTH_WEST>(players);
    return (around_players & possible) == 0;    
}
\end{minted}
% \captionof{listing}{Test de fin de partie}
\captionof{listing}{Game over test}
\label{lst:game_over}
\end{mdframed}

% Maintenant que nous savons tester la fin d'une partie, nous allons étudier comment générer efficacement les coups possibles dans une position donnée.
Now that we know how to test for game over, we will study how to efficiently generate possible moves in a given position.

\section{Generating Possible Piece Moves}

% La génération des coups possibles va utiliser une technique appelée les magic bitboard. Pour comprendre cette technique nous allons tout d'abord présenter sur un exemple simple le hachage parfait magique. Nous nous sommes inspirés de l'article pour cet exemple.
Move generation will use a technique called \emph{magic bitboards}, which is a perfect hash function that maps blocker occupancy patterns to unique lookup table indices without collisions % (nous allons voir tout cela en détail dans la suite de ce chapitre)
(we will see all this in detail later in this chapter). To understand this technique, we will first present perfect hashing through a simple example. Throughout this chapter, we will use the terms \emph{perfect hashing} and \emph{magic bitboards} interchangeably, as they refer to the same technique in this context. We drew inspiration from \cite{kannan2008magicbitboards} for this example.

\subsection{Magic Perfect Hashing Function}

% Supposons que nous devions trouver la position du seul bit à 1 dans un entier long non-signé (uint64_t). Par exemple, si nous appelons position la fonction permettant de calculer cette position, nous obtenons les résultats suivants :
Suppose we need to find the position of the only 1-bit in an unsigned long integer (\mintinline{c++}{uint64_t}). For example, if we call \mintinline{c++}{position} the function that calculates this position, we get the following results:

\begin{minted}[breaklines,fontsize=\small,frame=none]{cpp}
    position(1)          == 0
    position(0b1000)     == 3
    position(0b10000000) == 7
    position(0x8000000000000000) == 63
\end{minted}

% Notons que les processeurs possèdent des instructions permettant de calculer efficacement cette fonction, et le compilateur gcc permet de calculer efficacement cette position avec la fonction __builtin_ctzll(unsigned long long x), par exemple,
Note that processors have instructions to efficiently compute this function\footnote{\mintinline{asm}{tzcnt} on Intel.}, and in \texttt{C++} we can efficiently compute this position with the function\\ \mintinline{c++}{std::countr_zero(unsigned long long x)}\footnote{Returns the number of trailing 0-bits in x, starting at the least significant bit position.}, for example,

\begin{minted}[breaklines,fontsize=\small,frame=none]{cpp}
    position(0b1000) == std::countr_zero(0b1000)
\end{minted}

% Mais nous allons coder cette fonction position en utilisant une fonction magique de hachage parfait. Cette fonction nous servira pour la génération des coups possibles par la suite. En utilisant une table de hachage classique, nous pouvons tout d'abord remplir celle-ci avec les 64 valeurs et simplement consulter cette table par la suite, comme dans le code suivant :
However, we will code this \mintinline{c++}{position} function using a magic perfect hashing function. This kind of function will be useful for move generation later. Using a standard hash table, we could first fill it with 64 values and then simply look up this table, as in the following code:

\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
unordered_map<uint64_t, uint8_t> table {
    {1, 0}, {0b10, 1}, {0b100, 2}, {0b1000, 3}, //...
}
int position(uint64_t x) {
    return table[x];
}
\end{minted}

% La consultation de cette table de hachage est bien plus coûteuse que l'indexation d'un simple tableau. Mais on ne peut pas directement utiliser un tableau, car les valeurs pour indexer celui-ci sont dans une plage de valeurs trop grande. L'idée c'est de trouver une fonction de hachage efficace pour transformer chacune des 64 valeurs, que nous allons appeler clés, dans la plage [0, 63].
Looking up values in this hash table is far more costly than indexing a simple array\footnote{We will measure the performance gain from magic perfect hashing compared to using a standard hash table at the end of this section.}. However, we cannot directly use an array because the indexing values span too large a range—for example, the value \mintinline{c++}{0x8000000000000000} ($9,223,372,036,854,775,808$)! The idea is to find an efficient hash function that transforms each of the $64$ values\footnote{\mintinline{c++}{1, 0b10, 0b100, 0b1000, 0b10000, ...}.}—which we call bitboards—into the range $[0, 2^6 - 1 = 63]$.
% De plus on veut qu'il n'y ait aucune collision, on parle alors d'un hachage parfait. S'il y a des collisions des positions seraient erronées. Par exemple, si les clés 0b100 et 0b1000000 étaient transformées en l'indice 42, on devrait mettre dans table[42] la valeur 2 ou 6, mais on ne peut pas stocker plus d'une valeur au même emplacement.
Moreover, we want no collisions—this is called perfect hashing. If there were collisions, positions would be incorrect. For example, if keys \mintinline{c++}{0b100} and \mintinline{c++}{0b1000000} were both transformed to index $42$, we would need to store values $2$ and $6$ in \mintinline{c++}{table[42]}, but we cannot store more than one value at the same location.\\
% La fonction de hachage parfait magique va avoir la forme suivante :
The magic perfect hashing function will have the following form (listing \ref{lst:magic_perfect_hashing}):

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos,breaklines,fontsize=\small]{cpp}
constexpr uint64_t MAGIC = //...
constexpr int K = 6;
int magic_perfect_hashing(uint64_t bitboard) {
    return bitboard * MAGIC >> (64 - K);
}
\end{minted}
\vspace{-0.5em}
\captionof{listing}{Magic bitboard perfect hashing}
\label{lst:magic_perfect_hashing}
\end{mdframed}

% Dans cette fonction,
In this function:

\begin{itemize}

% \item À la ligne 2, la constante K donne le nombre de bits pour notre index. Ici avec K == 6, cela nous donne un maximum de 2^K = 2^6 = 64 valeurs possibles dans la table.
\item On line 2, the constant \mintinline{c++}{K} gives the number of bits for our index. Here with \mintinline{c++}{K == 6}, this gives us a maximum of $2^K = 2^6 = 64$ possible values in the table.

% \item À la ligne 4, on peut voir la formule pour calculer l'index dans la table selon la clé uint64_t key donnée en paramètre. On multiplie la clé par la constante MAGIC et ensuite on décale vers la droite pour ne garder que les K bits de poids forts du résultat. Cette opération est très peu coûteuse, mais comment trouver cette constante magique ?
\item On line 4, we see the formula for calculating the table index from the \mintinline{c++}{uint64_t key} parameter. We multiply the key by the \mintinline{c++}{MAGIC} constant and then right-shift to keep only the \mintinline{c++}{K} most significant bits of the result. This operation is very inexpensive, but how do we find this magic constant?\\

\end{itemize}

% Une méthode simple pour essayer de trouver la constante MAGIC est de la générer au hasard jusqu'à trouver une valeur qui ne crée aucune collision ! Ce genre d'approche est utilisée dans Stockfish pour générer les magic bitboard. Le listing montre cette approche.
A simple method to find the \mintinline{c++}{MAGIC} constant is to generate it randomly until we find a value that produces no collisions! This approach is used in Stockfish \cite{stockfish2025} to generate magic bitboards. Listing \ref{lst:random_magic} shows this approach.

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
#include <bits/stdc++.h>

using namespace std;

int main() {
    random_device rd;
    mt19937_64 mt(rd());
    uniform_int_distribution<uint64_t> d;
    unordered_map<uint64_t, int> positions;
    for (int i = 0; i < 64; i++) {
        positions[1ULL << i] = i;
    }
    constexpr int K = 7;
    auto index = [](uint64_t magic, int k, uint64_t bitboard) {
        return bitboard * magic >> (64 - k);
    };
    while (true) {
        uint64_t MAGIC = d(mt);
        bool found = true;
        set<uint64_t> seen;
        for (const auto [bitboard, pos] : positions) {
            int64_t i = index(MAGIC, K, bitboard);
            if (seen.contains(i)) {
                found = false;
                break;
            }
            seen.insert(i);
        }
        if (found) {
            cout << format("found magic for K = {}: {:#x}\n", 
                            K, MAGIC);
            int size = 1 << K;
            vector<int> table(size, -1);
            for (const auto [bitboard, pos] : positions) {
                table[index(MAGIC, K, bitboard)] = pos;
            }
            cout << format("uint8_t positions[{}] = {{", size);
            for (int i = 0; i < size; i++) {
                cout << table[i] << ',';
            }
            cout << "};\n";
            break;
        }
    }
}
\end{minted}
% \captionof{listing}{Recherche aléatoire de la constante MAGIC}
\captionof{listing}{Random search for the \mintinline{c++}{MAGIC} constant}
\label{lst:random_magic}
\end{mdframed}

\begin{itemize}

% \item Aux lignes 6 à 8, nous mettons en place un générateur aléatoire pour générer aléatoirement des uint64_t.
\item On lines 6 to 8, we set up a random generator to randomly generate \mintinline{c++}{uint64_t} values.

% \item À la ligne 9, la table de correspondance positions va associer à un entier long ne contenant qu'un seul bit à 1, la position de ce dernier. Cette table est initialisée aux lignes 10 à 12.
\item On line 9, the lookup table \mintinline{c++}{positions} associates each long integer containing only one 1-bit with its position. This table is initialized on lines 10 to 12.

% \item À la ligne 13, la constante K est le nombre de bits de notre clé obtenue par hachage parfait magique. Il faut que K permette de représenter toutes les valeurs que l'on doit couvrir. Par exemple, ici nous avons 64 valeurs possibles, car nous avons 64 positions possibles pour le bit à 1 dans un entier long sur 64 bits. Avec K == 7, on peut couvrir 2^7, soit 128 valeurs différentes. Notons que c'est plus que les 64 valeurs dont nous avons besoin et que K == 6 suffirait (K == 5 serait trop petit). Mais en essayant de trouver la constante MAGIC au hasard pour K == 6, ce programme ne trouvait pas en un temps raisonnable (nous verrons après une autre façon de faire pour réussir pour K == 6).
\item On line 13, the constant \mintinline{c++}{K} is the number of bits in our key obtained by magic perfect hashing. \mintinline{c++}{K} must be large enough to represent all values we need to cover. For example, here we have $64$ possible values since we have $64$ possible positions for the 1-bit in a $64$-bit long integer. With \mintinline{c++}{K == 7}, we can cover $2^7 = 128$ different values. Note that this is more than the $64$ values we need, and \mintinline{c++}{K == 6} would suffice (\mintinline{c++}{K == 5} would be too small). However, when trying to find the \mintinline{c++}{MAGIC} constant randomly for \mintinline{c++}{K == 6}, this program could not find one in reasonable time (we will see another approach to succeed with \mintinline{c++}{K == 6}).

% \item Aux lignes 14 à 16, la fonction index calcule l'index de clé bitboard (ce bitboard contient un seul bit à 1) en utilisant la formule pour notre hachage parfait magique.
\item On lines 14 to 16, the \mintinline{c++}{index} function calculates the index for key \mintinline{c++}{bitboard} (this bitboard contains only one 1-bit) using the magic perfect hashing formula.

% \item La boucle while, lignes 17 à 43, va boucler jusqu'à trouver la constante MAGIC qui permet de réaliser un hachage parfait magique (du coup cette boucle peut être infinie).
\item The \mintinline{c++}{while} loop, lines 17 to 44, loops until it finds a \mintinline{c++}{MAGIC} constant that achieves magic perfect hashing (this loop could potentially run forever).

% \item À la ligne 18, on crée la valeur MAGIC au hasard.
\item On line 18, we create the \mintinline{c++}{MAGIC} value randomly.

% \item Le set<uint64_t> de la ligne 20 va nous permettre de mémoriser les index (obtenues grâce à la fonction index) que nous avons déjà utilisés pour vérifier que nous n'avons pas de collisions.
\item The \mintinline{c++}{set<uint64_t>} on line 20 allows us to remember the indices (obtained via the \mintinline{c++}{index} function) we have already used, to verify we have no collisions.

% \item Aux lignes 21 à 28, la boucle for va tester tous les bitboards, trouver l'index de chacun d'entre eux grâce au hachage (fonction index) et vérifier que nous n'avons pas de collision (ligne 23) avec les index obtenus pour les bitboard précédents.
\item On lines 21 to 28, the \mintinline{c++}{for} loop tests all bitboards, finds the index for each using the hash (\mintinline{c++}{index} function), and verifies there are no collisions (line 23) with indices obtained for previous bitboards.

% \item Enfin, aux lignes 29 à 42, si nous avons trouvé une constante MAGIC qui permet de créer le hachage parfait magique, nous affichons celle-ci puis nous affichons un tableau en C++ qui contient la position du bit à 1 pour chacun des bitboard. La sortie de ce programme, pour une exécution donnée, est donnée ci-dessous.
\item Finally, on lines 29 to 43, if we found a \mintinline{c++}{MAGIC} constant that creates magic perfect hashing, we display it and then display a C++ array containing the position of the 1-bit for each bitboard. The output of this program for a given execution is shown below. 

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
\begin{minted}[fontsize=\small,breaklines,frame=none]{text}
$ g++ -O3 -Wall -Wpedantic -march=native -o find_magic
$ ./find_magic
found magic for K = 7: 0x65e4d4ee86638416
uint8_t positions[128] = {
  63, -1, 54, -1, 49, 55, 33, -1, 50, -1, -1, 56, 34, -1, 43, -1,
  51, -1, -1, 11, -1, -1, 57,  3, 39, 35, 14, -1, 44, 22, -1, -1,
  52, 31, -1, -1, -1, -1, 12, 20, -1, 18, -1, -1, 58, -1, -1,  4,
  60, 40,  0, 36, -1, 15, -1, -1, 45, -1, 27, 23,  6, -1, -1, -1,
  62, 53, 48, 32, -1, -1, -1, 42, -1, 10, -1,  2, 38, 13, 21, -1,
  30, -1, -1, 19, 17, -1, -1, -1, 59, -1, -1, -1, -1, 26,  5, -1,
  61, 47, -1, 41,  9,  1, 37, -1, 29, -1, 16, -1, -1, -1, 25, -1,
  46, -1,  8, -1, 28, -1, -1, 24, -1,  7, -1, -1, -1, -1, -1, -1
};
\end{minted}
\end{mdframed}

% Pour obtenir la position du bit à 1 pour le bitboard 0b1000 par exemple, il faut donc consulter la valeur suivante :
To get the position of the 1-bit for bitboard \mintinline{c++}{0b1000} for example, we need to look up the following value:

\begin{minted}[breaklines,fontsize=\small]{cpp}
   positions[0b1000 * 0x65e4d4ee86638416 >> (64 - 7)]
== positions[0x2f26a774331c20b0 >> 57]
== positions[0x17]
== positions[23]
== 3
\end{minted}

% On remarque qu'il y a des places vacantes dans le tableau positions, celles contenant la valeur -1, donc on a perdu de la place. Nous n'aurions gaspillé aucune place si nous avions trouvé une constante MAGIC pour K == 6. Mais est-ce possible ?
Notice that there are vacant slots in the \mintinline{c++}{positions} array—those containing $-1$—so we wasted space. We would not have wasted any space if we had found a \mintinline{c++}{MAGIC} constant for \mintinline{c++}{K == 6}. But is this possible?

\end{itemize}

% Pour répondre à cette question nous allons procéder d'une autre manière. Nous ne voulons pas, bien entendu, balayer les 2^64 valeurs possibles puis à chaque fois tester si la valeur permet le hachage parfait magique. Nous allons utiliser un solveur SMT qui va nous permettre de fixer des contraintes avant de balayer tout l'espace de recherche. Le fait de fixer tout d'abord des contraintes va permettre d'élaguer l'espace de recherche. Notons que nous n'avons pas la garantie que la recherche soit rapide, mais pour ce problème, l'obtention d'une constante MAGIC pour K == 6 sera très rapide. Si vous êtes intéressé par le fonctionnement d'un solveur SMT vous pouvez consulter les références.
To answer this question, we will proceed differently. Obviously, we do not want to scan through all $2^{64}$ ($9, 223, 372, 036, 854, 775, 808$) possible values and test each one for magic perfect hashing. We will use an \gls{smt} solver that allows us to set constraints before searching the entire space. Setting constraints first will prune the search space. Note that we have no guarantee the search will be fast, but for this problem, finding a \mintinline{c++}{MAGIC} constant for \mintinline{c++}{K == 6} will be very quick. If you are interested in how an \gls{smt} solver works, you can consult \cite{kroening2016decision} and \cite{biere2021handbook}.\\

% Le code du listing décrit l'approche utilisant le solveur Z3.
The code in Listing \ref{lst:z3_magic} describes the approach using the \gls{z3} solver \cite{moura2008z3}.

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{python}
from z3 import *

positions = {}
for i in range(64):
    positions[1 << i] = i

solver = Solver()
MAGIC  = BitVec('magic', 64)
K = 6
bitboards = list(positions.keys())

def index(magic, k, bitboard):
    return magic * bitboard >> (64 - k)

for i in range(64):
    index1 = index(MAGIC, K, bitboards[i])
    for j in range(i + 1, 64):
        index2 = index(MAGIC, K, bitboards[j])
        solver.add(index1 != index2)

if solver.check() == sat:
    model = solver.model()
    m = model[MAGIC].as_long()
    print(f'found magic for K = {K}: {m:#x}')
    size = 1 << K
    table = [-1] * size
    for bitboard, pos in positions.items():
        table[index(m, K, bitboard) & size - 1] = pos
    print(f'constexpr uint8_t positions[{size}] = {{')
    for i in range(size):
        print(f'{table[i]},', end='')
    print('\n};')
\end{minted}
% \captionof{listing}{Recherche avec un solveur SMT de la constante MAGIC}
\captionof{listing}{Searching for the \mintinline{c++}{MAGIC} constant with an \gls{smt} solver}
\label{lst:z3_magic}
\end{mdframed}

\begin{itemize}

% \item Les lignes 3 à 5 permettent de faire correspondre à un bitboard donné ne contenant qu'un bit à 1, la position correspondante de ce bit. On utilise pour ce faire le dictionnaire positions (ligne 3).
\item Lines 3 to 5 associate each bitboard containing only one 1-bit with the corresponding position of that bit. We use the \mintinline{python}{positions} dictionary (line 3) for this.

% \item À la ligne 7, on instantie le solveur Z3.
\item On line 7, we instantiate the \gls{z3} solver.

% \item À la ligne 8, on déclare que la constante MAGIC est du type z3.BitVec qui est un type proposé par le solveur Z3 qui permet de représenter des vecteurs de bits, ici nous utilisons un vecteur de 64 bits.
\item On line 8, we declare that the \mintinline{python}{MAGIC} constant is of type \mintinline{python}{z3.BitVec}, a type provided by the \gls{z3} solver for representing bit vectors—here we use a $64$-bit vector.

% \item La fonction index définie aux lignes 12 et 13 permet de calculer le hachage en fonction de la constante MAGIC et de K.
\item The \mintinline{python}{index} function defined on lines 12 and 13 calculates the hash based on the \mintinline{python}{MAGIC} constant and \mintinline{python}{K}.

% \item Aux lignes 15 à 19 on donne au solver les contraintes que les valeurs hachées par la fonction index de deux bitboards différents ne doivent pas se retrouver au même emplacement. Cette contrainte permet d'assurer que le hachage est parfait.
\item On lines 15 to 19, we give the solver the constraints that hashed values from the \mintinline{python}{index} function for two different bitboards must not map to the same location. This constraint ensures perfect hashing.

% \item À la ligne 21 on execute le solveur et il nous indique par la valeur sat s'il a trouvé une valeur pour MAGIC qui satisfait les contraintes. Notons que si le solveur répond unsat à la place de sat, cela veut dire qu'il n'existe aucun entier sur 64 bits qui permette le hachage parfait. Même si l'espace de recherche est très grand, sur ma machine, l'obtention d'une solution se fait en moins d'une seconde !
\item On line 21, we run the solver, which returns \mintinline{python}{sat} if it found a \mintinline{python}{MAGIC} value satisfying the constraints. Note that if the solver returns \mintinline{python}{unsat} instead of \mintinline{python}{sat}, it means no $64$-bit integer allows perfect hashing. Even though the search space is very large, on my machine, finding a solution takes less than a second!

% \item Les lignes 22 à 32 permettent d'afficher sur la sortie standard la valeur MAGIC ainsi que le tableau C++ des valeurs obtenues. Ce tableau est donné ci-dessous.
\item Lines 22 to 32 print to standard output the \mintinline{python}{MAGIC} value and the C++ array of obtained values. This array is shown below. 

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
\begin{minted}[fontsize=\small,breaklines,frame=none]{text}
$ python find_magic.py
found magic for K = 6: 0x2643c51ab9dfa5b
constexpr uint8_t positions[64] = {
 0,  1,  2, 14,  3, 22, 28, 15, 11,  4, 23, 55,  7, 29, 41, 16,
12, 26, 53,  5, 24, 33, 56, 35, 61,  8, 30, 58, 37, 42, 17, 46,
63, 13, 21, 27, 10, 54,  6, 40, 25, 52, 32, 34, 60, 57, 36, 45,
62, 20,  9, 39, 51, 31, 59, 44, 19, 38, 50, 43, 18, 49, 48, 47
};
\end{minted}
\end{mdframed}


% Notons qu'en Python il était important d'effectuer l'opération index(m, K, bitboard) & size - 1 à la ligne 28 car les nombres entiers ont une précision arbitraire et par exemple nous avons
Note that in \emph{Python} it was important to perform the operation \mintinline{python}{index(m, K, bitboard) & size - 1} on line 28 because Python integers have arbitrary precision. For example, we have:

\begin{minted}[breaklines,fontsize=\small]{python}
   0x2643c51ab9dfa5b * 0x8000000000000000 >> 58
== 0x4c878a3573bf4b60

   (0x2643c51ab9dfa5b * 0x8000000000000000 >> 58) & size - 1
== 0x4c878a3573bf4b60 & 0b111111
== 32
\end{minted}

% En C++ nous aurions
In C++ we would have:

\begin{minted}[breaklines,fontsize=\small]{cpp}
   0x2643c51ab9dfa5b * 0x8000000000000000 >> 58
== 32
\end{minted}

% Remarquons que nous n'avons pas le même problème à la ligne 18 car MAGIC est de type BitVec(64).
Note that we don't have the same problem on line 18 because \mintinline{python}{MAGIC} is of type \mintinline{python}{BitVec(64)}.\\

\end{itemize}

% Pour tester l'efficacité de notre technique de hachage parfait magique, nous allons mettre en place le micro-benchmark donné dans le listing. Nous utilisons la librairie google benchmark pour effectuer ces mesures. Le résultat de l'exécution de ce benchmark est donné dans la figure. La fonction BM_magic_positions utilisant le hachage parfait magique est bien plus rapide que la fonction BM_unordered_map_positions utilisant une table de hachage classique. Bien entendu, la fonction BM_builtin_ctz_positions utilisant une instruction dédiée est la plus efficace (mais ne sera d'aucune utilité pour la génération des coups possibles).
To test the efficiency of our magic perfect hashing technique, we set up the micro-benchmark shown in Listing \ref{lst:compare_hashmap_magic}. We use the \emph{Google Benchmark} library for these measurements \cite{googlebenchmark2025}. The benchmark execution results are shown in Listing \ref{lst:result_compare_hashmap_magic}. The \mintinline{c++}{BM_magic_positions} function using magic perfect hashing is much faster than the \mintinline{c++}{BM_unordered_map_positions} function using a standard hash table. Of course, the \mintinline{c++}{BM_countr_zero_positions} function using a dedicated instruction is the most efficient (but will be of no use for move generation).\\

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
#include <benchmark/benchmark.h>
#include <unordered_map>
#include <vector>
#include <bit>

std::vector<uint64_t> generate_isolated_bits() {
    std::vector<uint64_t> samples;
    for (int i = 0; i < 64; i++) {
        samples.push_back(1ULL << i);
    }
    return samples;
}
static void BM_magic_positions(benchmark::State& state) {
    constexpr uint64_t MAGIC = 0x2643c51ab9dfa5b;
    constexpr int K = 6;
    constexpr uint8_t positions[64] = {
      0,  1,  2, 14,  3, 22, 28, 15, 11,  4, 23, 55,  7, 29, 41, 16,
     12, 26, 53,  5, 24, 33, 56, 35, 61,  8, 30, 58, 37, 42, 17, 46,
     63, 13, 21, 27, 10, 54,  6, 40, 25, 52, 32, 34, 60, 57, 36, 45,
     62, 20,  9, 39, 51, 31, 59, 44, 19, 38, 50, 43, 18, 49, 48, 47
    };
    auto samples = generate_isolated_bits();
    size_t idx = 0;
    for (auto _ : state) {
     uint64_t bitboard = samples[idx++ & 63];
     benchmark::DoNotOptimize(positions[bitboard*MAGIC >> (64 - K)]);
    }
    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_magic_positions);
static void BM_unordered_map_positions(benchmark::State& state) {
    std::unordered_map<uint64_t, uint8_t> map;
    for (uint8_t i = 0; i < 64; i++) {
        map[1ULL << i] = i;
    }
    auto samples = generate_isolated_bits();
    size_t idx = 0;
    for (auto _ : state) {
        uint64_t bitboard = samples[idx++ & 63];
        benchmark::DoNotOptimize(map[bitboard]);
    }
    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_unordered_map_positions);
static void BM_countr_zero_positions(benchmark::State& state) {
    auto samples = generate_isolated_bits();
    size_t idx = 0;
    for (auto _ : state) {
        uint64_t bitboard = samples[idx++ & 63];
        benchmark::DoNotOptimize(std::countr_zero(bitboard));
    }
    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_countr_zero_positions);
BENCHMARK_MAIN();
\end{minted}
% \captionof{listing}{Micro-benchmark pour comparer les temps d'exécution du hachage parfait magique, d'une table de hachage classique et de l'instruction machine dédiée.}
\captionof{listing}{Micro-benchmark comparing execution times of magic perfect hashing, a standard hash table, and a dedicated machine instruction.}
\label{lst:compare_hashmap_magic}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
\begin{minted}[breaklines,fontsize=\small,frame=none]{text}
$ g++ -std=c++23 -O3 -march=native -Wall -Wpedantic\
positions_bench.cpp -o positions -lbenchmark
$ ./positions
Run on (12 X 4400 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB (x6)
  L1 Instruction 32 KiB (x6)
  L2 Unified 256 KiB (x6)
  L3 Unified 12288 KiB (x1)
Load Average: 1.59, 1.78, 1.63
-----------------------------------------------------------------
Benchmark                        Time        CPU      Iterations
-----------------------------------------------------------------
BM_magic_positions           0.552 ns   0.552 ns      1000000000
BM_unordered_map_positions    31.1 ns    31.1 ns        22584016
BM_countr_zero_positions     0.491 ns   0.491 ns      1000000000
\end{minted}
% \captionof{listing}{Résultats de l'exécution du micro-benchmark du listing}
\captionof{listing}{Micro-benchmark execution results from Listing \ref{lst:compare_hashmap_magic}}
\label{lst:result_compare_hashmap_magic}
\end{mdframed}

% Maintenant que nous avons vu sur un exemple simple comment marche la technique du hachage parfait magique, nous allons pouvoir étudier la génération des mouvements possibles des pièces en utilisant cette technique.
Now that we have seen how the magic perfect hashing technique works through a simple example, we can study generating possible piece moves using this technique.

\subsection{Magic Bitboards for Piece Moves}

% Pour chaque configuration du plateau de jeu, nous voulons pouvoir, pour une case donnée, donner la liste des coups possibles pour cette configuration de jeu. Par exemple, pour le plateau de la figure \ref{fig:move23_position} dont les coups possibles pour la pièce en {\ttfamily d3} sont représentées par des petites croix blanches dans la figure \ref{fig:move23_d3_moves}, on voudrait très efficacement pouvoir obtenir le bitboard de la table \ref{tab:bb_move23_d3_moves} indiquant les différents coups possibles.
For each board configuration, we want to be able to provide, for a given square, the list of possible moves for that game configuration. For example, for the board in figure \ref{fig:move23_position} where the possible moves for the piece at {\ttfamily d3} are represented by white crosses in figure \ref{fig:move23_d3_moves}, we would like to very efficiently obtain the bitboard shown in table \ref{tab:bb_move23_d3_moves} indicating the different possible moves.\\

\begin{figure}[htpb]
\centering
\includegraphics[width=0.5\textwidth]{yolah_game_example_move23_no_arrow.png}
% \caption{Position du plateau après le coup 23}
\caption{Board position example (after move 23 in figure \ref{fig:game_example_middle})}
\label{fig:move23_position}
\end{figure}


\begin{figure}[htpb]
\centering
\includegraphics[width=0.5\textwidth]{move23_d3_possible_moves.pdf}
% \caption{Coups possibles (petites croix blanches) pour le pion blanc situé sur la case {\ttfamily d3}}
\caption{Possible moves (white crosses) for the white piece at {\ttfamily d3}}
\label{fig:move23_d3_moves}
\end{figure}

\begin{table}[htpb]
\centering
\caption{Bitboard of possible moves for the piece at d3 (see figure \ref{fig:move23_d3_moves})}
\label{tab:bb_move23_d3_moves}
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.5cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[1pt]0\end{tabular} \\[5pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[1pt]0\end{tabular} \\[5pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[1pt]0\end{tabular} \\[5pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[1pt]0\end{tabular} \\[5pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[1pt]0\end{tabular} \\[5pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[1pt]\textbf{1}\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[1pt]0\end{tabular} \\[5pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[1pt]0\end{tabular} \\[5pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[1pt]0\end{tabular} \\[5pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\begin{table}[htpb]
\centering
% \caption{Masque pour les cases atteignables par la pièce en d3 sans considérer les éventuels obstacles}
\caption{Mask for reachable squares for the piece at d3 without considering obstacles}
\label{tab:mask_for_d3}
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.5cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[1pt]0\end{tabular} \\[5pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[1pt]0\end{tabular} \\[5pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[1pt]0\end{tabular} \\[5pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[1pt]0\end{tabular} \\[5pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[1pt]\textbf{1}\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[1pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[1pt]0\end{tabular} \\[5pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[1pt]0\end{tabular} \\[5pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\begin{table}[htpb]
\centering
\caption{Board bitboard}
\label{tab:board_move23}
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.5cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[1pt]0\end{tabular} \\[5pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[1pt]0\end{tabular} \\[5pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 19}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[1pt]0\end{tabular} \\[5pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

\begin{table}[htpb]
\centering
\caption{Occupancies bitboard (\mintinline{c++}{mask & board}) for d3}
\label{tab:occupancies_d3_move23}
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.5cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[1pt]0\end{tabular} \\[5pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[1pt]\textbf{1}\end{tabular} \\[5pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[1pt]0\end{tabular} \\[5pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[1pt]0\end{tabular} \\[5pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[1pt]0\end{tabular} \\[5pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[1pt]0\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[1pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[1pt]0\end{tabular} \\[5pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[1pt]0\end{tabular} \\[5pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[1pt]0\end{tabular} \\[5pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

% Prenons comme exemple la case {\ttfamily d3}. Nous avons tout d'abord besoin d'un masque qui va nous permettre d'isoler les cases du plateau atteignables par la pièce en {\ttfamily d3} sans prendre en considération les obstacles. Ce masque est représenté dans la table \ref{tab:mask_for_d3}. Soit \mintinline{c++}{mask} le masque de la table \ref{tab:mask_for_d3} et \mintinline{c++}{board} le bitboard de la table \ref{tab:board_move23} représentant le plateau de jeu de la figure \ref{fig:move23_position}. On obtient le bitboard \mintinline{c++}{occupancies}, donnant les obstacles sur les trajectoires possibles de la pièce en {\ttfamily d3} en faisant~: \mintinline{c++}{occupancies = mask & board}. Ce bitboard est donné dans la table \ref{tab:occupancies_d3_move23}. Il y a un $1$ pour chaque case contenant une pièce ou un trou. Ce qu'il nous faut, c'est de pouvoir indexer une table, appelons la \mintinline{c++}{uint64_t MOVES_D3[]}, grâce au bitboard \mintinline{c++}{occupancies}, pour obtenir le bitboard des coups possibles à partir de la case {\ttfamily d3}. Ce bitboard est représenté dans la table \ref{tab:bb_move23_d3_moves}. Il ne nous restera plus qu'à parcourir chacun des bits à $1$ dans ce bitboard pour connaitre les cases où l'on peut se rendre et créer le coup correspondant. Pour obtenir l'index dans \mintinline{c++}{MOVES_D3}, on va utiliser la technique des magic bitboard que nous avons décrite dans la section précédente. Pour la case {\ttfamily d3}, il va nous falloir trouver une valeur \mintinline{c++}{K} et une valeur \mintinline{c++}{MAGIC} (voir listing \ref{lst:magic_perfect_hashing}) pour pouvoir obtenir le bitboard des coups possibles en faisant~: \mintinline{c++}{MOVES_D3[occupancies * MAGIC >> (64 - K)]}.
Let's take square {\ttfamily d3} as an example. We first need a mask that will allow us to isolate the board squares reachable by the piece at {\ttfamily d3} without considering obstacles. This mask is represented in table \ref{tab:mask_for_d3}. Let \mintinline{c++}{mask} be the mask from table \ref{tab:mask_for_d3} and \mintinline{c++}{board} be the bitboard from table \ref{tab:board_move23} representing the game board from figure \ref{fig:move23_position}. We obtain the bitboard \mintinline{c++}{occupancies}, giving the obstacles on the possible trajectories of the piece at {\ttfamily d3} by doing: \mintinline{c++}{occupancies = mask & board}. This bitboard is given in table \ref{tab:occupancies_d3_move23}. There is a $1$ for each square containing a piece or a hole. What we need is to be able to index a table, let's call it \mintinline{c++}{uint64_t MOVES_D3[]}, using the bitboard \mintinline{c++}{occupancies}, to obtain the bitboard of possible moves from square {\ttfamily d3}. This bitboard is represented in table \ref{tab:bb_move23_d3_moves}. Then we only need to iterate through each $1$ bit in this bitboard to know which squares we can move to and create the corresponding move. To obtain the index in \mintinline{c++}{MOVES_D3}, we will use the magic bitboard technique we described in the previous section. For square {\ttfamily d3}, we need to find a value \mintinline{c++}{K} and a value \mintinline{c++}{MAGIC} (see listing \ref{lst:magic_perfect_hashing}) to be able to obtain the bitboard of possible moves by doing: \mintinline{c++}{MOVES_D3[occupancies * MAGIC >> (64 - K)]}.\\

% Pour trouver une constante \mintinline{c++}{MAGIC} pour la case {\ttfamily d3}, nous allons avoir besoin d'énumérer tous les placements d'obstacles possibles sur les cases où peut se rendre la pièce en {\ttfamily d3}. Cela veut dire que l'on doit énumérer tous les sous-ensembles de $1$ du bitboard de la table \ref{tab:mask_for_d3}. Huit sous-ensembles de cette énumération sont présentés dans la figure \ref{fig:subsets_for_d3}. Il y a $25$ cases sur la trajectoire de la pièce en {\ttfamily d3} (voir la table \ref{tab:mask_for_d3}), cela veut dire qu'il y a $2^{25} = 33,554,432$ sous-ensembles à énumérer~!
To find a \mintinline{c++}{MAGIC} constant for square {\ttfamily d3}, we will need to enumerate all possible obstacle placements on the squares reachable by the piece at {\ttfamily d3}. This means we must enumerate all subsets of $1$ bits of the bitboard in table \ref{tab:mask_for_d3}. Eight subsets from this enumeration are presented in figure \ref{fig:subsets_for_d3}. There are $25$ squares on the trajectory of the piece at {\ttfamily d3} (see table \ref{tab:mask_for_d3}), which means there are $2^{25} = 33,554,432$ subsets to enumerate!

% Nous voudrions réduire ce nombre de configurations des obstacles possibles sur la trajectoire de la pièce. En effet, comme nous le verrons lorsque nous détaillerons le code pour déterminer la valeur de la constante \mintinline{c++}{MAGIC}, la place mémoire pour stocker les coups possibles pour une case donnée va dépendre de ce nombre de configurations.
We would like to reduce this number of possible obstacle configurations on the piece's trajectory. Indeed, as we will see when we detail the code to determine the value of the \mintinline{c++}{MAGIC} constant, the memory space to store the possible moves for a given square will depend on this number of configurations.\\

\begin{figure}[htpb]
\centering
\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 6} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny 0 & \tiny 0 & \tiny 0 & \cellcolor{lightgray}\tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{Empty (0 bits)}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 6} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny 0 & \tiny 0 & \tiny 0 & \cellcolor{lightgray}\tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{1 bit set}
\end{subfigure}

\vspace{0.8cm}

\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 6} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \cellcolor{lightgray}\tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{2 bits set}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 6} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny 0 & \tiny 0 & \tiny 0 & \cellcolor{lightgray}\tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{3 bits set}
\end{subfigure}

\vspace{0.8cm}

\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} \\[2pt] \hline
{\scriptsize 6} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \cellcolor{lightgray}\tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{9 bits set}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.45\textwidth}
\centering
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.3cm}|}}
\hline
{\scriptsize 8} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 7} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 & \tiny\textbf{1} \\[2pt] \hline
{\scriptsize 6} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny 0 \\[2pt] \hline
{\scriptsize 5} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 4} & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny\textbf{1} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 3} & \tiny\textbf{1} & \tiny\textbf{1} & \tiny\textbf{1} & \cellcolor{lightgray}\tiny 0 & \tiny\textbf{1} & \tiny\textbf{1} & \tiny\textbf{1} & \tiny\textbf{1} \\[2pt] \hline
{\scriptsize 2} & \tiny 0 & \tiny 0 & \tiny\textbf{1} & \tiny\textbf{1} & \tiny\textbf{1} & \tiny 0 & \tiny 0 & \tiny 0 \\[2pt] \hline
{\scriptsize 1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny\textbf{1} & \tiny 0 & \tiny 0 \\[2pt] \hline
\multicolumn{1}{c|}{} & \scriptsize a & \scriptsize b & \scriptsize c & \scriptsize d & \scriptsize e & \scriptsize f & \scriptsize g & \scriptsize h \\
\cline{2-9}
\end{tabular}
\caption{25 bits set (full)}
\end{subfigure}

\caption{Six subsets of the mask for d3 showing different occupancy patterns (0 to 25 bits set) from the $2^{25}$ possible ones}
\label{fig:subsets_for_d3}
\end{figure}
 
\label{par:edge_exclusion}
% Pour réduire ce nombre de configurations, nous n'allons pas considérer les cases sur les bords du plateau pour enlever les bits à $1$ sur les lignes 1 et 8 et les colonnes a et h du masque de la table \ref{tab:mask_for_d3}. On obtient le bitboard de la table \ref{tab:mask_for_d3_without_edge}. Il nous manquera l'information sur les bords, mais on supposera que s'il est possible de jouer en {\ttfamily d7} par exemple, il sera aussi possible de jouer en {\ttfamily d8}. Bien sûr il se peut qu'il y ait un obstacle en {\ttfamily d8}, mais on pourra facilement éliminer ce coup impossible comme nous le verrons dans la suite de ce chapitre (partie \ref{subsection:list_of_moves}). Avec cette réduction, il nous reste $2^{17} = 131072$ sous-ensembles à énumérer. C'est bien mieux, mais nous allons pouvoir encore réduire ce nombre.
To reduce this number of configurations, we will not consider the squares on the board edges to remove the $1$ bits on ranks 1 and 8 and files a and h from the mask in table \ref{tab:mask_for_d3}. We obtain the bitboard in table \ref{tab:mask_for_d3_without_edge}. We will be missing information about the edges, but we will assume that if it's possible to play to {\ttfamily d7} for example, it will also be possible to play to {\ttfamily d8}. Of course there might be an obstacle at {\ttfamily d8}, but we can easily eliminate this impossible move as we will see later in this chapter (section \ref{subsection:list_of_moves}). With this reduction, we are left with $2^{17} = 131,072$ subsets to enumerate. That's much better, but we can still reduce this number further.\\

\begin{table}[htpb]
\centering
% \caption{Masque pour les cases atteignables pour la pièce en {\ttfamily d3} en excluant les bords du plateau}
\caption{Mask for reachable squares for the piece at {\ttfamily d3} excluding board edges}
\label{tab:mask_for_d3_without_edge}
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.5cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[1pt]0\end{tabular} \\[5pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[1pt]0\end{tabular} \\[5pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[1pt]0\end{tabular} \\[5pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[1pt]0\end{tabular} \\[5pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[1pt]0\end{tabular} \\[5pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[1pt]\textbf{1}\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[1pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[1pt]0\end{tabular} \\[5pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[1pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[1pt]0\end{tabular} \\[5pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[1pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[1pt]0\end{tabular} \\[5pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\end{table}

% En effet, on peut scinder les mouvements d'une pièce en mouvements diagonaux et orthogonaux. Nous obtiendrons deux tableaux~: \mintinline{c++}{MOVES_D3_DIAG} et \mintinline{c++}{MOVES_D3_ORTHO}. Nous aurons à consulter deux tableaux au lieu d'un seul, pour obtenir les coups possibles en {\ttfamily d3} (ou n'importe quelle autre case), mais nous allons gagner beaucoup de place mémoire. Nous verrons comment combiner les valeurs de ces deux tableaux plus loin dans ce chapitre. Au lieu du masque de la table \ref{tab:mask_for_d3_without_edge}, nous aurons maintenant les deux masques de la figure \ref{fig:diagonal_orthogonal_masks_d3}.
Indeed, we can split a piece's moves into diagonal and orthogonal moves. We will obtain two tables: \mintinline{c++}{MOVES_D3_DIAG} and \mintinline{c++}{MOVES_D3_ORTHO}. We will need to consult two tables instead of one to obtain the possible moves at {\ttfamily d3} (or any other square), but we will save a lot of memory space. We will see how to combine the values from these two tables later in this chapter. Instead of the mask from table \ref{tab:mask_for_d3_without_edge}, we will now have the two masks from figure \ref{fig:diagonal_orthogonal_masks_d3}.

% Pour le masque orthogonal de la figure \ref{fig:orthogonal_mask_d3}, on a $2^{10} = 1024$ sous-ensembles et pour le masque diagonal de la figure \ref{fig:diagonal_mask_d3}, on a $2^{7} = 128$ sous-ensembles, on passe donc de $2^{17} = 131072$ à $2^{10} + 2^{7} = 1152$ configurations d'obstacles à considérer pour la pièce en {\ttfamily d3}~!
For the orthogonal mask in figure \ref{fig:orthogonal_mask_d3}, we have $2^{10} = 1,024$ subsets and for the diagonal mask in figure \ref{fig:diagonal_mask_d3}, we have $2^{7} = 128$ subsets, so we go from $2^{17} = 131,072$ to $2^{10} + 2^{7} = 1,152$ obstacle configurations to consider for the piece at {\ttfamily d3}!\\

\begin{figure}[htpb]
\centering
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]0\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]0\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]0\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]0\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]0\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]\textbf{1}\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]0\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]0\end{tabular} \\[3pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]0\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Orthogonal mask}
\label{fig:orthogonal_mask_d3}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]0\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]0\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]0\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]0\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]0\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]0\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]0\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]0\end{tabular} \\[3pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]0\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Diagonal mask}
\label{fig:diagonal_mask_d3}
\end{subfigure}

\caption{Orthogonal and diagonal masks for d3 without edge squares}
\label{fig:diagonal_orthogonal_masks_d3}
\end{figure}

% Nous pouvons maintenant étudier comment trouver les constantes \mintinline{c++}{MAGIC} et \mintinline{c++}{K} pour les coups orthogonaux et diagonaux de chacune des cases du plateau. Le code est donné dans le listing \ref{lst:find_magic}\footnote{Nous avons essayé d'utiliser le solveur \gls{z3} pour obtenir ces constantes mais sans succès.}. Une exécution de ce programme\footnote{Au vu du générateur aléatoire et de son initialisation, le programme pourra trouver des constantes différentes pour des exécutions différentes.} est donnée dans le listing \ref{lst:find_magic_exec}\footnote{La sortie est reformatée pour être plus lisible.}.
We can now study how to find the \mintinline{c++}{MAGIC} and \mintinline{c++}{K} constants for the orthogonal and diagonal moves of each square on the board. The code is given in listing \ref{lst:find_magic}\footnote{We tried to use the \gls{z3} solver to obtain these constants but without success.}. An execution of this program\footnote{Given the random generator and its initialization, the program may find different constants for different executions.} is given in listing \ref{lst:find_magic_exec}\footnote{The output is reformatted for readability.}.

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{cpp}
constexpr uint64_t FileABB = 0x0101010101010101;
constexpr uint64_t FileHBB = FileABB << 7;
constexpr uint64_t Rank1BB = 0xFF;
constexpr uint64_t Rank8BB = Rank1BB << (8 * 7);

constexpr bool is_ok(Square s) { return s >= SQ_A1 && s <= SQ_H8; }

constexpr File file_of(Square s) { return File(s & 7); }

constexpr Rank rank_of(Square s) { return Rank(s >> 3); }

constexpr uint64_t rank_bb(Rank r) { return Rank1BB << (8 * r); }

constexpr uint64_t rank_bb(Square s) { return rank_bb(rank_of(s)); }

constexpr uint64_t file_bb(File f) { return FileABB << f; }

constexpr uint64_t file_bb(Square s) { return file_bb(file_of(s)); }

constexpr uint64_t square_bb(Square s) {
    return uint64_t(1) << s;
}

constexpr Square operator+(Square s, Direction d) { 
    return Square(int(s) + int(d)); 
}

int manhattan_distance(Square sq1, Square sq2) {
    int d_rank = std::abs(rank_of(sq1) - rank_of(sq2));
    int d_file = std::abs(file_of(sq1) - file_of(sq2));
    return d_rank + d_file;
}

enum MoveType {
    ORTHOGONAL,
    DIAGONAL
};

uint64_t reachable_squares(MoveType mt,Square sq,uint64_t occupied) {
    uint64_t  moves    = 0;
    Direction o_dir[4] = {NORTH, SOUTH, EAST, WEST};
    Direction d_dir[4]={NORTH_EAST,SOUTH_EAST,SOUTH_WEST,NORTH_WEST};
    for (Direction d : (mt == ORTHOGONAL ? o_dir : d_dir)) {
        Square s = sq;
        while (true) {            
            Square to = s + d;
            if (!is_ok(to) || manhattan_distance(s, to) > 2) break;
            uint64_t bb = square_bb(to);            
            if ((square_bb(to) & occupied) != 0) break;
            moves |= bb;
            s = to;
        } 
    }
    return moves;
}

std::pair<int, uint64_t> magic_for_square(MoveType mt, Square sq) {    
    using namespace std;
    uint64_t edges = ((Rank1BB | Rank8BB) & ~rank_bb(sq)) | 
                        ((FileABB | FileHBB) & ~file_bb(sq));
    uint64_t moves_bb = reachable_squares(mt, sq, 0) & ~edges;
    vector<uint64_t> occupancies;
    vector<uint64_t> possible_moves;
    uint64_t b = 0;
    int size = 0;
    do {
        occupancies.push_back(b);
        possible_moves.push_back(reachable_squares(mt, sq, b));
        size++;
        b = (b - moves_bb) & moves_bb;
    } while (b);
    int k = popcount(moves_bb);
    int shift = 64 - k;                
    random_device rd;
    mt19937_64 twister(rd());
    uniform_int_distribution<uint64_t> d;
    vector<uint32_t> seen(1 << k);
    vector<uint64_t> moves(1 << k);                    
    for (uint32_t cnt = 0;; cnt++) {
        uint64_t magic = d(twister) & d(twister) & d(twister);
        bool found = true;                    
        for (size_t j = 0; j < occupancies.size(); j++) {
            uint64_t occ = occupancies[j];
            int index = magic * occ >> shift;
            if (seen[index]==cnt && moves[index]!=possible_moves[j]) 
            {
                found = false;
                break;
            }
            seen[index] = cnt;
            moves[index] = possible_moves[j];
        }
        if (found) {
            return {k, magic};
        }
    }
    unreachable();
}

int main() {
    using namespace std;
    for (MoveType mt : {ORTHOGONAL, DIAGONAL}) {
        stringstream ss_k, ss_magic;
        ss_k << format("int {}_K[64] = {{",
                        mt == ORTHOGONAL ? "H" : "D");
        ss_magic << format("uint64_t {}_MAGIC[64] = {{",
                            mt == ORTHOGONAL ? "H" : "D");
        for (int sq = SQ_A1; sq <= SQ_H8; sq++) {
            const auto [k, magic] = magic_for_square(mt, Square(sq));
            ss_k << dec << k << ',';
            ss_magic << showbase << hex << magic << ',';
        }
        cout << ss_k.str() << "};\n";
        cout << ss_magic.str() << "};\n\n";
    }
}
\end{minted}
% \captionof{listing}{Programme permettant de trouver les constantes \mintinline{c++}{K} et \mintinline{c++}{MAGIC} du listing \ref{lst:magic_perfect_hashing} pour les configurations d'obstacles d'un type de mouvement et d'une case donnés}
\captionof{listing}{Program to find the \mintinline{c++}{K} and \mintinline{c++}{MAGIC} constants from listing \ref{lst:magic_perfect_hashing} for the obstacle configurations of a given move type and square}
\label{lst:find_magic}
\end{mdframed} 

% Dans le listing \ref{lst:find_magic},
In listing \ref{lst:find_magic},

\begin{itemize}

% \item À la ligne 39, la fonction \mintinline{c++}{uint64_t reachable_squares(MoveType mt, Square sq, uint64_t occupied)} va nous permettre de créer le masque des cases accessibles à partir de la case \mintinline{c++}{sq} et pour le type de mouvement \mintinline{c++}{mt}, qui sera soit orthogonal (\mintinline{c++}{ORTHOGONAL} à la ligne 35), soit diagonal (\mintinline{c++}{DIAGONAL} à la ligne 36). Le masque créé sera similaire aux masques de la figure \ref{fig:diagonal_orthogonal_masks_d3}.
\item At line 39, the function \mintinline{c++}{uint64_t reachable_squares(MoveType mt, Square sq, uint64_t occupied)} will allow us to create the mask of squares reachable from square \mintinline{c++}{sq} for the move type \mintinline{c++}{mt}, which will be either orthogonal (\mintinline{c++}{ORTHOGONAL} at line 35) or diagonal (\mintinline{c++}{DIAGONAL} at line 36). The created mask will be similar to the masks in figure \ref{fig:diagonal_orthogonal_masks_d3}.
\begin{itemize}
% \item Aux lignes 43 à 53, nous parcourons tour à tour une des directions selon le type de mouvement, en partant de la case de départ (\mintinline{c++}{sq}) jusqu'à rencontrer un obstacle.
\item At lines 43 to 53, we iterate through each direction according to the move type, starting from the starting square (\mintinline{c++}{sq}) until we encounter an obstacle.
% \item À la ligne 47, on test si on ne sort pas du plateau ou si on ne fait pas le tour, par exemple, si l'on se trouve dans la case \mintinline{c++}{SQ_A8} et que la direction est \mintinline{c++}{EAST}, \mintinline{c++}{SQ_H8 + EAST == SQ_B1}, le test avec la distance de Manhattan va nous permettre d'exclure ce genre de cas (voir à la ligne 28 la définition de la distance de Manhattan et le listing \ref{lst:files_and_ranks} pour les définitions de \mintinline{c++}{File} et \mintinline{c++}{Rank}).
\item At line 47, we test whether we go off the board or wrap around, for example, if we are at square \mintinline{c++}{SQ_A8} and the direction is \mintinline{c++}{EAST}, \mintinline{c++}{SQ_H8 + EAST == SQ_B1}, the test with Manhattan distance will allow us to exclude this kind of case (see line 28 for the definition of Manhattan distance and listing \ref{lst:files_and_ranks} for the definitions of \mintinline{c++}{File} and \mintinline{c++}{Rank}).
% \item À la ligne 48, on transforme la case de destination \mintinline{c++}{to} en un bitboard qui contient un seul $1$, sur le bit correspondant à la case.
\item At line 48, we transform the destination square \mintinline{c++}{to} into a bitboard that contains a single $1$, on the bit corresponding to the square.
% \item À la ligne 49, on test s'il n'y a pas un obstacle sur la case où l'on ve se rendre grâce au bitboard que l'on vient de créer et du bitboard \mintinline{c++}{occupied} contenant les obstacles du plateau.
\item At line 49, we test whether there is an obstacle on the square we want to move to using the bitboard we just created and the bitboard \mintinline{c++}{occupied} containing the obstacles on the board.
% \item À la ligne 50, on ajoute la nouvelle case comme coup possible.
\item At line 50, we add the new square as a possible move.
% \item À la ligne 51, on se déplace d'une case dans la direction \mintinline{c++}{d}.
\item At line 51, we move one square in direction \mintinline{c++}{d}.
\end{itemize}

% \item À la ligne 57, la fonction \mintinline{c++}{pair<int, uint64_t> magic_for_square(MoveType mt, Square sq)} va renvoyer une paire dont le premier élément sera la valeur de \mintinline{c++}{K}, et le deuxième élément sera la constante \mintinline{c++}{MAGIC} (voir listing \ref{lst:magic_perfect_hashing}), pour le type de mouvement \mintinline{c++}{mt} (\mintinline{c++}{ORTHOGONAL} ou \mintinline{c++}{DIAGONAL}) et la case \mintinline{c++}{sq}.
\item At line 57, the function \mintinline{c++}{pair<int, uint64_t> magic_for_square(MoveType mt, Square sq)} will return a pair whose first element will be the value of \mintinline{c++}{K}, and whose second element will be the \mintinline{c++}{MAGIC} constant (see listing \ref{lst:magic_perfect_hashing}), for the move type \mintinline{c++}{mt} (\mintinline{c++}{ORTHOGONAL} or \mintinline{c++}{DIAGONAL}) and square \mintinline{c++}{sq}.
\begin{itemize}
% \item Aux lignes 59 à 60, on crée un masque qui va couvrir les bords du plateaux mais en faisant attention de ne pas exclure des cases qui doivent rester accessibles par la pièce. Par exemple, si \mintinline{c++}{sq == SQ_A1}, on obtient le bitboard de la figure \ref{fig:edges_mask_a1} et si \mintinline{c++}{sq == SQ_C2}, on obtient celui de la figure \ref{fig:edges_mask_c2}.
\item At lines 59 to 60, we create a mask that will cover the board edges but being careful not to exclude squares that must remain accessible by the piece. For example, if \mintinline{c++}{sq == SQ_A1}, we obtain the bitboard from figure \ref{fig:edges_mask_a1} and if \mintinline{c++}{sq == SQ_C2}, we obtain the one from figure \ref{fig:edges_mask_c2}.

\begin{figure}[htpb]
\centering
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
1 & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Edge mask for square a1}
\label{fig:edges_mask_a1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]\textbf{1}\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Edge mask for square c2}
\label{fig:edges_mask_c2}
\end{subfigure}

\caption{Edge masks excluding the rank and file of the piece}
\label{fig:edge_masks}
\end{figure}

% \item À la ligne 61, on crée le bitboard \mintinline{c++}{moves_bb} des cases accessibles par la pièce à partir de la case \mintinline{c++}{sq}. Le paramètre \mintinline{c++}{occupied} est égal à zéro pour indiquer qu'il n'y a aucun obstacle. On retire les bords avec \mintinline{c++}{& ~edges} comme nous l'avions vu au paragraphe \ref{par:edge_exclusion}.
\item At line 61, we create the bitboard \mintinline{c++}{moves_bb} of squares accessible by the piece from square \mintinline{c++}{sq}. The parameter \mintinline{c++}{occupied} is equal to zero to indicate that there are no obstacles. We remove the edges with \mintinline{c++}{& ~edges} as we saw in paragraph \ref{par:edge_exclusion}.

% \item Aux lignes 62 à 71, on va créer toutes les configurations d'obstacles sur les cases accessibles par la pièce en \mintinline{c++}{sq}, sans considérer les cases dans \mintinline{c++}{edge}, en énumérant tous les sous-ensembles du bitboard \mintinline{c++}{moves_bb}.
\item At lines 62 to 71, we will create all obstacle configurations on the squares accessible by the piece at \mintinline{c++}{sq}, without considering the squares in \mintinline{c++}{edge}, by enumerating all subsets of the bitboard \mintinline{c++}{moves_bb}.

\begin{itemize}
% \item Aux lignes 62 et 63, le vecteur \mintinline{c++}{occupancies} va contenir toutes les configurations d'obstacles sur la trajectoire de la pièce, sans considérer les cases dans \mintinline{c++}{edge}, et pour chacune de ces configurations, le vecteur \mintinline{c++}{possible_moves} va contenir le bitboard des coups possibles pour cette configuration. Par exemple, on pourrait avoir comme configuration d'obstacles le bitboard de la figure \ref{fig:occupancy_d3_23} et les coups possibles associés seraient représentés par le bitboard de la figure \ref{fig:possible_moves_d3_23}.
\item At lines 62 and 63, the vector \mintinline{c++}{occupancies} will contain all obstacle configurations on the piece's trajectory, without considering the squares in \mintinline{c++}{edge}, and for each of these configurations, the vector \mintinline{c++}{possible_}\\\mintinline{c++}{moves} will contain the bitboard of possible moves for that configuration. For example, we could have as an obstacle configuration the bitboard from figure \ref{fig:occupancy_d3_23} and the associated possible moves would be represented by the bitboard from figure \ref{fig:possible_moves_d3_23}.

\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]0\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]0\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]0\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]0\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]0\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]0\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]0\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]0\end{tabular} \\[3pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]0\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Occupancy configuration example}
\label{fig:occupancy_d3_23}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.42\textwidth}
\centering
\small
\begin{tabular}{|c|*{8}{>{\centering\arraybackslash}p{0.4cm}|}}
\hline
8 & \begin{tabular}{@{}c@{}}{\tiny 56}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 57}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 58}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 59}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 60}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 61}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 62}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 63}\\[0pt]0\end{tabular} \\[3pt] \hline
7 & \begin{tabular}{@{}c@{}}{\tiny 48}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 49}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 50}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 51}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 52}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 53}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 54}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 55}\\[0pt]0\end{tabular} \\[3pt] \hline
6 & \begin{tabular}{@{}c@{}}{\tiny 40}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 41}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 42}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 43}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 44}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 45}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 46}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 47}\\[0pt]0\end{tabular} \\[3pt] \hline
5 & \begin{tabular}{@{}c@{}}{\tiny 32}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 33}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 34}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 35}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 36}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 37}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 38}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 39}\\[0pt]0\end{tabular} \\[3pt] \hline
4 & \begin{tabular}{@{}c@{}}{\tiny 24}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 25}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 26}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 27}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 28}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 29}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 30}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 31}\\[0pt]0\end{tabular} \\[3pt] \hline
3 & \begin{tabular}{@{}c@{}}{\tiny 16}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 17}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 18}\\[0pt]\textbf{1}\end{tabular} & \cellcolor{lightgray}\begin{tabular}{@{}c@{}}{\tiny 19}\\[0pt]\textbf{0}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 20}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 21}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 22}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 23}\\[0pt]0\end{tabular} \\[3pt] \hline
2 & \begin{tabular}{@{}c@{}}{\tiny 8}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 9}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 10}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 11}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 12}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 13}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 14}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 15}\\[0pt]0\end{tabular} \\[3pt] \hline
1 & \begin{tabular}{@{}c@{}}{\tiny 0}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 1}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 2}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 3}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 4}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 5}\\[0pt]\textbf{1}\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 6}\\[0pt]0\end{tabular} & \begin{tabular}{@{}c@{}}{\tiny 7}\\[0pt]0\end{tabular} \\[3pt] \hline
\multicolumn{1}{c|}{} & a & b & c & d & e & f & g & h \\
\cline{2-9}
\end{tabular}
\caption{Possible moves for this occupancy}
\label{fig:possible_moves_d3_23}
\end{subfigure}

\caption{Example of occupancy configuration and corresponding possible moves}
\label{fig:occupancy_example}
\end{figure}

% \item La boucle entre les lignes 66 et 71 va permettre d'énumérer tous les sous-ensembles du bitboard \mintinline{c++}{moves_bb}. On utilise pour se faire la technique appelée \emph{Carry-Rippler}\footnote{Si vous êtes intéressés par ce genre d'astuces de manipulation bit-à-bit, vous aimerez l'ouvrage \emph{Hacker's Delight}\cite{warren2012hackersdelight}.} à la ligne 70. Prenons un exemple fictif avec \mintinline{c++}{moves_bb = 0b1011}. On obtient alors
\item The loop between lines 66 and 71 will allow us to enumerate all subsets of the bitboard \mintinline{c++}{moves_bb}. To do this, we use the technique called \emph{Carry-Rippler}\footnote{If you are interested in this kind of bit manipulation tricks, you will love the book \emph{Hacker's Delight}\cite{warren2012hackersdelight}.} at line 70. Let's take a fictitious example with \mintinline{c++}{moves_bb = 0b1011}. We then obtain
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
uint64_t b = 0;                 // b == 0
b = (0 - 0b1011) & 0b1011;      // b == 0b0001
b = (0b0001 - 0b1011) & 0b1011; // b == 0b0010
b = (0b0010 - 0b1011) & 0b1011; // b == 0b0011
b = (0b0011 - 0b1011) & 0b1011; // b == 0b1000
b = (0b1000 - 0b1011) & 0b1011; // b == 0b1001
b = (0b1001 - 0b1011) & 0b1011; // b == 0b1010
b = (0b1010 - 0b1011) & 0b1011; // b == 0b1011
b = (0b1011 - 0b1011) & 0b1011; // b == 0
\end{minted}

\vspace{0.3cm}

% \item À la ligne 68, on crée les coups possibles pour la configuration d'obstacles \mintinline{c++}{b}. Notons que comme \mintinline{c++}{b} ne couvre pas les cases de \mintinline{c++}{edge}, si aucun obstacle dans \mintinline{c++}{b} ne bloque les déplacements de la pièce jusqu'à une case dans \mintinline{c++}{edge}, celle-ci apparaîtra dans les coups possibles.
\item At line 68, we create the possible moves for the obstacle configuration \mintinline{c++}{b}. Note that since \mintinline{c++}{b} does not cover the squares in \mintinline{c++}{edge}, if no obstacle in \mintinline{c++}{b} blocks the piece's moves to a square in \mintinline{c++}{edge}, it will appear in the possible moves.

\end{itemize}

% \item À la ligne 72, on compte le nombre de bits à $1$ dans le bitboard \mintinline{c++}{moves_bb}. Nous fixons \mintinline{c++}{k} à cette valeur, ce qui veut dire que pour la case \mintinline{c++}{sq} et le type de mouvement \mintinline{c++}{mt}, la place occupée par notre table de hachage parfait\footnote{C'est la façon de faire dans le logiciel Stockfish\cite{stockfish2025}.} sera de $2^k$. Notons que certaines configurations d'obstacles produisent les mêmes coups possibles, il est donc peut-être possible d'obtenir une valeur de \mintinline{c++}{k} plus petite. Mais cette façon de faire permet de trouver les différentes constantes \mintinline{c++}{MAGIC} très rapidement et la place mémoire consommée est relativement faible (moins $110$Kio en tout).
\item At line 72, we count the number of $1$ bits in the bitboard \mintinline{c++}{moves_bb}. We set \mintinline{c++}{k} to this value, which means that for square \mintinline{c++}{sq} and move type \mintinline{c++}{mt}, the space occupied by our perfect hash table\footnote{This is the approach used in the Stockfish software\cite{stockfish2025}.} will be $2^k$. Note that some obstacle configurations produce the same possible moves, so it might be possible to obtain a smaller value of \mintinline{c++}{k}. But this approach allows us to find the different \mintinline{c++}{MAGIC} constants very quickly and the memory consumed is relatively small (less than $110$ KiB in total).

% \item Aux lignes 74 à 76, on met en place le générateur aléatoire qui va nous permettre de créer les constantes \mintinline{c++}{MAGIC}.
\item At lines 74 to 76, we set up the random generator that will allow us to create the \mintinline{c++}{MAGIC} constants.

% \item À la ligne 77, le tableau \mintinline{c++}{seen} va nous permettre de mémoriser les indices, obtenues par la formule de la ligne 84, que l'on a déjà rencontrés.
\item At line 77, the array \mintinline{c++}{seen} will allow us to memorize the indices, obtained by the formula at line 84, that we have already encountered.

% \item À la ligne 78, le tableau \mintinline{c++}{moves} va nous permettre de mémoriser les coups possibles pour un indice donné. Il se peut que deux configurations d'obstacles différentes donnent lieu aux mêmes coups possibles, ce tableau nous permettra de ne pas considérer comme des collisions ces deux configurations différentes menant au même indice, mais ayant les mêmes coups possibles.
\item At line 78, the array \mintinline{c++}{moves} will allow us to memorize the possible moves for a given index. It may happen that two different obstacle configurations lead to the same possible moves, this array will allow us not to consider as collisions these two different configurations leading to the same index but having the same possible moves.

% \item La boucle de la ligne 79 à 96 va rechercher la constante \mintinline{c++}{MAGIC} permettant de créer le hachage parfait pour la case \mintinline{c++}{sq} et la valeur \mintinline{c++}{k}. Notons que cette boucle est potentiellement infinie. Nous informons le compilateur, à la ligne 97, que cette partie du code ne sera jamais atteinte grâce à la fonction \mintinline{c++}{std::unreachable}.
\item The loop from line 79 to 96 will search for the \mintinline{c++}{MAGIC} constant that allows creating the perfect hash for square \mintinline{c++}{sq} and value \mintinline{c++}{k}. Note that this loop is potentially infinite. We inform the compiler, at line 97, that this part of the code will never be reached thanks to the function \mintinline{c++}{std::unreachable}.

% \item À la ligne 80, on génère un candidat \mintinline{c++}{MAGIC}. On génère trois nombres aléatoires et on fait un ET bit-à-bit entre eux pour obtenir un nombre aléatoire avec moins de bits à $1$. Cette astuce est très importante car sans celle-ci nous n'arrivions pas à trouver un en temps raisonnable les constantes \mintinline{c++}{MAGIC}~!\footnote{Notons que l'utilisation de cette astuce pour le listing \ref{lst:random_magic} ralentissait l'obtention de la constante \mintinline{c++}{MAGIC}.}
\item At line 80, we generate a \mintinline{c++}{MAGIC} candidate. We generate three random numbers and perform a bitwise AND between them to obtain a random number with fewer $1$ bits. This trick is very important because without it we couldn't find the \mintinline{c++}{MAGIC} constants in a reasonable time!\footnote{Note that using this trick for listing \ref{lst:random_magic} slowed down obtaining the \mintinline{c++}{MAGIC} constant.}

% \item Aux lignes 82 à 92, on vérifie qu'il n'y a pas de collisions pour la constante considérée. Si c'est le cas, on retourne la valeur \mintinline{c++}{k} et la constante magique trouvée.
\item At lines 82 to 92, we verify that there are no collisions for the constant being considered. If this is the case, we return the value \mintinline{c++}{k} and the magic constant found.

\begin{itemize}
% \item À la ligne 84, pour une configuration d'obstacles donnée, on calcule son indice \mintinline{c++}{index} grâce à la fonction de hachage parfait~: \mintinline{c++}{(magic * occ >> (64 - k))}.
\item At line 84, for a given obstacle configuration, we calculate its index \mintinline{c++}{index} using the perfect hash function: \mintinline{c++}{(magic * occ >> (64 - k))}.

% \item À la ligne 85, on test s'il y a une collision. On utilise une petite astuce classique pour ne pas avoir à réinitialiser \mintinline{c++}{seen} à zéro à chaque fois que l'on va tester un nouveau candidat \mintinline{c++}{magic}. La variable \mintinline{c++}{cnt} nous permet de savoir si la valeur contenue dans seen pour la case index est une valeur mise à jour pour un ancien candidat \mintinline{c++}{magic} ou est pour le candidat actuel. En effet, si \mintinline{c++}{seen[index]} est inférieur à \mintinline{c++}{cnt}, la valeur n'est plus d'actualité. Maintenant, la partie \mintinline{c++}{(moves[index] != possible_moves[j])} nous permet d'ignorer une collision qui produit les mêmes coups possibles.
\item At line 85, we test whether there is a collision. We use a classic little trick to avoid having to reinitialize \mintinline{c++}{seen} to zero each time we test a new \mintinline{c++}{magic} candidate. The variable \mintinline{c++}{cnt} allows us to know whether the value contained in seen for position index is a value updated for an old \mintinline{c++}{magic} candidate or is for the current candidate. Indeed, if \mintinline{c++}{seen[index]} is less than \mintinline{c++}{cnt}, the value is no longer current. Now, the part \mintinline{c++}{(moves[index] != possible_moves[j])} allows us to ignore a collision that produces the same possible moves.

\end{itemize}

\end{itemize}

% \item Aux lignes 100 à 116, le \mintinline{c++}{main} va produire et afficher sur la sortie standard toutes les valeurs de \mintinline{c++}{k} et toutes les constantes \mintinline{c++}{MAGIC} pour chacune des cases du plateau et pour les deux types de mouvement. Ces constantes vont nous servir bientôt pour initialiser la table de tous les coups possibles pour chacune des configurations d'obstacles. On peut voir une sortie possible dans le listing \ref{lst:find_magic_exec}.
\item At lines 100 to 116, the \mintinline{c++}{main} will produce and display on standard output all values of \mintinline{c++}{k} and all \mintinline{c++}{MAGIC} constants for each square on the board and for both move types. These constants will soon be used to initialize the table of all possible moves for each of the obstacle configurations. We can see a possible output in listing \ref{lst:find_magic_exec}.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
\begin{minted}[fontsize=\small,breaklines,frame=none]{text}
$ g++ -O3 -march=native chapter02.cpp -o chapter02
$ ./chapter02
int O_K[64] = {
    12, 11, 11, 11, 11, 11, 11, 12,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    12, 11, 11, 11, 11, 11, 11, 12,
};
uint64_t O_MAGIC[64] = {
    0x80011040002082,     0x40022002100040,     0x1880200081181000,
    0x2080240800100080,   0x8080024400800800,   0x4100080400024100,
    0xc080028001000a00,   0x80146043000080,
    0x8120802080034004,   0x8401000200240,      0x202001282002044,
    0x81010021000b1000,   0x808044000800,       0x300080800c000200,
    0x8c000268411004,     0x810080058020c100,
    0xc248608010400080,   0x30024040002000,     0x9001010042102000,
    0x210009001002,       0xa0061d0018001100,   0x2410808004000600,
    0x6400240008025001,   0xc10600010340a4,
    0x628080044011,       0x4810014040002000,   0x380200080801000,
    0x10018580080010,     0x101040080180180,    0x9208020080040080,
    0x10400a21008,        0x6800104200010484,
    0x21400280800020,     0x9400402008401001,   0x8430006800200400,
    0x8104411202000820,   0x8010171000408,      0x1202000402001008,
    0x881100904002208,    0x15a0800a49802100,
    0x224001808004,       0x4420201002424000,   0xc04500020008080,
    0x2503009004210008,   0x42801010010,        0x2000400090100,
    0x8080011810040002,   0x44401c008046000d,
    0x4000800521104100,   0x82000b080400080,    0x10821022420200,
    0x9488a82104100100,   0x1004800041100,      0x81600a0034008080,
    0xa00056210280400,    0x5124088200,
    0x4210410010228202,   0x1802230840001081,   0x1002102000400901,
    0x1100c46010000901,   0x281000408001003,    0xc001001c00028809,
    0x10020008008c4102,   0x280005008c014222,
};

int D_K[64] = {
    6, 5, 5, 5, 5, 5, 5, 6,
    5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5,
    6, 5, 5, 5, 5, 5, 5, 6,
};
uint64_t D_MAGIC[64] = {
    0x811100100408200,    0x412100401044020,    0x404044c00408002,
    0xa0c070200010102,    0x104042001400008,    0x8802013008080000,
    0x1001008860080080,   0x20220044202800,
    0x2002610802080160,   0x4080800808610,      0x91c2800a10a0132,
    0x400242401822000,    0x8530040420040001,   0x142010c210048,
    0x8841820801241004,   0x804212084108801,
    0x2032402094100484,   0x40202110010210a2,   0x8010000800202020,
    0x800240421a800,      0x62200401a00444,     0x224082200820845,
    0x106021492012000,    0x8481020082849000,
    0x40a110c59602800,    0x10020108020400,     0x208c020844080010,
    0x2000480004012020,   0x8001004004044000,   0xa044104128080200,
    0x1108008015cc1400,   0x8284004801844400,
    0x8180a020c2004,      0x9101004080100,      0x8840264108800c0,
    0xc004200900200900,   0x8040008020020020,   0x20010802e1920200,
    0x80204000480a0,      0xc0a80a100008400,
    0x4018808114000,      0x90092200b9000,      0x80020c0048000400,
    0x6018005500,         0x80a0204110a00,      0x4018808407201,
    0x6050040806500280,   0x108208400c40180,
    0x803081210840480,    0x201210402200200,    0x200010400920042,
    0x902000a884110010,   0x851002021004,       0x43c08020120,
    0x6140500501010044,   0x200a04440400c028,
    0x14a002084046000,    0x10002409041040,     0x100022020500880b,
    0x1000000000460802,   0x21084104410,        0x8000001053300104,
    0x4000182008c20048,   0x112088105020200,
};
\end{minted}
\end{mdframed}
%\vspace{-\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Exemple de la sortie pour une exécution du programme du listing \ref{lst:find_magic}}
\captionof{listing}{Example output from one execution of the program from listing \ref{lst:find_magic}}
\label{lst:find_magic_exec}
\end{mdframed}
\
\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
uint64_t orthogonalTable[102400];
uint64_t diagonalTable[5248];
Magic orthogonalMagics[SQUARE_NB];
Magic diagonalMagics[SQUARE_NB];
\end{minted}
% \captionof{listing}{Les tableaux nous permettant de générer les coups possibles à partir d'une case donnée et d'une configuration d'obstacles}
\captionof{listing}{The tables allowing us to generate possible moves from a given square and an obstacle configuration}
\label{lst:magic_tables}
\end{mdframed}

% Maintenant que nous détenons les constantes \mintinline{c++}{MAGIC}, nous allons pouvoir initialiser grâce à elles des tableaux, décrits dans le listing \ref{lst:magic_tables}, qui vont stocker les informations nécessaires nous permettant de générer les coups possibles à partir d'une case donnée et d'une configuration d'obstacles.
Now that we have the \mintinline{c++}{MAGIC} constants, we will be able to use them to initialize the tables described in listing \ref{lst:magic_tables}, which will store the necessary information allowing us to generate possible moves from a given square and an obstacle configuration.
\begin{itemize}
% \item À la ligne 1, le tableau \mintinline{c++}{orthogonalTable} contiendra les bitboards des coups possibles pour tous les coups orthogonaux, pour toutes les cases et toutes les configurations d'obstacles. La valeur $102400$ pour la taille de ce tableau s'obtient en faisant
\item At line 1, the \mintinline{c++}{orthogonalTable} array will contain the bitboards of possible moves for all orthogonal moves, for all squares and all obstacle configurations. The value $102400$ for the size of this table is obtained by calculating
\begin{minted}[breaklines,fontsize=\small]{c++}
size_t size = 0;
for (int i = 0; i < 64; i++) {
    size += 1 << O_K[i];
}
\end{minted}
% \item À la ligne 2, le tableau \mintinline{c++}{diagonalTable} fera de même mais pour les coups diagonaux.
\item At line 2, the \mintinline{c++}{diagonalTable} array does the same but for diagonal moves.
% \item À la ligne 3, le tableau \mintinline{c++}{orthogonalMagics} va définir pour chaque case du plateau les différentes informations nous permettant d'appliquer le hachage parfait et retrouver les coups possibles dans le tableau \mintinline{c++}{orthogonalTable}.
\item At line 3, the \mintinline{c++}{orthogonalMagics} array will define for each square of the board the different information allowing us to apply the perfect hashing and retrieve the possible moves in the \mintinline{c++}{orthogonalTable} array.
% \item À la ligne 4, le tableau \mintinline{c++}{diagonalMagics} fera de même pour les coups diagonaux.
\item At line 4, the \mintinline{c++}{diagonalMagics} array does the same for diagonal moves.
\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
struct Magic {
    uint64_t  mask;
    uint64_t  magic;
    uint64_t* moves;
    uint32_t  shift;

    uint32_t index(uint64_t occupied) const {
        return uint32_t( ((occupied & mask) * magic) >> shift );
    }
};
\end{minted}
% \captionof{listing}{Structure de donnée nous permettant de stocker les informations utiles pour trouver les coups possibles pour une case et une configuration d'obstacles données}
\captionof{listing}{Data structure allowing us to store the useful information to find possible moves for a given square and obstacle configuration}
\label{lst:magic_struct}
\end{mdframed}

% Le listing \ref{lst:magic_struct} décrit la structure permettant de stocker les informations permettant d'appliquer le hachage parfait pour une case donnée.
Listing \ref{lst:magic_struct} describes the structure allowing us to store the information for applying the perfect hashing for a given square.
\begin{itemize}
% \item À la ligne 2, l'attribut \mintinline{c++}{mask} est le bitboard permettant d'isoler la partie du plateau qui contient les cases concernées par le déplacement de la pièce pour la case et le type de déplacement considérés. Ce masque correspond à la variable \mintinline{c++}{moves_bb} à la ligne 61 du listing \ref{lst:find_magic}.
\item At line 2, the \mintinline{c++}{mask} attribute is the bitboard allowing us to isolate the part of the board that contains the squares affected by the piece's movement for the considered square and movement type. This mask corresponds to the \mintinline{c++}{moves_bb} variable at line 61 of listing \ref{lst:find_magic}.

% \item À la ligne 3, l'attribut \mintinline{c++}{magic} est la constante \mintinline{c++}{MAGIC} que l'on a trouvé pour la case et le déplacement considérés. Ce attribut prendra la valeur d'une des constantes des tables \mintinline{c++}{O_MAGIC} ou \mintinline{c++}{D_MAGIC} du listing \ref{lst:find_magic_exec}.
\item At line 3, the \mintinline{c++}{magic} attribute is the \mintinline{c++}{MAGIC} constant that we found for the considered square and movement. This attribute will take the value of one of the constants from the \mintinline{c++}{O_MAGIC} or \mintinline{c++}{D_MAGIC} tables from listing \ref{lst:find_magic_exec}.

% \item À la ligne 4, l'attribut \mintinline{c++}{moves} est un pointeur sur la partie de la table \mintinline{c++}{orthogonalTable} ou \mintinline{c++}{diagonalTable}, selon le type de déplacement, qui contiendra les coups possibles pour la case considérée.
\item At line 4, the \mintinline{c++}{moves} attribute is a pointer to the part of the \mintinline{c++}{orthogonalTable} or \mintinline{c++}{diagonalTable}, depending on the movement type, that will contain the possible moves for the considered square.

% \item À la ligne 5, l'attribut \mintinline{c++}{shift} est le déplacement \mintinline{c++}{(64 - K)} dans la formule du listing \ref{lst:magic_perfect_hashing}.
\item At line 5, the \mintinline{c++}{shift} attribute is the shift \mintinline{c++}{(64 - K)} in the formula from listing \ref{lst:magic_perfect_hashing}.

% \item Aux lignes 7 à 9, la fonction \mintinline{c++}{uint32_t index(uint64_t occupied) const}, calcule la position dans \mintinline{c++}{moves} où trouver le bitboard des coups possibles. On retrouve la formule du listing \ref{lst:magic_perfect_hashing} avec le masque appliquée aux obstacles pour ne considérer que ceux dans la trajectoire de la pièce.
\item At lines 7 to 9, the function \mintinline{c++}{uint32_t index(uint64_t occupied) const} calculates the position in \mintinline{c++}{moves} where to find the bitboard of possible moves. We find the formula from listing \ref{lst:magic_perfect_hashing} with the mask applied to the obstacles to only consider those in the piece's trajectory.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
uint64_t moves_bb(Square sq, uint64_t occupied) {
    uint32_t idx_omoves = orthogonalMagics[sq].index(occupied);
    uint32_t idx_dmoves = diagonalMagics[sq].index(occupied);
    return orthogonalMagics[sq].moves[idx_omoves] | 
            diagonalMagics[sq].moves[idx_dmoves];
}
\end{minted}
% \captionof{listing}{La fonction \mintinline{c++}{moves_bb} utilisent les éléments des listings \ref{lst:magic_tables} et \ref{lst:magic_struct} pour calculer efficacement le bitboard des coups possibles pour une case et une configuration d'obstacles données}
\captionof{listing}{The \mintinline{c++}{moves_bb} function uses the elements from listings \ref{lst:magic_tables} and \ref{lst:magic_struct} to efficiently compute the bitboard of possible moves for a given square and obstacle configuration}
\label{lst:possible_moves}
\end{mdframed}

% La fonction \mintinline{c++}{uint64_t moves_bb(Square sq, uint64_t occupied)} du listing \ref{lst:possible_moves} va se servir des tables du listing \ref{lst:magic_tables} pour calculer le bitboard des coups possibles, orthogonaux et diagonaux, pour la case \mintinline{c++}{sq} et la configuration d'obstacles \mintinline{c++}{occupied}. C'est cette fonction qui sera utilisée pour la génération des coups dans la partie \ref{subsection:list_of_moves}. Pour ce faire,
The function \mintinline{c++}{uint64_t moves_bb(Square sq, uint64_t occupied)} from listing \ref{lst:possible_moves} will use the tables from listing \ref{lst:magic_tables} to compute the bitboard of possible moves, both orthogonal and diagonal, for the square \mintinline{c++}{sq} and the obstacle configuration \mintinline{c++}{occupied}. This function will be used for move generation in section \ref{subsection:list_of_moves}. To do this,

\begin{itemize}
% \item À la ligne 2, on calcule l'index \mintinline{c++}{idx_omoves}, grâce au hachage parfait, en utilisant la structure \mintinline{c++}{Magic} pour la case \mintinline{c++}{sq} et les coups orthogonaux.
\item At line 2, we compute the index \mintinline{c++}{idx_omoves} using the perfect hashing, by using the \mintinline{c++}{Magic} structure for the square \mintinline{c++}{sq} and orthogonal moves.

% \item À la ligne 3, on calcule l'index \mintinline{c++}{idx_dmoves}, grâce au hachage parfait, en utilisant la structure \mintinline{c++}{Magic} pour la case \mintinline{c++}{sq} et les coups diagonaux.
\item At line 3, we compute the index \mintinline{c++}{idx_dmoves} using the perfect hashing, by using the \mintinline{c++}{Magic} structure for the square \mintinline{c++}{sq} and diagonal moves.

% \item Aux lignes 4 et 5, on peut récupérer le bitboard des coups possibles orthogonaux (ligne 4) et faire l'union de ceux-ci avec les coups diagonaux en combinant ce bitboard par un OU bit-à-bit avec celui des coups possibles diagonaux (ligne 5). On obtient ainsi le bitboard de tous les coups possibles pour la pièce en \mintinline{c++}{sq} en prenant en considération tous les obstacles du bitboard \mintinline{c++}{occupied}.
\item At lines 4 and 5, we can retrieve the bitboard of possible orthogonal moves (line 4) and create the union of these with the diagonal moves by combining this bitboard using a bitwise OR with the bitboard of possible diagonal moves (line 5). We thus obtain the bitboard of all possible moves for the piece at \mintinline{c++}{sq}, taking into consideration all obstacles from the bitboard \mintinline{c++}{occupied}.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
void init_all_magics() {
    init_magics(ORTHOGONAL, orthogonalTable, orthogonalMagics);
    init_magics(DIAGONAL, diagonalTable, diagonalMagics);
}
\end{minted}
\captionof{listing}{Initialisation of all the magic bitboards}
\label{lst:magic_init}
\end{mdframed}

% La fonction \mintinline{c++}{void init()} du listing \ref{lst:magic_init} initialisera une fois pour toute, en début de programme, les différentes tables. On appelle juste aux lignes lignes 2 et 3 la fonction \mintinline{c++}{void init_magics(MoveType mt, uint64_t table[], Magic magics[])} décrite dans le listing \ref{lst:find_magics} pour les coups orthogonaux et diagonaux avec les tables associées.
The function \mintinline{c++}{void init_all_magics()} from listing \ref{lst:magic_init} will initialize once and for all, at the beginning of the program, the different tables. We simply call at lines 2 and 3 the function \mintinline{c++}{void init_magics(MoveType mt, uint64_t table[], Magic magics[])} described in listing \ref{lst:find_magics} for orthogonal and diagonal moves with their associated tables.\\ 

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
Square& operator++(Square& d) { return d = Square(int(d) + 1); }

void init_magics(MoveType mt, uint64_t table[], Magic magics[]) {
    static constexpr uint64_t O_MAGIC[64]={ 0x80011040002082, //...
    static constexpr uint64_t D_MAGIC[64]={ 0x811100100408200,//...
    using namespace std;
    int32_t size = 0;
    vector<uint64_t> occupancies;
    vector<uint64_t> possible_moves;
    for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
        occupancies.clear();
        possible_moves.clear();
        Magic& m = magics[sq];
        uint64_t edges = ((Rank1BB | Rank8BB) & ~rank_bb(sq)) | 
                            ((FileABB | FileHBB) & ~file_bb(sq));
        uint64_t moves_bb = reachable_squares(mt, sq, 0) & ~edges;
        m.mask = moves_bb;
        m.shift = 64 - popcount(m.mask);
        m.magic = (mt == ORTHOGONAL ? O_MAGIC : D_MAGIC)[sq];        
        m.moves = table + size;
        uint64_t b = 0;
        do {
            occupancies.push_back(b);
            possible_moves.push_back(reachable_squares(mt, sq, b));
            b = (b - moves_bb) & moves_bb;
            size++;
        } while (b);
        for (size_t j = 0; j < occupancies.size(); j++) {
            int32_t index = m.index(occupancies[j]);
            m.moves[index] = possible_moves[j];
        }
    }
}
\end{minted}
% Initialisation des différentes tables permettant d'obtenir le bitboard des coups possibles en fonction de la configuration des obstacles.
\captionof{listing}{Initialization of the various tables used to obtain the bitboard of possible moves based on the obstacle configuration.}
\label{lst:find_magics}
\end{mdframed} 


% La fonction \mintinline{c++}{void init_magics(MoveType mt, uint64_t table[], Magic magics[])} va initialiser les différentes tables pour le type de mouvement considéré \mintinline{c++}{mt}. Elle est très similaire à la fonction du listing \ref{lst:find_magic} qui nous a permis de trouver les constantes \mintinline{c++}{MAGIC}.
The function \mintinline{c++}{void init_magics(MoveType mt,uint64_t table[],Magic magics[])} will initialize the different tables for the considered movement type \mintinline{c++}{mt}. It is very similar to the function from listing \ref{lst:find_magic} which allowed us to find the \mintinline{c++}{MAGIC} constants.

\begin{itemize}
% \item Les lignes 4 et 5 reprennent les constantes magiques que nous avions trouvées en lançant le programme du listing \ref{lst:find_magic} et dont l'exécution fut donnée dans le listing \ref{lst:find_magic_exec}.
\item Lines 4 and 5 use the magic constants that we found by running the program from listing \ref{lst:find_magic}, whose execution output was given in listing \ref{lst:find_magic_exec}.

% \item À la ligne 8, le tableau \mintinline{c++}{occupancies} va contenir toutes les configurations d'obstacles pour la case considérée pour chaque tour de la boucle de la ligne 10. Le tableau \mintinline{c++}{possible_moves} lui va contenir le bitboard des coups possibles pour une configuration d'obstacles donnée. Notons que nous aurions pu placer ces deux tableaux à partir de la ligne 11, car ils doivent être réinitialisés à chaque tour de la boucle de la ligne 10. Mais il est plus efficace de faire appel à la méthode \mintinline{c++}{clear} aux lignes 11 et 12, cela va nous éviter des allocations inutiles.
\item At line 8, the \mintinline{c++}{occupancies} array will contain all obstacle configurations for the considered square for each iteration of the loop at line 10. The \mintinline{c++}{possible_moves} array will contain the bitboard of possible moves for a given obstacle configuration. Note that we could have placed these two arrays starting from line 11, since they must be reinitialized at each iteration of the loop at line 10. However, it is more efficient to call the \mintinline{c++}{clear} method at lines 11 and 12, which will avoid unnecessary allocations.

% \item La boucle comprenant les lignes 10 à 32, va mettre à jour le paramètre \mintinline{c++}{magics} pour toutes les cases du plateau et stocker les coups possibles dans une zone du paramètre \mintinline{c++}{table}.
\item The loop comprising lines 10 to 32 will update the \mintinline{c++}{magics} parameter for all squares of the board and store the possible moves in a region of the \mintinline{c++}{table} parameter.

% \item On peut reconnaître, des lignes 14 à 27, l'énumération des sous-ensembles d'obstacles que nous avons étudiez dans le listing \ref{lst:find_magic}. On va mettre à jour la structure \mintinline{c++}{Magic} \mintinline{c++}{m} de la ligne 13, correspondant à la case \mintinline{c++}{sq}, avec
\item We can recognize, from lines 14 to 27, the enumeration of obstacle subsets that we studied in listing \ref{lst:find_magic}. We will update the \mintinline{c++}{Magic} structure \mintinline{c++}{m} from line 13, corresponding to the square \mintinline{c++}{sq}, with
\begin{itemize}
% \item À la ligne 17, le masque des cases à considérer pour le déplacement de la pièce en \mintinline{c++}{sq} et le mouvement \mintinline{c++}{mt}.
\item At line 17, the mask of squares to consider for the movement of the piece at \mintinline{c++}{sq} and the movement type \mintinline{c++}{mt}.
% \item À la ligne 18, le décalage vers la droite à effectuer après la multiplication~: \mintinline{c++}{(occupied & mask) * magic} (voir listing \ref{lst:magic_struct}).
\item At line 18, the right shift to perform after the multiplication: \mintinline{c++}{(occupied & mask) * magic} (see listing \ref{lst:magic_struct}).
% \item À la ligne 19, la constante magique à utiliser pour le type de mouvement \mintinline{c++}{mt} et la case considérée \mintinline{c++}{sq}.
\item At line 19, the magic constant to use for the movement type \mintinline{c++}{mt} and the considered square \mintinline{c++}{sq}.
\end{itemize}

% \item À la ligne 20, on calcule l'adresse du début de l'emplacement dans la tableau \mintinline{c++}{table} qui va permettre de stocker les coups possibles pour chaque configuration d'obstacles. Pour se faire, on utilise la variable \mintinline{c++}{size} qui compte le nombre de configurations d'obstacles que nous avons traitées depuis le début de la boucle \mintinline{c++}{for}.
\item At line 20, we compute the address of the beginning of the location in the \mintinline{c++}{table} array that will allow us to store the possible moves for each obstacle configuration. To do this, we use the \mintinline{c++}{size} variable which counts the number of obstacle configurations we have processed since the beginning of the \mintinline{c++}{for} loop.

% \item Enfin, aux lignes 28 à 31, pour chaque configuration d'obstacles, on calcule son index grâce au hachage parfait et l'on stocke les coups possibles dans la zone du tableau \mintinline{c++}{table} réservée à cet effet.
\item Finally, at lines 28 to 31, for each obstacle configuration, we compute its index using the perfect hashing and we store the possible moves in the region of the \mintinline{c++}{table} array reserved for this purpose.

\end{itemize}


% Maintenant que nous avons à notre disposition la fonction \mintinline{c++}{moves_bb} du listing \ref{lst:possible_moves} il va être assez facile de générer la liste des coups possible dans une position donnée du jeu. Mais avant de faire cela, nous allons tout d'abord décrire la façon de représenter un coup.
Now that we have at our disposal the function \mintinline{c++}{moves_bb} from listing \ref{lst:possible_moves}, it will be quite easy to generate the list of possible moves in a given position of the game. But before doing that, we will first describe how to represent a move.

\subsection{Move Representation}

% Nous allons représenter un coup par une paire, dont le premier élément est la case de départ, et le deuxième élément est la case d'arrivée. Par exemple, la partie déroulée dans les figures \ref{fig:game_example_opening}, \ref{fig:game_example_middle} et \ref{fig:game_example_end} sera textuellement représentée par les coups suivants~:
We will represent a move by a pair, whose first element is the departure square and the second element is the arrival square. For example, the game shown in figures \ref{fig:game_example_opening}, \ref{fig:game_example_middle}, and \ref{fig:game_example_end} will be textually represented by the following moves:
\begin{minted}[breaklines,fontsize=\small,frame=none]{text}
a1:a2  h1:f3  h8:f6  a8:c6  d5:d6  d4:b2  d6:e6  e5:g5  f6:f5  f3:g4
f5:h7  g5:h5  e4:f4  h5:f7  e6:e8  g4:g1  e8:b8  b2:d2  a2:a3  g1:f2
a3:a6  d2:d3  f4:h2  d3:b5  a6:a4  b5:b3  a4:c4  b3:c3  h2:g2  f2:f1
b8:c7  c3:a5  c4:c5  c6:d7  g2:g3  f7:g7  c5:b4  a5:b6  g3:h4  b6:b7
h7:g8  d7:d8  c7:c8  f1:b1  g8:f8  d8:e7  h4:h3  a1:a1  b1:c1  a1:a1
c1:e1  a1:a1  e1:e3  a1:a1  e3:e2  a1:a1  e2:d1  a1:a1  d1:c2  a1:a1
g7:g6  a1:a1  g6:h6  a1:a1  b7:a7
\end{minted}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
class Move {
    uint16_t data;
public:
    Move() = default;
    constexpr explicit Move(uint16_t d) : data(d) {}
    constexpr explicit Move(Square from, 
                            Square to) : data((to << 6) + from) {}
    constexpr Square from_sq() const {
        return Square(data & 0x3F);
    }
    constexpr Square to_sq() const {
        return Square((data >> 6) & 0x3F);
    }    
    static constexpr Move none() { return Move(0); }
    constexpr bool operator==(const Move& m) const { 
        return data == m.data; 
    }
    constexpr bool operator!=(const Move& m) const { 
        return data != m.data; 
    }
    constexpr explicit operator bool() const { return data != 0; }
    constexpr uint16_t raw() const { return data; }
};

std::ostream& operator<<(std::ostream& os, const Move& m) {
    static constexpr std::string_view square2string[SQUARE_NB] = {
        "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1",
        "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
        "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
        "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
        "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
        "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
        "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
        "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
    };
    os << square2string[m.from_sq()] << ':' 
       << square2string[m.to_sq()];
    return os;
}
\end{minted}
% \captionof{listing}{Représentation d'un coup, les cases de départ et d'arrivée sont chacune stockées sur $6$ bits}
\captionof{listing}{Move representation, the departure and arrival squares are each stored on $6$ bits}
\label{lst:move_struct}
\end{mdframed} 

% La structure \mintinline{c++}{Move}, présentée dans le listing \ref{lst:move_struct}, représente un coup en utilisant un entier non signé sur 16 bits~: \mintinline{c++}{uint16_t data}. On a besoin de $6$ bits pour représenter la case de départ et de $6$ autres bits pour représenter la case d'arrivée.
The \mintinline{c++}{Move} structure, presented in listing \ref{lst:move_struct}, represents a move using an unsigned 16-bit integer: \mintinline{c++}{uint16_t data}. We need $6$ bits to represent the departure square and $6$ other bits to represent the arrival square.
\begin{itemize}
% \item Aux lignes 6-7, on construit le coup à partir de la case de départ \mintinline{c++}{from} et de la case d'arrivée \mintinline{c++}{to}. On place le numéro de la case de départ dans les $6$ bits de poids faibles de \mintinline{c++}{data} et la case d'arrivée à partir du bit $6$.
\item At lines 6-7, we construct the move from the departure square \mintinline{c++}{from} and the arrival square \mintinline{c++}{to}. We place the departure square number in the $6$ least significant bits of \mintinline{c++}{data} and the arrival square starting from bit $6$.

% \item À la ligne 8, la fonction \mintinline{c++}{Square from_sq()} permet de récupérer la case dont le numéro se trouve dans les bits $0$ à $5$ de \mintinline{c++}{data}. Ce qui correspond à la case de départ.
\item At line 8, the function \mintinline{c++}{Square from_sq()} retrieves the square whose number is located in bits $0$ to $5$ of \mintinline{c++}{data}. This corresponds to the departure square.

% \item À la ligne 11, la fonction \mintinline{c++}{Square to_sq()} permet de récupérer la case dont le numéro se trouve dans les bits $6$ à $11$ de \mintinline{c++}{data}. Ce qui correspond à la case d'arrivée.
\item At line 11, the function \mintinline{c++}{Square to_sq()} retrieves the square whose number is located in bits $6$ to $11$ of \mintinline{c++}{data}. This corresponds to the arrival square.

% \item On représente le fait de passer son tour, ce qui arrive quand on ne peut plus jouer mais que l'adversaire possède encore des coups à sa disposition, par le coup fictif {\ttfamily a1:a1}. La fonction \mintinline{c++}{Move none()}, décrite à la ligne 14, rend ce coup. La case de départ et la case d'arrivée sont \mintinline{c++}{SQ_A1 == 0}.
\item We represent passing one's turn, which occurs when a player can no longer move but the opponent still has moves available, by the fictitious move {\ttfamily a1:a1}. The function \mintinline{c++}{Move none()}, described at line 14, returns this move. The departure square and arrival square are both \mintinline{c++}{SQ_A1 == 0}.

% \item À la ligne 25, la fonction \mintinline{c++}{ostream& operator<<(std::ostream& os, const Move& m)} permet d'afficher un coup au format~: {\ttfamily case de départ:case d'arrivée}.
\item At line 25, the function \mintinline{c++}{ostream& operator<<(std::ostream& os, const Move& m)} displays a move in the format: {\ttfamily departure square:arrival square}.

\end{itemize}

\subsection{List of Moves for a Given Board Configuration}
\label{subsection:list_of_moves}

% La liste des coups possibles dans une configuration donnée du jeu est représentée par la classe \mintinline{c++}{MoveList} présentée dans le listing \ref{lst:move_list_class}.
The list of possible moves in a given game configuration is represented by the \mintinline{c++}{MoveList} class presented in listing \ref{lst:move_list_class}.

\begin{itemize}
% \item À la ligne 1, la constante \mintinline{c++}{MAX_NB_MOVES} est une borne supérieure du nombre maximum de coups possibles pour les joueurs. Dans la configuration de départ, le joueur noir a le choix entre $14 \times 4 = 56$ coups. Notons que ce nombre de coups possibles ne diminue pas forcément, par exemple, dans la configuration de la figure \ref{fig:more_moves}, le joueur noir a le choix entre $60$ coups. Pour obtenir cette borne supérieure, nous avons lancé beaucoup de parties aléatoires et observé le maximum de coups disponibles pour les joueurs durant ces parties.
\item At line 1, the constant \mintinline{c++}{MAX_NB_MOVES} is an upper bound on the maximum number of possible moves for the players. In the starting configuration, the black player has a choice of $14 \times 4 = 56$ moves. Note that this number of possible moves does not necessarily decrease; for example, in the configuration shown in figure \ref{fig:more_moves}, the black player has a choice of $60$ moves. To obtain this upper bound, we ran many random games and observed the maximum number of available moves for players during these games.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.5\textwidth]{more_moves.png}
% \caption{Dans cette position, le joueur noir a le choix entre $60$ coups}
\caption{In this position, the black player has a choice of $60$ moves}
\label{fig:more_moves}
\end{figure}

% \item À la ligne 3, les coups seront stockés dans le tableau \mintinline{c++}{move_list} qui, dans notre utilisation, comme nous le verrons plus tard, sera placé sur la pile. Le pointeur \mintinline{c++}{last} pointera sur la case juste après le dernier coup (ce qui est plus pratique pour l'implémentation). Par exemple, si le joueur courant ne dispose que des coups \mintinline{c++}{Move(SQ_A1, SQ_A2)} et \mintinline{c++}{Move(SQ_H8, SQ_G7)}, nous aurons alors la configuration suivante~:
\item At line 3, moves will be stored in the \mintinline{c++}{move_list} array which, in our usage as we will see later, will be placed on the stack. The \mintinline{c++}{last} pointer will point to the cell just after the last move (which is more convenient for implementation). For example, if the current player only has the moves \mintinline{c++}{Move(SQ_A1, SQ_A2)} and \mintinline{c++}{Move(SQ_H8, SQ_G7)}, we will have the following configuration:

\begin{verbatim}
                      last
                        |
                        v
    +-------+-------+-------+-------+     +-------+
    | a1:a2 | h8:g7 |       |       | ... |       |
    +-------+-------+-------+-------+     +-------+
       [0]     [1]     [2]     [3]           [74]
\end{verbatim}

% \item Aux lignes 6 à 9, les fonctions \mintinline{c++}{begin} et \mintinline{c++}{end} vont nous permettre d'itérer sur un objet de type \mintinline{c++}{MoveList}. Nous pourrons faire par exemple~:
\item At lines 6 to 11, the \mintinline{c++}{begin} and \mintinline{c++}{end} functions allow us to iterate over a \mintinline{c++}{MoveList} object. For example, we can write:
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
MoveList list;
// ...
for (Move m : list) {
    // ...
}
\end{minted}

% \item Le reste des fonctions vont nous permettre de récupérer la taille (\mintinline{c++}{size} à la ligne 10), de pouvoir indexer la liste comme un tableau (\mintinline{c++}{operator[]} aux lignes 11 à 14) et de récupérer directement le pointeur sur le début du tableau \mintinline{c++}{move_list} (\mintinline{c++}{data} à la ligne 15).
\item The remaining functions allow us to retrieve the size (\mintinline{c++}{size} at lines 12 to 14), index the list like an array (\mintinline{c++}{operator[]} at lines 15 to 18), and directly obtain the pointer to the beginning of the \mintinline{c++}{move_list} array (\mintinline{c++}{data} at line 19).

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
static constexpr uint16_t MAX_NB_MOVES = 75;
class MoveList {
    Move move_list[MAX_NB_MOVES], *last;
public:
    constexpr MoveList() noexcept : last(move_list) {}
    constexpr const Move* begin() const noexcept { 
        return move_list; 
    }
    constexpr const Move* end() const noexcept { return last; }
    constexpr Move* begin() noexcept { return move_list; }
    constexpr Move* end() noexcept { return last; }
    constexpr size_t size() const noexcept { 
        return last - move_list; 
    }
    constexpr const Move& operator[](size_t i) const { 
        return move_list[i]; 
    }
    constexpr Move& operator[](size_t i) { return move_list[i]; }
    constexpr Move* data() noexcept { return move_list; }
    friend class Yolah;
};
\end{minted}
% \captionof{listing}{Classe représentant une liste de coups}
\captionof{listing}{Class representing a list of moves}
\label{lst:move_list_class}
\end{mdframed}

% La fonction \mintinline{c++}{void Yolah::moves(uint8_t player, MoveList& moves)} présentée à la ligne 19 du listing \ref{lst:get_moves}, va placer dans le paramètre \mintinline{c++}{moves} de type \mintinline{c++}{MoveList} les coups possibles dans la configuration actuelle du jeu pour le joueur en paramètre (\mintinline{c++}{player}) (qui vaut soit \mintinline{c++}{BLACK}, soit \mintinline{c++}{WHITE})\footnote{Il s'avèrera intéressant dans la suite du livre de pouvoir récupérer les coups possibles d'un joueur même si ce n'est pas son tour de jouer.}. Dans cette fonction,
The function \mintinline{c++}{void Yolah::moves(uint8_t player, MoveList& moves)} presented at line 19 of listing \ref{lst:get_moves}, will store in the \mintinline{c++}{moves} parameter of type \mintinline{c++}{MoveList} the possible moves in the current game configuration for the player passed as parameter (\mintinline{c++}{player}) (which is either \mintinline{c++}{BLACK} or \mintinline{c++}{WHITE})\footnote{It will prove useful later in this book to be able to retrieve a player's possible moves even when it is not their turn to play.}. In this function,

\begin{itemize}
% \item La boucle entre les lignes 23 et 29 va parcourir chaque pièce du joueur \mintinline{c++}{player}, dont les positions sont données dans le bitboard \mintinline{c++}{bb}, et générer tous les coups possibles pour chacune d'entre elles.
\item The loop between lines 23 and 29 iterates over each piece of player \mintinline{c++}{player}, whose positions are given in the bitboard \mintinline{c++}{bb}, and generates all possible moves for each of them.
\begin{itemize}
% \item À la ligne 24, on récupère la case correspondant à la position du bit à $1$ le plus à droite dans le bitboard \mintinline{c++}{bb}. On utilise pour cela la fonction \mintinline{c++}{Square pop_lsb(uint64_t& b)} définie à la ligne 4. Cette fonction nous renvoie la case correspondant à la position du bit à $1$ le plus à droite dans le bitboard \mintinline{c++}{b} et, de plus, elle met un $0$ à la place du $1$ dans cette position. Par exemple,
\item At line 24, we retrieve the square corresponding to the position of the rightmost $1$ bit in the bitboard \mintinline{c++}{bb}. We use the function \mintinline{c++}{Square pop_lsb(uint64_t& b)} defined at line 4 for this purpose. This function returns the square corresponding to the position of the rightmost $1$ bit in the bitboard \mintinline{c++}{b} and, additionally, sets that bit to $0$. For example,
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
uint64_t bb = 0b1000100100010000;
Square sq = pop_lsb(bb);
// sq == SQ_E1
// bb ==      0b1000100100000000
\end{minted}

% \item À la ligne 25, on utilise notre fonction utilisant les bitboards magiques \mintinline{c++}{moves_bb} pour générer le bitboard contenant tous les coups possibles pour cette position et cette configuration d'obstacles. Nous avions dit au paragraphe \ref{par:edge_exclusion} à la page \pageref{par:edge_exclusion} que nous devrions gérer les éventuels obstacles sur les bords que nous avions ignorés. Rappelez-vous que pour limiter le nombre de configurations d'obstacles à considérer, nous avions ignoré les bords du plateau. En conséquence, il se peut que nous autorisions des coups sur les bords alors qu'il y a des obstacles. Il est très facile d'éliminer ces éventuels coups illégaux en éliminant les coups qui sont sur des cases occupées en faisant~: \mintinline{c++}{& ~occupied}.
\item At line 25, we use our magic bitboard function \mintinline{c++}{moves_bb} to generate the bitboard containing all possible moves for this position and obstacle configuration. We mentioned in paragraph \ref{par:edge_exclusion} on page \pageref{par:edge_exclusion} that we would need to handle potential obstacles on the edges that we had ignored. Remember that to limit the number of obstacle configurations to consider, we had ignored the board edges. As a consequence, we might allow moves to edge squares even when there are obstacles there. It is very easy to eliminate these potentially illegal moves by removing moves that land on occupied squares using: \mintinline{c++}{& ~occupied}.

% \item Aux lignes 26 à 28, nous parcourons le bitboard \mintinline{c++}{b} des coups possibles et utilisons de nouveau la fonction \mintinline{c++}{pop_lsb} pour récupérer les cases d'arrivée des différents coups (la position de départ étant la position \mintinline{c++}{from} de la pièce considérée), afin de construire un objet de type \mintinline{c++}{Move} que nous plaçons dans le tableau \mintinline{c++}{moves.move_list}.
\item At lines 26 to 28, we iterate through the bitboard \mintinline{c++}{b} of possible moves and again use the \mintinline{c++}{pop_lsb} function to retrieve the destination squares of the various moves (the starting position being the \mintinline{c++}{from} position of the piece under consideration), in order to construct a \mintinline{c++}{Move} object that we place in the \mintinline{c++}{moves.move_list} array.

\end{itemize}

% \item Aux lignes 30 à 32, on vérifie que le joueur avait au moins un coup à sa disposition, en regardant si le pointeur \mintinline{c++}{move_list} pointe toujours sur le début du tableau \mintinline{c++}{moves.move_list}. Si c'est le cas, ce qui n'est pas l'occurrence la plus fréquente\footnote{Nous indiquons cela en utilisant la construction \mintinline{c++}{[[unlikely]]} du langage C++.}, nous ajoutons le coup indiquant que le joueur passe (\mintinline{c++}{Move::none()}), comme unique coup possible pour le joueur.
\item At lines 30 to 32, we check whether the player had at least one move available, by checking if the \mintinline{c++}{move_list} pointer still points to the beginning of the \mintinline{c++}{moves.move_list} array. If so, which is not the most frequent occurrence\footnote{We indicate this using the C++ \mintinline{c++}{[[unlikely]]} attribute.}, we add the pass move (\mintinline{c++}{Move::none()}) as the only possible move for the player.

% \item Enfin, à la ligne 33, nous plaçons le pointeur de fin \mintinline{c++}{moves.last} sur la case juste après celle contenant le dernier coup.
\item Finally, at line 33, we set the end pointer \mintinline{c++}{moves.last} to the cell just after the one containing the last move.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
constexpr Square lsb(uint64_t b) {
    return Square(std::countr_zero(b));
}
Square pop_lsb(uint64_t& b) {
    const Square s = lsb(b);
    b &= b - 1;
    return s;
}
class Yolah {
    uint64_t black = BLACK_INITIAL_POSITION;
    uint64_t white = WHITE_INITIAL_POSITION;
    uint64_t holes = 0;
    uint8_t black_score = 0;
    uint8_t white_score = 0;
    uint8_t ply = 0;
public:
    // ...
};
void Yolah::moves(uint8_t player, MoveList& moves) const noexcept {
    Move* move_list = moves.move_list;
    uint64_t occupied = black | white | holes;
    uint64_t bb = player == BLACK ? black : white;
    while (bb) {
        Square   from = pop_lsb(bb);
        uint64_t b    = moves_bb(from, occupied) & ~occupied;
        while (b) {
            *move_list++ = Move(from, pop_lsb(b));
        }
    }
    if (move_list == moves.move_list) [[unlikely]] {
        *move_list++ = Move::none();
    }
    moves.last = move_list;
}
constexpr uint8_t Yolah::current_player() const noexcept {
    return ply & 1;
}
void Yolah::moves(MoveList& moves) const noexcept {
    this->moves(current_player(), moves);
}
\end{minted}
% \captionof{listing}{Génération des coups possibles pour un joueur dans la position courante du jeu}
\captionof{listing}{Generating possible moves for a player in the current game position}
\label{lst:get_moves}
\end{mdframed}

% La fonction \mintinline{c++}{uint8_t current_player()} positionnée à la ligne 35 du listing \ref{lst:get_moves} renvoie le joueur courant. Pour ce faire, elle teste si le nombre de coups joués depuis le début de la partie est pair ou impair. Le joueur noir joue dans les positions où \mintinline{c++}{ply} vaut 0, 2, 4, 6, \ldots, tandis que le joueur blanc joue dans les positions où \mintinline{c++}{ply} vaut 1, 3, 5, 7, \ldots. On teste la parité en regardant le bit de poids faible de \mintinline{c++}{ply} ; on obtient en faisant \mintinline{c++}{(ply & 1)}~: $0$ quand c'est pair (ce qui correspond bien à \mintinline{c++}{BLACK}) et $1$ quand c'est impair (ce qui correspond bien à \mintinline{c++}{WHITE}).
The function \mintinline{c++}{uint8_t current_player()} at line 35 of listing \ref{lst:get_moves} returns the current player. To do this, it tests whether the number of moves played since the beginning of the game is even or odd. The black player plays in positions where \mintinline{c++}{ply} equals 0, 2, 4, 6, \ldots, while the white player plays in positions where \mintinline{c++}{ply} equals 1, 3, 5, 7, \ldots. We test parity by examining the least significant bit of \mintinline{c++}{ply}; using \mintinline{c++}{(ply & 1)} yields: $0$ when even (which corresponds to \mintinline{c++}{BLACK}) and $1$ when odd (which corresponds to \mintinline{c++}{WHITE}). 

\subsection{Making and Unmaking Moves}
\label{subsection:making_and_unmaking_moves}

% Pour terminer l'implémentation de Yolah, il nous reste à pouvoir répercuter un coup dans le jeu. La fonction \mintinline{c++}{void play(Move m)} du listing \ref{lst:making_moves} va modifier l'état du plateau en jouant le coup \mintinline{c++}{m} passé en paramètre.
To complete the Yolah implementation, we still need to be able to apply a move to the game. The function \mintinline{c++}{void play(Move m)} in listing \ref{lst:making_moves} will modify the board state by playing the move \mintinline{c++}{m} passed as parameter.

\begin{itemize}
% \item À la ligne 2, on vérifie que le joueur ne passe pas son tour\footnote{Ce qu'il doit faire si et seulement s'il ne dispose d'aucun coup valide.}, nous utilisons la construction \mintinline{c++}{[[likely]]}, car il est beaucoup plus fréquent que le joueur puisse jouer. Qu'il passe ou non son tour, on incrémente, à la ligne 14, l'attribut \mintinline{c++}{ply} qui nous sert à compter le nombre de coups joués dans la partie et à déterminer le joueur courant.
\item At line 2, we check that the player is not passing their turn\footnote{Which they must do if and only if they have no valid move available.}; we use the \mintinline{c++}{[[likely]]} attribute because it is much more common for the player to be able to play. Whether they pass or not, we increment, at line 14, the \mintinline{c++}{ply} attribute which we use to count the number of moves played in the game and to determine the current player.

% \item À la ligne 3, \mintinline{c++}{pos1} est le bitboard correspondant à la case de départ du coup.
\item At line 3, \mintinline{c++}{pos1} is the bitboard corresponding to the move's source square.

% \item À la ligne 4, \mintinline{c++}{pos2} est le bitboard correspondant à la case d'arrivée du coup.
\item At line 4, \mintinline{c++}{pos2} is the bitboard corresponding to the move's destination square.

% \item À la ligne 5, on teste si c'est aux blancs de jouer.
\item At line 5, we test if it is white's turn to play.
\begin{itemize}
% \item Si c'est le cas, on va inverser, à la ligne 6, grâce au OU exclusif, les bits correspondant aux cases de départ et d'arrivée du coup dans le bitboard \mintinline{c++}{white} donnant la position des pièces du joueur blanc. Par exemple,
\item If so, we toggle, at line 6, using XOR, the bits corresponding to the source and destination squares of the move in the \mintinline{c++}{white} bitboard which gives the position of the white player's pieces. For example,
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
    uint64_t white = 0b1000100100010000;
    Move m = Move(SQ_E1, SQ_G1);
    uint64_t pos1 = square_bb(m.from_sq());
    // pos1 ==            0b010000;
    uint64_t pos2 = square_bb(m.to_sq());
    // pos2 ==            0b100000;
    // pos1 | pos2 ==     0b110000;
    // white == 0b1000100100010000;
    white ^= pos1 | pos2;
    // white == 0b1000100100100000;
\end{minted}
% Puis à la ligne 7, on augmente le score du joueur blanc car il vient d'effectuer un coup.
Then at line 7, we increase the white player's score because they have just made a move.

% \item Si c'est au noir de jouer, on procède de même, mais pour le bitboard \mintinline{c++}{black} du joueur noir à la ligne 9, et on augmente son score à la ligne 10.
\item If it is black's turn to play, we proceed similarly, but for the black player's \mintinline{c++}{black} bitboard at line 9, and we increase their score at line 10.

\end{itemize}

% \item À la ligne 12, on élimine la case de départ du coup en ajoutant un trou au bitboard \mintinline{c++}{holes} à la position correspondant à la case de départ du coup.
\item At line 12, we eliminate the source square of the move by adding a hole to the \mintinline{c++}{holes} bitboard at the position corresponding to the move's source square.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
void Yolah::play(Move m) {
    if (m != Move::none()) [[likely]] {                    
        uint64_t pos1 = square_bb(m.from_sq());
        uint64_t pos2 = square_bb(m.to_sq());
        if (ply & 1) {
            white ^= pos1 | pos2;
            white_score++;
        } else {
            black ^= pos1 | pos2;
            black_score++;
        }
        holes |= pos1;
    }
    ply++;
}
\end{minted}
% \captionof{listing}{Le coup \mintinline{c++}{m} est joué dans la position courante du jeu}
\captionof{listing}{The move \mintinline{c++}{m} is played in the current game position}
\label{lst:making_moves}
\end{mdframed}

% Il va s'avérer utile pour plusieurs de nos IA de pouvoir défaire le coup précédemment joué. La fonction \mintinline{c++}{void undo(Move m)} du listing \ref{lst:unmaking_moves} va effectuer le traitement inverse de celui effectué par la fonction \mintinline{c++}{void play(Move m)} afin de remettre le plateau de jeu dans l'état dans lequel il était avant de jouer le coup \mintinline{c++}{m}. Typiquement, on utilisera \mintinline{c++}{undo} comme suit~:
It will prove useful for several of our AIs to be able to undo the previously played move. The function \mintinline{c++}{void undo(Move m)} in listing \ref{lst:unmaking_moves} will perform the inverse operation of that performed by the function \mintinline{c++}{void play(Move m)} in order to restore the game board to the state it was in before playing move \mintinline{c++}{m}. Typically, we will use \mintinline{c++}{undo} as follows:
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
    /* return type */ recursive(Yolah& yolah, /* other parameters */) {
        // ...
        MoveList moves;
        yolah.moves(moves);
        for (Move m : moves) {
            yolah.play(m);
            recursive(yolah, /* ... */);
            yolah.undo(m);
        }
        // ...
        return // ...
    }    
\end{minted}

% Il est plus efficace, dans le listing précédent, d'utiliser la fonction \mintinline{c++}{undo} que de sauvegarder l'état complet du jeu avant l'appel récursif, puis de le restaurer après l'appel. Le benchmark du listing \ref{lst:undo_vs_restore_bench} teste cette affirmation. La fonction \mintinline{c++}{uint64_t count_nodes_with_undo(Yolah& yolah, int depth)} à la ligne 1 va tester la restauration de l'état du jeu grâce à la fonction \mintinline{c++}{undo} et va faire un nombre d'appels récursifs contrôlé par le paramètre \mintinline{c++}{depth}.\\
% La fonction \mintinline{c++}{uint64_t count_nodes_with_restore(Yolah& yolah, int depth)} à la ligne 15 va, quant à elle, tester la restauration grâce à la sauvegarde de l'état complet du jeu à la ligne 23. L'état précédent est restauré grâce à l'affectation à la ligne 28.\\
% Le résultat est donné dans le listing \ref{lst:undo_vs_restore_bench_result}. Le gain serait encore plus prononcé pour un jeu ayant un état plus conséquent que celui de Yolah.
In the previous listing, it is more efficient to use the \mintinline{c++}{undo} function than to save the complete game state before the recursive call and then restore it afterward. The benchmark in listing \ref{lst:undo_vs_restore_bench} tests this assertion. The function \mintinline{c++}{count_nodes_with_undo} at line 1 tests state restoration using the \mintinline{c++}{undo} function and makes a number of recursive calls controlled by the \mintinline{c++}{depth} parameter.\\
The function \mintinline{c++}{count_nodes_with_restore} at line 15 tests restoration by saving the complete game state at line 23. The previous state is restored via the assignment at line 28.\\
The results are given in listing \ref{lst:undo_vs_restore_bench_result}. The performance gain would be even more pronounced for a game with a larger state than Yolah's.

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
void Yolah::undo(Move m) {
    ply--;
    if (m != Move::none()) [[likely]] {                    
        uint64_t pos1 = square_bb(m.from_sq());
        uint64_t pos2 = square_bb(m.to_sq());
        if (ply & 1) {
            white ^= pos1 | pos2;
            white_score--;
        } else {
            black ^= pos1 | pos2;
            black_score--;
        }
        holes ^= pos1;
    }
}
\end{minted}
% \captionof{listing}{Le dernier coup joué \mintinline{c++}{m} est annulé}
\captionof{listing}{The last played move \mintinline{c++}{m} is undone}
\label{lst:unmaking_moves}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
uint64_t count_nodes_with_undo(Yolah& yolah, int depth) {
    if (depth == 0 || yolah.game_over()) {
        return 1;
    }
    uint64_t count = 0;
    MoveList moves;
    yolah.moves(moves);
    for (const Move& m : moves) {
        yolah.play(m);
        count += count_nodes_with_undo(yolah, depth - 1);
        yolah.undo(m);
    }
    return count;
}
uint64_t count_nodes_with_restore(Yolah& yolah, int depth) {
    if (depth == 0 || yolah.game_over()) {
        return 1;
    }
    uint64_t count = 0;
    MoveList moves;
    yolah.moves(moves);
    // Save the complete state
    Yolah saved = yolah;
    for (const Move& m : moves) {
        yolah.play(m);
        count += count_nodes_with_restore(yolah, depth - 1);
        // Restore the complete state
        yolah = saved;
    }
    return count;
}
static void BM_recursive_with_undo(benchmark::State& state) {
    int depth = state.range(0);
    for (auto _ : state) {
        Yolah yolah;
        uint64_t nodes = count_nodes_with_undo(yolah, depth);
        benchmark::DoNotOptimize(nodes);
    }
    // Calculate nodes for reporting
    Yolah yolah;
    uint64_t nodes = count_nodes_with_undo(yolah, depth);
    state.SetItemsProcessed(state.iterations() * nodes);
    state.counters["nodes"] = nodes;
}
static void BM_recursive_with_restore(benchmark::State& state) {
    int depth = state.range(0);
    for (auto _ : state) {
        Yolah yolah;
        uint64_t nodes = count_nodes_with_restore(yolah, depth);
        benchmark::DoNotOptimize(nodes);
    }
    Yolah yolah;
    uint64_t nodes = count_nodes_with_restore(yolah, depth);
    state.SetItemsProcessed(state.iterations() * nodes);
    state.counters["nodes"] = nodes;
}
// Test at various depths
BENCHMARK(BM_recursive_with_undo)->Arg(3)->Arg(4)->Arg(5);
BENCHMARK(BM_recursive_with_restore)->Arg(3)->Arg(4)->Arg(5);
int main(int argc, char** argv) {
    init_all_magics();
    benchmark::Initialize(&argc, argv);
    benchmark::RunSpecifiedBenchmarks();
}
\end{minted}
% \captionof{listing}{Benchmark pour tester l'affirmation que la fonction \mintinline{c++}{undo} apporte un gain par rapport à une sauvegarde de l'état complet du jeu}
\captionof{listing}{Benchmark to test the assertion that the \mintinline{c++}{undo} function provides a performance gain over saving the complete game state}
\label{lst:undo_vs_restore_bench}
\end{mdframed}

% \begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
% \begin{minted}[breaklines,fontsize=\small]{text}
% \begin{mdframed}[skipabove=\baselineskip,hidealllines=true,backgroundcolor=black]
% \color{white}
\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
\begin{minted}[fontsize=\small,breaklines,frame=none]{text}
$ g++ -O3 -march=native -Wall -Wpedantic undo_vs_restore_bench.cpp\
-o undo_vs_restore_bench -lbenchmark
$ ./undo_vs_restore_bench
Run on (12 X 4400 MHz CPU s)

CPU Caches: L1 Data 32 KiB (x6), L1 Instruction 32 KiB (x6),
            L2 Unified 256 KiB (x6), L3 Unified 12288 KiB (x1)

Benchmark                       Time (ms)   Throughput
------------------------------------------------------
BM_recursive_with_undo/3             1.09    150.4 M/s
BM_recursive_with_undo/4            56.50    153.1 M/s
BM_recursive_with_undo/5          3059.00    149.3 M/s
BM_recursive_with_restore/3          1.24    132.3 M/s
BM_recursive_with_restore/4         70.00    123.6 M/s
BM_recursive_with_restore/5       3492.00    130.8 M/s
\end{minted}
\end{mdframed}
%\vspace{-\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Résultats du benchmark du listing \ref{lst:undo_vs_restore_bench}}
\captionof{listing}{Benchmark results from listing \ref{lst:undo_vs_restore_bench}}
\label{lst:undo_vs_restore_bench_result}
\end{mdframed}

\section{Testing with Random Games}

% Nous présentons deux manières de tester notre implémentation de Yolah. Ces deux façons de faire se basent sur le déroulement de parties aléatoires. Dans un premier temps nous inspectons visuellement si tout semble correct, et une fois les éventuels bugs "faciles" détectés, nous passons à une batterie de tests importante, toujours en générant des parties aléatoires, mais cette fois-ci en testant des propriétés du jeu qui devraient être respectées par notre implémentation et en comparant la génération des coups à base de magic bitboards avec une implémentation beaucoup plus simple (mais bien moins efficace) pour vérifier que les deux implémentations différentes donnent les mêmes résultats. Une fois cette batterie de tests passée avec succès, nous profilons le code en générant un ensemble de parties aléatoires, et en nous basant sur cette analyse, nous améliorons le temps d'exécution du programme.

We present two ways of testing our implementation of Yolah. Both approaches are based on playing random games. First, we visually inspect whether everything appears correct, and once any "easy" bugs have been detected, we move on to a large battery of tests, again by generating random games, but this time by checking game properties that should be respected by our implementation and by comparing the move generation based on magic bitboards with a much simpler (but far less efficient) implementation, to verify that both different implementations produce the same results. Once this battery of tests has been passed successfully, we profile the code by generating a set of random games, and based on this analysis, we improve the program's execution time.

% \subsection{Tests par observation de parties aléatoires}
\subsection{Testing by Observing Random Games}

% Le code pour tester visuellement notre implémentation est donné dans le listing \ref{lst:random_games_testing}. Un début d'exécution de ce code est donné dans le listing \ref{lst:random_games_testing_exec}.

The code for visually testing our implementation is given in Listing~\ref{lst:random_games_testing}. The beginning of an execution of this code is shown in Listing~\ref{lst:random_games_testing_exec}.

\begin{itemize}

% \item Aux lignes 4 et 5, nous initialisons un générateur pseudo-aléatoire, soit avec une graine donnée par l'utilisateur (paramètre \mintinline{c++}{seed}) pour pouvoir reproduire le test, ou un nombre aléatoire en utilisant \mintinline{c++}{random_device}\footnote{Ce générateur va générer des nombres aléatoires de haute qualité, en utilisant par exemple {\ttfamily /dev/urandom} pour Linux. Par contre, l'obtention du nombre aléatoire va être assez lente comparée à l'utilisation d'un générateur pseudo-aléatoire comme \mintinline{c++}{mt19937} par exemple. Un des usages typiques de \mintinline{c++}{random_device} est d'initialiser un générateur pseudo-aléatoire comme nous le faisons ici.}.

\item At lines 4 and 5, we initialize a pseudo-random generator, either with a seed given by the user (parameter \mintinline{c++}{seed}) to make the test reproducible, or with a random number using \mintinline{c++}{random_device}\footnote{This generator produces high-quality random numbers, using for example {\ttfamily /dev/urandom} on Linux. However, obtaining the random number is rather slow compared to using a pseudo-random generator such as \mintinline{c++}{mt19937}. A typical use of \mintinline{c++}{random_device} is to seed a pseudo-random generator, as we do here.}.

% \item La boucle des lignes 6 à 25 va jouer \mintinline{c++}{nb_games} parties aléatoires.
\item The loop at lines 6 to 25 plays \mintinline{c++}{nb_games} random games.
\begin{itemize}
% \item À la ligne 7, on initialise une nouvelle partie.
\item At line 7, we initialize a new game.
% \item Aux lignes 8 à 23, on joue la partie aléatoire.
\item At lines 8 to 23, we play the random game.
\begin{itemize}
% \item Aux lignes 9 et 10, on récupère la liste des coups possibles dans la position actuelle du jeu et on les trie pour rendre l'affichage des coups possibles plus lisible.
\item At lines 9 and 10, we retrieve the list of possible moves in the current game position and sort them to make the display of possible moves more readable.
% \item Aux lignes 11 à 14, on affiche le nombre de coups possibles puis la liste de tous les coups. Vous pouvez voir le résultat dans le listing \ref{lst:random_games_testing_exec}.
\item At lines 11 to 14, we display the number of possible moves and then the list of all moves. You can see the result in Listing~\ref{lst:random_games_testing_exec}.
% \item À la ligne 16, on affiche le plateau avec les coups représentés par des croix. Cela permet de voir facilement si des coups manquent ou si des coups sont de trop.
\item At line 16, we display the board with the moves represented by crosses. This makes it easy to see if any moves are missing or if there are extra moves.
% \item Aux lignes 17 à 19, on choisit un coup aléatoirement et on l'affiche.
\item At lines 17 to 19, we randomly choose a move and display it.
% \item Aux lignes 20 et 21, on attend l'appui sur la touche entrée pour continuer la boucle. Cela nous laisse le temps d'analyser les sorties.
\item At lines 20 and 21, we wait for the Enter key to be pressed before continuing the loop. This gives us time to analyze the outputs.

\end{itemize}

\end{itemize}

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
\begin{minted}[linenos, breaklines,fontsize=\small]{c++}
void play_random_games(size_t nb_games, 
                       optional<uint64_t> seed = nullopt) {
    MoveList moves;
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    for (size_t i = 0; i < nb_games; i++) {
        Yolah yolah;    
        while (!yolah.game_over()) {                 
            yolah.moves(moves);
            sort(begin(moves), end(moves));
            cout << format("# moves: {}\n", moves.size());
            for (const auto& m : moves) {
                cout << m << ' ';
            }            
            cout << "\n\n";
            cout << YolahWithMoves(yolah, moves) << '\n';
            uniform_int_distribution<uint64_t> d(0, moves.size()-1);    
            Move m = moves[d(mt)];
            cout << m << '\n';
            std::string _;
            std::getline(std::cin, _);            
            yolah.play(m);
        }
        cout << yolah << '\n';
    }
}
int main() {
    init_all_magics();
    play_random_games(42);
}
\end{minted}
\captionof{listing}{Playing random games, displaying the list of moves and the board to check the engine visually}
\label{lst:random_games_testing}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -O3 -march=native -Wall -Wpedantic chapter02.cpp -o chapter02
$ ./chapter02
Black player
  ┌───┬───┬───┬───┬───┬───┬───┬───┐
8 │ ○ │ · │ · │ · │ · │ · │ · │ ● │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
7 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
6 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
5 │ · │ · │ · │ ● │ ○ │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
4 │ · │ · │ · │ ○ │ ● │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
3 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
2 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
1 │ ● │ · │ · │ · │ · │ · │ · │ ○ │
  └───┴───┴───┴───┴───┴───┴───┴───┘
    a   b   c   d   e   f   g   h
score: 0/0

# moves: 56
a1:b1 a1:c1 a1:d1 a1:e1 a1:f1 a1:g1 a1:a2 a1:b2 a1:a3 a1:c3 a1:a4 a1:a5
a1:a6 a1:a7 e4:b1 e4:e1 e4:c2 e4:e2 e4:g2 e4:d3 e4:e3 e4:f3 e4:f4 e4:g4
e4:h4 e4:f5 e4:g6 e4:h7 d5:a2 d5:b3 d5:c4 d5:a5 d5:b5 d5:c5 d5:c6 d5:d6
d5:e6 d5:b7 d5:d7 d5:f7 d5:d8 d5:g8 h8:h2 h8:h3 h8:h4 h8:h5 h8:f6 h8:h6
h8:g7 h8:h7 h8:b8 h8:c8 h8:d8 h8:e8 h8:f8 h8:g8



Black player
  ┌───┬───┬───┬───┬───┬───┬───┬───┐
8 │ ○ │ X │ X │ X │ X │ X │ X │ ● │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
7 │ X │ X │ · │ X │ · │ X │ X │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
6 │ X │ · │ X │ X │ X │ X │ X │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
5 │ X │ X │ X │ ● │ ○ │ X │ · │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
4 │ X │ · │ X │ ○ │ ● │ X │ X │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
3 │ X │ X │ X │ X │ X │ X │ · │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
2 │ X │ X │ X │ · │ X │ · │ X │ X │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
1 │ ● │ X │ X │ X │ X │ X │ X │ ○ │
  └───┴───┴───┴───┴───┴───┴───┴───┘
    a   b   c   d   e   f   g   h
score: 0/0

d5:a2

White player
  ┌───┬───┬───┬───┬───┬───┬───┬───┐
8 │ ○ │ · │ · │ · │ · │ · │ · │ ● │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
7 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
6 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
5 │ · │ · │ · │   │ ○ │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
4 │ · │ · │ · │ ○ │ ● │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
3 │ · │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
2 │ ● │ · │ · │ · │ · │ · │ · │ · │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
1 │ ● │ · │ · │ · │ · │ · │ · │ ○ │
  └───┴───┴───┴───┴───┴───┴───┴───┘
    a   b   c   d   e   f   g   h
score: 1/0

# moves: 55
h1:b1 h1:c1 h1:d1 h1:e1 h1:f1 h1:g1 h1:g2 h1:h2 h1:f3 h1:h3 h1:h4 h1:h5
h1:h6 h1:h7 d4:d1 d4:g1 d4:b2 d4:d2 d4:f2 d4:c3 d4:d3 d4:e3 d4:a4 d4:b4
d4:c4 d4:c5 d4:b6 d4:a7 e5:h2 e5:g3 e5:f4 e5:f5 e5:g5 e5:h5 e5:d6 e5:e6
e5:f6 e5:c7 e5:e7 e5:g7 e5:b8 e5:e8 a8:a3 a8:a4 a8:a5 a8:a6 a8:c6 a8:a7
a8:b7 a8:b8 a8:c8 a8:d8 a8:e8 a8:f8 a8:g8

White player
  ┌───┬───┬───┬───┬───┬───┬───┬───┐
8 │ ○ │ x │ x │ x │ x │ x │ x │ ● │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
7 │ x │ x │ x │ · │ x │ · │ x │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
6 │ x │ x │ x │ x │ x │ x │ · │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
5 │ x │ · │ x │   │ ○ │ x │ x │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
4 │ x │ x │ x │ ○ │ ● │ x │ · │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
3 │ x │ · │ x │ x │ x │ x │ x │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
2 │ ● │ x │ · │ x │ · │ x │ x │ x │
  ├───┼───┼───┼───┼───┼───┼───┼───┤
1 │ ● │ x │ x │ x │ x │ x │ x │ ○ │
  └───┴───┴───┴───┴───┴───┴───┴───┘
    a   b   c   d   e   f   g   h
score: 1/0

h1:f1


\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Début du déroulement du programme du listing \ref{lst:random_games_testing}}
\captionof{listing}{Beginning of the execution of the program from Listing~\ref{lst:random_games_testing}}
\label{lst:random_games_testing_exec}
\end{mdframed}

% \subsection{Tests différentiels et tests basés sur les propriétés}
\subsection{Differential Testing and Property-Based Testing}

% L'observation des parties aléatoires précédentes nous permet de détecter rapidement des bugs éventuels. Cette façon de faire est bien pratique pour voir en détail le fonctionnement de notre programme. Mais nous voulons aussi une manière de tester automatiquement notre jeu. Pour ce faire, nous allons tester le jeu en testant des propriétés qu'il doit vérifier. Nous allons aussi générer les coups possibles d'une manière simple (et peu efficace) dans laquelle nous avons une grande confiance, justement car elle est basique à implémenter, et pouvoir comparer les coups générés par notre jeu avec ceux générés simplement. Tous ces tests se feront sur des parties générées aléatoirement. Nous allons ainsi pouvoir produire assez facilement une très grande quantité de tests. Cette façon de tester s'appelle les \emph{tests basés sur les propriétés} \cite{claessen2000quickcheck} et les \emph{tests différentiels} \cite{mckeeman1998differential}. Les tests basés sur les propriétés consistent à vérifier que certaines propriétés invariantes sont toujours respectées lors de l'exécution de scénarios générés aléatoirement. Les tests différentiels comparent les résultats de deux implémentations différentes du même algorithme~: une implémentation optimisée (notre générateur de coups avec magic bitboards) et une implémentation de référence simple mais manifestement correcte.

Observing the previous random games allows us to quickly detect potential bugs. This approach is very convenient for seeing in detail how our program works. But we also want a way to automatically test our game. To do so, we will test the game by checking properties that it must satisfy. We will also generate possible moves in a simple (and inefficient) way in which we have high confidence, precisely because it is straightforward to implement, and compare the moves generated by our game with those generated simply. All these tests will be performed on randomly generated games. This way, we can easily produce a very large number of tests. This testing approach is known as \emph{property-based testing}~\cite{claessen2000quickcheck} and \emph{differential testing}~\cite{mckeeman1998differential}. Property-based testing consists of verifying that certain invariant properties are always respected during the execution of randomly generated scenarios. Differential testing compares the results of two different implementations of the same algorithm: an optimized implementation (our move generator with magic bitboards) and a simple but obviously correct reference implementation.\\

% Le code du listing \ref{lst:random_games_property_based_testing} illustre cette approche des tests.

The code in Listing~\ref{lst:random_games_property_based_testing} illustrates this testing approach.

\begin{itemize}
% \item Aux lignes 8 à 12, la structure \mintinline{c++}{TestResult} va contenir le résultat d'un test donné. L'attribut \mintinline{c++}{passed} est à vrai lorsque le test a réussi et à faux sinon. L'attribut \mintinline{c++}{message} stocke le diagnostic qui sera utilisé en cas d'erreur (voir la fonction \mintinline{c++}{run_test} à la ligne 165).
\item At lines 8 to 12, the \mintinline{c++}{TestResult} structure holds the result of a given test. The \mintinline{c++}{passed} attribute is true when the test succeeds and false otherwise. The \mintinline{c++}{message} attribute stores the diagnostic that will be used in case of failure (see the \mintinline{c++}{run_test} function at line 165).

% \item À la ligne 14, la fonction \mintinline{c++}{pass} rend un \mintinline{c++}{TestResult} qui indique que le test s'est déroulé correctement.
\item At line 14, the \mintinline{c++}{pass} function returns a \mintinline{c++}{TestResult} indicating that the test ran successfully.

% \item À la ligne 15, la fonction \mintinline{c++}{fail(string msg)} rend un \mintinline{c++}{TestResult} qui indique que le test a échoué avec le diagnostic d'erreur \mintinline{c++}{msg}.
\item At line 15, the \mintinline{c++}{fail(string msg)} function returns a \mintinline{c++}{TestResult} indicating that the test failed with the error diagnostic \mintinline{c++}{msg}.

% \item Aux lignes 17 à 44 est définie la fonction \mintinline{c++}{slow_moves_generation} qui permet d'obtenir la liste des coups possibles dans la configuration du jeu \mintinline{c++}{yolah} passée en paramètre (ligne 182). Cette fonction va nous permettre de faire les tests différentiels. Comme nous le disions, cette façon de générer les coups est bien plus simple que celle à base de bitboards magiques. Nous avons une grande confiance dans l'exactitude de \mintinline{c++}{slow_moves_generation}. Les boucles aux lignes 19 et 20, vont parcourir toutes les cases du plateau. On construit la case de départ du coup \mintinline{c++}{from} à la ligne 21, puis on vérifie à la ligne 22 que cette case contient un pion du joueur pour lequel on crée la liste de coups. Les fonctions \mintinline{c++}{square_of} et \mintinline{c++}{get} sont définies précisément dans le listing \ref{lst:chapter02}, mais \mintinline{c++}{Square square_of(int rank, int file)} va créer une case à partir des coordonnées \mintinline{c++}{(rank, file)} et \mintinline{c++}{uint8_t Yolah::get(Square sq)} retourne le type d'élément (un des joueurs, un trou ou un emplacement libre) sur la case \mintinline{c++}{sq}.
% Les boucles aux lignes 23 et 24 vont parcourir toutes les directions possibles pour la pièce, on fait attention à filtrer le déplacement nul à la ligne 25. Enfin, la boucle de la ligne 28 à 37 va se déplacer dans la direction choisie \mintinline{c++}{(di, dj)} tant qu'on ne sort pas du plateau et qu'il n'y a pas d'obstacles. Si on sort du plateau à la ligne 29, ou qu'un obstacle est détecté à la ligne 33, on sort de la boucle pour essayer une nouvelle direction. On n'oublie pas à la ligne 42 d'ajouter le coup \mintinline{c++}{Move::none()} si aucun coup n'était possible. Cette façon de construire tous les coups possibles est très intuitive (mais inefficace).
\item At lines 17 to 44, the \mintinline{c++}{slow_moves_generation} function is defined, which returns the list of possible moves in the game configuration \mintinline{c++}{yolah} passed as parameter (line 182). This function will allow us to perform the differential tests. As we mentioned, this way of generating moves is much simpler than the magic bitboard approach. We have high confidence in the correctness of \mintinline{c++}{slow_moves_generation}. The loops at lines 19 and 20 iterate over all squares on the board. We construct the move's source square \mintinline{c++}{from} at line 21, then check at line 22 that this square contains a piece belonging to the player for whom we are generating the move list. The functions \mintinline{c++}{square_of} and \mintinline{c++}{get} are defined precisely in Listings~\ref{lst:board_code_1}--\ref{lst:board_code_4}, but \mintinline{c++}{Square square_of(int rank, int file)} creates a square from coordinates \mintinline{c++}{(rank, file)} and \mintinline{c++}{uint8_t Yolah::get(Square sq)} returns the type of element (one of the players, a hole, or a free square) at square \mintinline{c++}{sq}.
The loops at lines 23 and 24 iterate over all possible directions for the piece, taking care to filter out the null displacement at line 25. Finally, the loop from line 28 to 37 moves in the chosen direction \mintinline{c++}{(di, dj)} as long as we do not leave the board and there are no obstacles. If we leave the board at line 29, or an obstacle is detected at line 33, we break out of the loop to try a new direction. We do not forget at line 42 to add \mintinline{c++}{Move::none()} if no move was possible. This way of building all possible moves is very intuitive (but inefficient).

% \item Aux lignes 46 à 53, la fonction \mintinline{c++}{check_move_count} est notre premier test différentiel. Le premier paramètre \mintinline{c++}{fast} est la liste des coups obtenue grâce aux bitboards magiques, et le deuxième paramètre \mintinline{c++}{expected} est la liste de coups obtenue avec la fonction précédente. Nous vérifions dans ce test que les nombres de coups produits par les deux approches sont bien identiques.
\item At lines 46 to 53, the \mintinline{c++}{check_move_count} function is our first differential test. The first parameter \mintinline{c++}{fast} is the move list obtained using magic bitboards, and the second parameter \mintinline{c++}{expected} is the move list obtained with the previous function. In this test, we verify that the number of moves produced by both approaches is identical.

% \item Aux lignes 55 à 84, la fonction \mintinline{c++}{check_move_lists_equal} est notre deuxième et dernier test différentiel. On vérifie que les listes de coups sont identiques, en les triant tout d'abord aux lignes 58 et 59, puis en vérifiant que les deux listes de coups sont maintenant identiques aux lignes 60 et 61. Le reste de la fonction crée un message d'erreur en calculant les différences entre les deux listes.
\item At lines 55 to 84, the \mintinline{c++}{check_move_lists_equal} function is our second and last differential test. We verify that the move lists are identical, by first sorting them at lines 58 and 59, then checking that both move lists are now identical at lines 60 and 61. The rest of the function builds an error message by computing the differences between the two lists.

% \item Aux lignes 86 à 92, la fonction \mintinline{c++}{check_undo} va vérifier la propriété suivante.
% Soit \mintinline{c++}{yolah} une configuration quelconque du jeu et \mintinline{c++}{m} un coup possible dans cette position. Posons \mintinline{c++}{Yolah before = yolah;}, puis effectuons les actions suivantes.
\item At lines 86 to 92, the \mintinline{c++}{check_undo} function verifies the following property.
Let \mintinline{c++}{yolah} be any game configuration and \mintinline{c++}{m} a possible move in this position. Let \mintinline{c++}{Yolah before = yolah;}, then perform the following actions.
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
    yolah.play(m);
    yolah.undo(m);
    Yolah after = yolah;
\end{minted}
% On vérifie que l'annulation d'un coup fonctionne correctement en testant si \mintinline{c++}{before == after} à la ligne 87.
We verify that undoing a move works correctly by testing whether \mintinline{c++}{before == after} at line 87.

% \item La deuxième propriété que l'on va tester est donnée dans la fonction \mintinline{c++}{check_game_over_moves} aux lignes 94 à 101. On y teste que le seul coup possible dans une position terminale du jeu est le coup \mintinline{c++}{Move::none()}. En effet, les joueurs n'ont plus de coups à disposition et ils doivent donc passer leur tour. À la ligne 96, on vérifie qu'il n'y a qu'un seul coup et que celui-ci est bien le coup \mintinline{c++}{Move::none()}.
\item The second property we test is given in the \mintinline{c++}{check_game_over_moves} function at lines 94 to 101. We test that the only possible move in a terminal game position is \mintinline{c++}{Move::none()}. Indeed, the players have no more moves available and must therefore pass their turn. At line 96, we verify that there is only one move and that it is indeed \mintinline{c++}{Move::none()}.

% \item Aux lignes 103 à 119, la fonction \mintinline{c++}{check_none_move_execution} va tester la propriété que le coup \mintinline{c++}{Move::none()} doit seulement incrémenter le nombre de coups dans la partie. Pour ce faire, la boucle à la ligne 106 va tester à la ligne 107, que le contenu de chaque case n'a pas changé après l'exécution du coup nul. Ensuite, à la ligne 115, on teste si le nombre de coups a bien été incrémenté.
\item At lines 103 to 119, the \mintinline{c++}{check_none_move_execution} function tests the property that \mintinline{c++}{Move::none()} should only increment the move count in the game. To do this, the loop at line 106 checks at line 107 that the content of each square has not changed after executing the null move. Then, at line 115, we test whether the move count has been properly incremented.

% \item Aux lignes 121 à 156, la fonction \mintinline{c++}{check_regular_move_execution} va tester les propriétés que doit vérifier un coup normal. Aux lignes 126 à 132, on vérifie que les cases qui ne sont pas concernées par le coup n'ont pas changé.
% Aux lignes 133 à 137, on vérifie que le nombre de coups a été incrémenté, qu'un trou est apparu sur la case de départ du coup et enfin que la pièce se trouve maintenant sur la case d'arrivée du coup.
\item At lines 121 to 156, the \mintinline{c++}{check_regular_move_execution} function tests the properties that a regular move must satisfy. At lines 126 to 132, we verify that the squares not involved in the move have not changed. At lines 133 to 137, we verify that the move count has been incremented, that a hole has appeared on the move's source square, and finally that the piece is now on the move's destination square.

% \item Aux lignes 158 à 234, la fonction \mintinline{c++}{random_games} va lancer tous les tests sur \mintinline{c++}{nb_games} parties aléatoires aux lignes 178 à 219. Les lignes 221 à 233 affichent un résumé des tests.
\item At lines 158 to 234, the \mintinline{c++}{random_games} function runs all tests on \mintinline{c++}{nb_games} random games at lines 178 to 219. Lines 221 to 233 display a test summary.

% \item Le listing \ref{lst:random_games_property_based_testing_exec} donne le résultat de l'exécution du \mintinline{c++}{main}. Même si, comme le disait Dijkstra, "Program testing can be used to show the presence of bugs, but never to show their absence," et qu'il faille toujours rester prudent, le grand nombre de configurations du jeu explorées nous donne néanmoins une bonne confiance dans la validité de notre implémentation de Yolah. Maintenant que nous avons testé notre implémentation, nous allons étudier les performances de celle-ci.
\item Listing~\ref{lst:random_games_property_based_testing_exec} shows the result of executing the \mintinline{c++}{main}. Even though, as Dijkstra said, "Program testing can be used to show the presence of bugs, but never to show their absence," and one must always remain cautious, the large number of game configurations explored nonetheless gives us good confidence in the validity of our Yolah implementation. Now that we have tested our implementation, we will study its performance.

\end{itemize}


\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
namespace test {
constexpr string_view RED    = "\033[1;31m";
constexpr string_view GREEN  = "\033[1;32m";
constexpr string_view YELLOW = "\033[1;33m";
constexpr string_view RESET  = "\033[0m";
constexpr string_view BOLD   = "\033[1m";

struct TestResult {
    bool passed;
    string message;
    operator bool() const { return passed; }
};

TestResult pass() { return {true, ""}; }
TestResult fail(string msg) { return {false, std::move(msg)}; }

vector<Move> slow_moves_generation(const Yolah& yolah) {
    vector<Move> res;
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            Square from = square_of(i, j);
            if (yolah.get(from) != yolah.current_player()) continue;
            for (int di = -1; di <= 1; di++) {
                for (int dj = -1; dj <= 1; dj++) {
                    if (di == 0 && dj == 0) continue;
                    int ii = i + di;
                    int jj = j + dj;
                    for(;;) {
                        if (ii < 0 || ii >= 8 || jj < 0 || jj >= 8) {
                            break;
                        }
                        Square to = square_of(ii, jj);                                
                        if (yolah.get(to) != FREE) break;                                
                        res.emplace_back(from, to);
                        ii += di;
                        jj += dj;
                    }
                }
            }
        }
    }
    if (res.empty()) res.push_back(Move::none());
    return res;
};

TestResult check_move_count(const MoveList& fast, 
                            const vector<Move>& expected) {
    if (fast.size() != expected.size()) {
        return fail(format("# of moves: expected {} got {}", 
                           expected.size(), fast.size()));
    }
    return pass();
}

TestResult check_move_lists_equal(MoveList& fast, 
                                  vector<Move>& expected, 
                                  const Yolah& yolah) {
    sort(begin(fast), end(fast));
    sort(begin(expected), end(expected));
    if (equal(begin(fast), end(fast), 
              begin(expected), end(expected))) {
        return pass();
    }
    ostringstream oss;
    oss << "move lists differ\n" << yolah << '\n';
    vector<Move> only_in_fast, only_in_expected;
    set_difference(begin(fast), end(fast), 
                   begin(expected), end(expected), 
                   back_inserter(only_in_fast));
    set_difference(begin(expected), end(expected), 
                   begin(fast), end(fast), 
                   back_inserter(only_in_expected));
    if (!only_in_expected.empty()) {
        oss << "  Only in expected: ";
        for (const auto& m : only_in_expected) oss << m << ' ';
        oss << '\n';
    }
    if (!only_in_fast.empty()) {
        oss << "  Only in fast: ";
        for (const auto& m : only_in_fast) oss << m << ' ';
        oss << '\n';
    }
    return fail(oss.str());
}

TestResult check_undo(const Yolah& before, const Yolah& after) {
    if (before == after) return pass();
    ostringstream oss;
    oss << "undo failed\n  Previous state:\n" << before
        << "\n  State after undo:\n" << after << '\n';
    return fail(oss.str());
}

TestResult check_game_over_moves(const Yolah& yolah, 
                                 const MoveList& moves) {
    if (moves.size() == 1 && moves[0] == Move::none()) return pass();
    ostringstream oss;
    oss << "only Move::none() should be available when game is over\n"
        << YolahWithMoves(yolah, moves) << '\n';
    return fail(oss.str());
}

TestResult check_none_move_execution(const Yolah& before, 
                                     const Yolah& after) {
    bool ok = true;
    for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
        if (before.get(sq) != after.get(sq)) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        return fail("Move::none() must not change the board content");
    }
    if (before.nb_plies() + 1 != after.nb_plies()) {
      return fail("Move::none() must increment the number of plies");
    }
    return pass();
}

TestResult check_regular_move_execution(const Yolah& before, 
                                        const Yolah& after, Move m) {
    Square from = m.from_sq();
    Square to = m.to_sq();
    bool ok = true;
    for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
        if (sq == from || sq == to) continue;
        if (before.get(sq) != after.get(sq)) {
            ok = false;
            break;
        }
    }
    if (ok && before.nb_plies() + 1 == after.nb_plies() && 
        after.get(from) == HOLE && 
        after.get(to) == before.current_player()) {
            return pass();
    }
    ostringstream oss;
    oss << "Move execution incorrect\n" << after 
        << "\n  Move: " << m << '\n';
    if (!ok) {
        oss << " Squares not concerned by the move must not change";
    }
    if (after.get(from) != HOLE) {
        oss << "  From square should be hole\n";
    }
    if (after.get(to) != before.current_player()) {
        oss << " To square should contain a piece from " 
            << (before.current_player() == BLACK ? "black" : "white") 
            << " player\n";
    }
    if (before.nb_plies() + 1 != after.nb_plies()) {
        oss << " The number of plies must be incremented\n";
    }
    return fail(oss.str());
}

void random_games(size_t nb_games, optional<uint64_t> seed) {
    MoveList fast_moves;
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    size_t total_tests = 0;
    size_t passed_tests = 0;

    auto run_test = [&](TestResult result) -> bool {
        total_tests++;
        if (result) {
            passed_tests++;
            return true;
        }
        cout << format("{}FAIL:{} {}\n", RED, RESET, result.message);
        return false;
    };
    
    cout << format("{}\n=== Running Random Games Tests ===\n{}", 
                   BOLD, RESET);

    for (size_t i = 0; i < nb_games; i++) {
      Yolah yolah;
      while (!yolah.game_over()) {
        yolah.moves(fast_moves);
        vector<Move> expected_moves = slow_moves_generation(yolah);

        if (!run_test(
              check_move_count(fast_moves, expected_moves))) break;
        if (!run_test(
              check_move_lists_equal(fast_moves, 
                                     expected_moves, yolah))) break;

        uniform_int_distribution<int> d(0, fast_moves.size() - 1);
        Move m = fast_moves[d(mt)];
        Yolah before = yolah;
        yolah.play(m);

        if (m == Move::none()) {
            if (!run_test(
                  check_none_move_execution(before, yolah))) break;
        } else {
            if (!run_test(
                  check_regular_move_execution(before, 
                                               yolah, m))) break;
        }

        yolah.undo(m);
        if (!run_test(check_undo(before, yolah))) break;
        yolah.play(m);
      }

      if (!yolah.game_over()) continue;

      yolah.moves(fast_moves);
      if (!run_test(
            check_game_over_moves(yolah, fast_moves))) continue;

      yolah.play(Move::none());
      yolah.moves(fast_moves);
      if (!run_test(
            check_game_over_moves(yolah, fast_moves))) continue;
    }

    cout << format("\n{}=== Test Summary ==={}\n", BOLD, RESET);
    cout << format("Total tests: {}\n", total_tests);
    cout << format("Passed: {}{}{}\n", GREEN, passed_tests, RESET);
    cout << format("Failed: {}{}{}\n", 
                   (passed_tests == total_tests ? GREEN : RED), 
                   total_tests - passed_tests, RESET);
    if (passed_tests == total_tests) {
        cout << format("{}All tests passed!{}\n", GREEN, RESET);
    } else {
        double pass_rate = 100.0 * passed_tests / total_tests;
        cout << format("{}Pass rate: {:.2f}%{}\n", YELLOW, pass_rate, 
                       RESET);
    }
}}

int main() {
  init_all_magics();
  test::random_games(10000, 42);
}
\end{minted}
% \captionof{listing}{Tests basés sur les propriétés et différentiels utilisés pour valider notre implémentation.}
\captionof{listing}{Property-based and differential tests used to validate our implementation.}
\label{lst:random_games_property_based_testing}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -O3 -march=native -Wall -Wpedantic chapter02.cpp -o chapter02
$ ./chapter02
=== Running Random Games Tests ===

=== Test Summary ===
Total tests: 2223036
Passed: 2223036
Failed: 0
All tests passed!
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Résultats de l'exécution du programme du listing \ref{lst:random_games_property_based_testing}}
\captionof{listing}{Results of executing the program from Listing~\ref{lst:random_games_property_based_testing}}
\label{lst:random_games_property_based_testing_exec}
\end{mdframed}


% \subsection{Tests de performance}
\subsection{Performance Testing}

% Nous allons analyser les performances de notre implémentation de Yolah en utilisant le programme du listing \ref{lst:random_games_perf1} qui ressemble au programme du listing \ref{lst:random_games_testing}. Mais contrairement à ce dernier, le programme du listing \ref{lst:random_games_perf1} n'arrête pas le déroulement des parties et affiche quelques statistiques sur les parties.
We will analyze the performance of our Yolah implementation using the program in Listing~\ref{lst:random_games_perf1}, which is similar to the program in Listing~\ref{lst:random_games_testing}. However, unlike the latter, the program in Listing~\ref{lst:random_games_perf1} does not pause during game play and displays some statistics about the games.
\begin{itemize}
% \item À la ligne 6, \mintinline{c++}{black_wins} va comptabiliser le nombre de victoires du joueur noir tout au long des \mintinline{c++}{nb_games} parties. Aux lignes 28 à 30, on affiche le nombre de victoires du joueur noir et le pourcentage que cela représente par rapport à toutes les parties jouées.
\item At line 6, \mintinline{c++}{black_wins} counts the number of wins by the black player throughout the \mintinline{c++}{nb_games} games. At lines 28 to 30, we display the number of black wins and the percentage this represents relative to all games played.
% \item À la ligne 7, \mintinline{c++}{white_wins} va comptabiliser le nombre de victoires du joueur blanc. On affiche aux lignes 31 à 33 les statistiques associées.
\item At line 7, \mintinline{c++}{white_wins} counts the number of wins by the white player. The associated statistics are displayed at lines 31 to 33.
% \item À la ligne 8, on procède de même pour le nombre de parties nulles grâce à la variable \mintinline{c++}{draws}.
\item At line 8, we do the same for the number of draws using the \mintinline{c++}{draws} variable.
% \item Aux lignes 11 à 16, on joue une partie aléatoire, en obtenant la liste des coups disponibles à la ligne 12, puis en sélectionnant un coup aléatoire à la ligne 14 puis en jouant ce coup à la ligne 15.
\item At lines 11 to 16, we play a random game, by obtaining the list of available moves at line 12, then selecting a random move at line 14, and playing this move at line 15.
% \item Nous allons jouer un million de parties comme nous pouvons le voir dans le \mintinline{c++}{main} à la ligne 40.
\item We will play one million games as we can see in the \mintinline{c++}{main} at line 40.
\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
void play_random_games(size_t nb_games, 
                       optional<uint64_t> seed = nullopt) {
    MoveList moves;
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    size_t black_wins = 0;
    size_t white_wins = 0;
    size_t draws = 0;
    for (size_t i = 0; i < nb_games; i++) {
        Yolah yolah;    
        while (!yolah.game_over()) {                 
            yolah.moves(moves);
            uniform_int_distribution<int> d(0, moves.size() - 1);
            Move m = moves[d(mt)];
            yolah.play(m);
        }
        auto [black_score, white_score] = yolah.score();
        if (black_score > white_score) {
            black_wins++;
        } else if (white_score > black_score) {
            white_wins++;
        } else {
            draws++;
        }
    }
    cout << format("\n=== Game Statistics ===\n");
    cout << format("Total games: {}\n", nb_games);
    cout << format("Black wins:  {} ({:.1f}%)\n", 
                    black_wins, 
                    100.0 * black_wins / nb_games);
    cout << format("White wins:  {} ({:.1f}%)\n", 
                    white_wins, 
                    100.0 * white_wins / nb_games);
    cout << format("Draws:       {} ({:.1f}%)\n", 
                    draws, 
                    100.0 * draws / nb_games);
}
int main() {
    init_all_magics();
    play_random_games(1000000, 42);
}
\end{minted}
% \captionof{listing}{Nous jouons un million de parties aléatoires pour évaluer les performances de notre implémentation de Yolah}
\captionof{listing}{We play one million random games to evaluate the performance of our Yolah implementation}
\label{lst:random_games_perf1}
\end{mdframed}

% \begin{figure}[htpb]
% \centering
% \includegraphics[width=0.4\textwidth]{chapter02_perf1.png}
% \caption{Flame graph ...}
% % \caption{La boîte du jeu des pingouins}
% \label{fig:chapter02_perf1}
% \end{figure}

% Nous utilisons \texttt{perf}~\cite{perf} pour collecter les données de performance et 
% \texttt{stackcollapse-perf.pl}, issu du projet FlameGraph~\cite{flamegraph}, 
% pour analyser les traces d'appels.

% Nous allons d'abord analyser les traces d'appels des fonctions pour déterminer les parties du code les plus coûteuses en temps. Nous utilisons l'outil \texttt{perf}~\cite{perf} pour collecter les données de performance et \texttt{stackcollapse-perf.pl}, issu du projet \texttt{FlameGraph}~\cite{flamegraph}, pour analyser les traces d'appels. La commande que nous utilisons est la suivante.

We will first analyze the function call traces to determine the most time-consuming parts of the code. We use the \texttt{perf}~\cite{perf} tool to collect performance data and \texttt{stackcollapse-perf.pl}, from the \texttt{FlameGraph}~\cite{flamegraph} project, to analyze the call traces. The command we use is the following.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -O3 -g -march=native -Wall -Wpedantic chapter02.cpp -o chapter02
$ sudo perf record -F 999 --call-graph dwarf -g ./chapter02
$ sudo perf script | stackcollapse-perf.pl > profile.txt
\end{verbatim}
}
\end{mdframed}

% Nous avons demandé à Claude \cite{anthropic2025claude} de générer un script Python permettant de visualiser les traces d'appels sous la forme d'un arbre qui est représenté dans le listing \ref{lst:chapter02_perf1}.

We asked Claude~\cite{anthropic2025claude} to generate a Python script to visualize the call traces as a tree, which is shown in Listing~\ref{lst:chapter02_perf1}.
\begin{itemize}
% \item La fonction \mintinline{c++}{play_random_games} compte pour $96.79\%$ du temps d'exécution du programme.
\item The \mintinline{c++}{play_random_games} function accounts for $96.79\%$ of the program's execution time.
% \item La suite des appels de fonctions se lit en suivant les branches de l'arbre. Par exemple, on peut voir ci-dessous les différents appels de fonctions qui ont amené à l'exécution de \mintinline{c++}{Magic::index}.
\item The sequence of function calls can be read by following the tree branches. For example, we can see below the different function calls that led to the execution of \mintinline{c++}{Magic::index}.
\begin{verbatim}
play_random_games
├── Yolah::moves
        ├── moves_bb
            └── Magic::index             8.87%
\end{verbatim}
% on voit de plus que l'exécution de \mintinline{c++}{Magic::index} via cette suite d'appels représente $8.87\%$ du temps d'exécution du programme.
we can also see that the execution of \mintinline{c++}{Magic::index} through this call chain represents $8.87\%$ of the program's execution time.
% \item Notons que l'ordre des fonctions ne représente pas l'ordre du listing, les feuilles de l'arbre sont triées selon le pourcentage du temps d'exécution.
\item Note that the order of functions does not represent the order in the listing; the tree leaves are sorted by execution time percentage.
% \item Remarquons aussi que l'on peut déduire facilement le temps passé dans une fonction en dehors des appels de fonctions qu'elle a effectué. Par exemple, pour la fonction \mintinline{c++}{play_random_games}, son temps d'exécution compte pour $96.79\%$ du temps d'exécution du programme. Si on soustrait de ce nombre la somme $(82.25\% + 5.33\% + 3.89\% + 3.86\%)$, qui représente les pourcentages du temps d'exécution du programme des fonctions \mintinline{c++}{Yolah::moves}, \mintinline{c++}{std::uniform_int_distribution}, \mintinline{c++}{Yolah::game_over} et \mintinline{c++}{Yolah::play}, on obtient $1.46\%$, qui donne le pourcentage du temps d'exécution total passé dans le reste de la fonction \mintinline{c++}{play_random_games}. La proportion du temps passé dans le reste de la fonction est donc de $1.46/96.79 = 1.5\%$.
\item Note also that we can easily deduce the time spent in a function excluding its function calls. For example, for the \mintinline{c++}{play_random_games} function, its execution time accounts for $96.79\%$ of the program's execution time. If we subtract from this number the sum $(82.25\% + 5.33\% + 3.89\% + 3.86\%)$, which represents the execution time percentages of the functions \mintinline{c++}{Yolah::moves}, \mintinline{c++}{std::uniform_int_distr}\\\mintinline{c++}{ibution}, \mintinline{c++}{Yolah::game_over}, and \mintinline{c++}{Yolah::play}, we obtain $1.46\%$, which gives the percentage of total execution time spent in the rest of the \mintinline{c++}{play_random_games} function. The proportion of time spent in the rest of the function is therefore $1.46/96.79 = 1.5\%$.
% \item L'arbre nous permet de voir rapidement que si l'on souhaite améliorer le temps d'exécution de notre programme, il faut se concentrer sur la fonction \mintinline{c++}{Yolah::moves} appelée par \mintinline{c++}{play_random_games}. En effet, le temps d'exécution de cette fonction représente $82.25\%$ du temps d'exécution total du programme.
\item The tree allows us to quickly see that if we wish to improve our program's execution time, we should focus on the \mintinline{c++}{Yolah::moves} function called by \mintinline{c++}{play_random_}\\\mintinline{c++}{games}. Indeed, this function's execution time represents $82.25\%$ of the program's total execution time.
\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
play_random_games                       96.79%
├── Yolah::moves                        82.25%
│       ├── moves_bb                    33.07%
│       │   └── Magic::index             8.87%
│       ├── Move::Move                  13.86%
│       └── pop_lsb                     13.85%
│           └── lsb                     13.18%
├── std::uniform_int_distribution<...    5.33%   
├── Yolah::game_over                     3.89%
│   └── shift<>                          2.14%
└── Yolah::play                          3.86%
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Traces d'appels des fonctions permettant d'identifier les fonctions les plus coûteuses}
\captionof{listing}{Function call traces identifying the most expensive functions}
\label{lst:chapter02_perf1}
\end{mdframed}

% Grâce au listing \ref{lst:chapter02_perf1}, nous savons que nous devons concentrer nos efforts sur la fonction \mintinline{c++}{Yolah::moves}. Nous allons de nouveau utiliser l'outil \texttt{perf}~\cite{perf} mais cette fois-ci pour accéder aux compteurs de performance matériel (PMU - Performance Monitoring Unit)~\cite{intelsdm} du processeur. Ces compteurs mesurent des évènements tels que les défauts de prédiction de branchement, les défauts de cache, etc. Ces compteurs vont nous guider afin de trouver les faiblesses de notre implémentation\footnote{Pour approfondir le sujet de l'optimisation sur processeurs modernes, vous pouvez consulter~\cite{bakhvalov2024, pikus2021, algorithmica, inteltma}.}. Nous utilisons les commandes suivantes pour analyser le comportement de notre programme.

Thanks to Listing~\ref{lst:chapter02_perf1}, we know that we must focus our efforts on the \mintinline{c++}{Yolah::moves} function. We will again use the \texttt{perf}~\cite{perf} tool, but this time to access the processor's hardware performance counters (PMU -- Performance Monitoring Unit)~\cite{intelsdm}. These counters measure events such as branch mispredictions, cache misses, etc. These counters will guide us in finding the weaknesses of our implementation\footnote{To delve deeper into optimization on modern processors, you may consult~\cite{bakhvalov2024, pikus2021, algorithmica, inteltma}.}. We use the following commands to analyze the behavior of our program.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -O3 -march=native -Wall -Wpedantic chapter02.cpp -o chapter02
$ perf stat -r 10 -e cycles,instructions,branches,branch-misses,\
L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses,\
l1d_pend_miss.pending,l1d_pend_miss.pending_cycles ./chapter02
\end{verbatim}
}
\end{mdframed}

% Les résultats sont présentés dans le listing \ref{lst:perf_chapter02_1}.

The results are presented in Listing~\ref{lst:perf_chapter02_1}.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim} Performance counter stats for './chapter02' (10 runs):

    17 675 748 046      cycles                        ( +-  0.14% )
    24 357 812 457      instructions   # 1.38 IPC     ( +-  0.03% )
     2 429 931 966      branches                      ( +-  0.03% )
       274 551 866      branch-misses  # 11.30%       ( +-  0.03% )
     3 132 479 051      L1-dcache-loads               ( +-  0.03% )
       147 715 205      L1-dcache-load-misses # 4.71% ( +-  0.16% )
        53 089 459      LLC-loads                     ( +-  1.24% )
            24 898      LLC-load-misses # 0.05%       ( +- 31.02% )
     2 413 363 382      l1d_pend_miss.pending         ( +-  0.78% )
     2 202 499 896      l1d_pend_miss.pending_cycles  ( +-  0.70% )

           4.23 +- 0.01 seconds time elapsed
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Compteurs de performances pour le programme du listing \ref{lst:random_games_perf1}.}
\captionof{listing}{Performance counters for the program in Listing~\ref{lst:random_games_perf1}.}
\label{lst:perf_chapter02_1}
\end{mdframed}

\begin{itemize}
% \item L'option \texttt{-r 10} de la commande \texttt{perf} ci-dessus permet de lancer le programme dix fois, pour faire la moyenne et calculer l'écart-type des résultats obtenus.
\item The \texttt{-r 10} option of the \texttt{perf} command above runs the program ten times, to compute the average and the standard deviation\footnote{More precisely, the standard deviation as a percentage of the mean.} of the obtained results.
% \item Le compteur \texttt{cycles} indique le nombre de cycles effectués par le processeur durant l'exécution de notre programme.
\item The \texttt{cycles} counter indicates the number of cycles performed by the processor during our program's execution\footnote{In user mode and kernel mode. The counters are enabled when a process is running and disabled when it loses the CPU.}.
% \item Le compteur \texttt{instructions} mesure le nombre d'instructions exécutées par notre programme. Le nombre d'instructions exécutées par cycle \gls{ipc} est de $1.38$. Les processeurs modernes sont super-scalaires, ils ont la capacité d'exécuter plusieurs instructions par cycle. Plus ce nombre est élevé, et plus les unités de calculs du processeur sont utilisées. Nous pourrons comparer cet \gls{ipc} avec celui des versions optimisées que nous développerons par la suite.
\item The \texttt{instructions} counter measures the number of instructions executed by our program. The number of instructions executed per cycle \gls{ipc} is $1.38$. Modern processors are superscalar: they have the ability to execute multiple instructions per cycle. The higher this number, the more the processor's execution units are utilized. We will be able to compare this \gls{ipc} with that of the optimized versions we will develop later.
% \item Le compteur \texttt{branches} va comptabiliser le nombre total de branchements exécutés (conditionnels, inconditionnels, indirects, appels et retours de fonction).
\item The \texttt{branches} counter tallies the total number of executed branches (conditional, unconditional, indirect, function calls, and returns).
% \item Le compteur \texttt{branch-misses} indique le nombre de fois où le prédicteur de branchement s'est trompé. Les processeurs modernes, pour ne pas laisser leurs unités de calcul sans travail, exécutent des instructions de manière spéculative, c'est-à-dire avant de connaître le résultat des branchements conditionnels. Lorsque la prédiction est correcte, le processeur a gagné du temps. En cas d'erreur, les instructions exécutées spéculativement sont annulées, et le processeur reprend l'exécution du programme au bon endroit après le branchement. Ces erreurs de branchements sont coûteuses. Dans notre cas, le prédicteur de branchement se trompe dans $11{,}30\%$ des cas. Ce taux est élevé et c'est la première chose que nous allons essayer d'améliorer.
\item The \texttt{branch-misses} counter indicates the number of times the branch predictor was wrong. Modern processors, to keep their execution units busy, execute instructions speculatively, that is, before knowing the result of conditional branches. When the prediction is correct, the processor has saved time. In case of error, the speculatively executed instructions are discarded, and the processor resumes execution at the correct location after the branch. These branch mispredictions are costly. In our case, the branch predictor is wrong in $11.30\%$ of cases. This rate is high and is the first thing we will try to improve.
% \item Le compteur \texttt{L1-dcache-loads} mesure le nombre d'accès en lecture au cache de premier niveau, qui est le cache le plus rapide (mais aussi le plus petit).
\item The \texttt{L1-dcache-loads} counter measures the number of read accesses to the first-level cache, which is the fastest cache (but also the smallest).
% \item Le compteur \texttt{L1-dcache-load-misses} indique le nombre de lectures qui n'ont pas trouvé les données dans le cache de premier niveau. Ces lectures ont dû être recherchées dans les caches de niveaux supérieurs, ou en mémoire principale. Ici nous avons un défaut de cache de niveau 1 de $4{,}71\%$. Notre programme accède aux tables des magic bitboards de manière peu prévisible pour le processeur et ces tables ne peuvent pas tenir entièrement dans le cache de niveau 1. Au vu de ces considérations, ce taux de défaut nous semble correct.
\item The \texttt{L1-dcache-load-misses} counter indicates the number of reads that did not find the data in the first-level cache. These reads had to be fetched from higher-level caches or from main memory. Here we have an L1 cache miss rate of $4.71\%$. Our program accesses the magic bitboard tables in a way that is unpredictable for the processor, and these tables cannot fit entirely in the L1 cache. Given these considerations, this miss rate seems reasonable.
% \item Le compteur \texttt{LLC-loads} mesure les accès au cache de dernier niveau, celui placé juste avant la mémoire principale.
\item The \texttt{LLC-loads} counter measures accesses to the last-level cache, the one placed just before main memory.
% \item Le compteur \texttt{LLC-load-misses} indique le nombre de lectures qui n'ont pas trouvé les données dans le cache de dernier niveau (\gls{llc}). On constate que ce nombre est très faible~: sur les $147\,175\,205$ accès ayant échoué dans le cache L1, seulement $24\,898$ ont nécessité un accès à la mémoire principale. Cela s'explique facilement, car les tables des magic bitboards peuvent tenir entièrement dans le cache de dernier niveau.
\item The \texttt{LLC-load-misses} counter indicates the number of reads that did not find the data in the last-level cache (\gls{llc}). We observe that this number is very low: out of the $147{,}175{,}205$ accesses that missed in the L1 cache, only $24{,}898$ required an access to main memory. This is easily explained, as the magic bitboard tables can fit entirely in the last-level cache.
% \item Concernant les deux prochains compteurs, nous étions curieux d'étudier le parallélisme des accès à la mémoire \gls{mlp} présente dans les processeurs modernes et étudier cette caractéristique dans notre programme.
\item Regarding the next two counters, we were curious to study the memory-level parallelism \gls{mlp} present in modern processors and to examine this characteristic in our program.
% \item Le compteur \texttt{l1d\_pend\_miss.pending} comptabilise, à chaque cycle, le nombre de requêtes mémoire en attente suite à des défauts de cache L1. C'est une somme cumulée~: si pendant 100 cycles il y a 3 requêtes en vol, ce compteur s'incrémente de 300.
\item The \texttt{l1d\_pend\_miss.pending} counter tallies, at each cycle, the number of pending memory requests following L1 cache misses. It is a cumulative sum: if during 100 cycles there are 3 in-flight requests, this counter increments by 300.
% \item Le compteur \texttt{l1d\_pend\_miss.pending\_cycles} compte le nombre de cycles pendant lesquels au moins une requête mémoire est en attente.
\item The \texttt{l1d\_pend\_miss.pending\_cycles} counter counts the number of cycles during which at least one memory request is pending.
% \item Le rapport de ces deux compteurs donne le MLP~:
\item The ratio of these two counters gives the MLP:
\[
\text{MLP} = \frac{\texttt{l1d\_pend\_miss.pending}}{\texttt{l1d\_pend\_miss.pending\_cycles}} = \frac{2\,413\,363\,382}{2\,202\,499\,896} \approx 1{,}10
\]
% Cette valeur indique qu'en moyenne, seulement $1{,}10$ requête mémoire est en vol simultanément lorsque le processeur attend des données. Un MLP de 1 signifie que les accès mémoire sont strictement séquentiels~: le processeur attend la fin d'une requête avant d'en lancer une autre. Les processeurs modernes peuvent gérer plusieurs requêtes simultanées. Notre MLP proche de 1 suggère que notre code ne tire pas parti du parallélisme mémoire, probablement à cause de dépendances dans le code de la fonction \mintinline{c++}{moves} qui empêchent le processeur de lancer plusieurs requêtes en parallèle. Il faut toutefois nuancer ce constat~: avec un taux de défaut L1 de seulement $4{,}71\%$, la grande majorité des accès mémoire ($95{,}29\%$) sont satisfaits par le cache L1 en quelques cycles. Le faible MLP n'est donc problématique que pour les $4{,}71\%$ d'accès qui génèrent effectivement une attente. Nous pourrons comparer ce MLP avec les versions optimisées que nous allons développer.
This value indicates that on average, only $1.10$ memory requests are in flight simultaneously when the processor is waiting for data. An MLP of 1 means that memory accesses are strictly sequential: the processor waits for one request to complete before launching another. Modern processors can handle multiple simultaneous requests. Our MLP close to 1 suggests that our code does not take advantage of memory-level parallelism, probably due to dependencies in the \mintinline{c++}{moves} function code that prevent the processor from launching multiple requests in parallel. However, this observation should be put into perspective: with an L1 miss rate of only $4.71\%$, the vast majority of memory accesses ($95.29\%$) are satisfied by the L1 cache within a few cycles. The low MLP is therefore only problematic for the $4.71\%$ of accesses that actually generate a wait. We will be able to compare this MLP with the optimized versions we will develop.

\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
void moves(uint8_t player, MoveList& moves) const noexcept {
    Move* move_list = moves.move_list;
    uint64_t occupied = black | white | holes;
    uint64_t bb = player == BLACK ? black : white;
    while (bb) {
        Square from = pop_lsb(bb);
        uint64_t b = moves_bb(from, occupied) & ~occupied;
        while (b) {
            *move_list++ = Move(from, pop_lsb(b));
        }
    }
    if (move_list == moves.move_list) [[unlikely]] {
        *move_list++ = Move::none();
    }
    moves.last = move_list;
}
\end{minted}
% \captionof{listing}{Rappel du code de la fonction \mintinline{c++}{moves}}
\captionof{listing}{Recap of the \mintinline{c++}{moves} function code}
\label{lst:random_games_perf2}
\end{mdframed}

% Au vu des résultats précédents sur les différents compteurs, le critère qui nous semble le plus important à améliorer est le taux élevé de défauts du prédicteur de branchements. Le listing~\ref{lst:random_games_perf2} rappelle le code de la fonction \mintinline{c++}{moves}. On peut aussi utiliser \texttt{perf} pour analyser plus finement où se situent les défauts de prédiction de branchements dans le code source. La commande que nous utilisons est la suivante.

Given the previous results on the various counters, the criterion that seems most important to improve is the high branch misprediction rate. Listing~\ref{lst:random_games_perf2} recalls the code of the \mintinline{c++}{moves} function. We can also use \texttt{perf} to analyze more precisely where the branch mispredictions occur in the source code. The command we use is the following.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -O3 -g -march=native -Wall -Wpedantic chapter02.cpp -o chapter02
$ sudo perf record -e branch-misses:pp ./chapter02
$ sudo perf annotate --stdio
\end{verbatim}
}
\end{mdframed}

% Une partie du code annoté produit par \texttt{perf annotate} est donnée dans le listing \ref{lst:branch-misses-version1}.

A portion of the annotated code produced by \texttt{perf annotate} is shown in Listing~\ref{lst:branch-misses-version1}.
\begin{itemize}
% \item Le code généré par le compilateur est optimisé et il n'est pas toujours facile de voir la correspondance avec le listing \ref{lst:random_games_perf2}. Le code annoté montre l'assembleur généré par le compilateur et intercale des lignes du source pour essayer de montrer la correspondance avec le code original.
\item The code generated by the compiler is optimized, and it is not always easy to see the correspondence with Listing~\ref{lst:random_games_perf2}. The annotated code shows the assembly generated by the compiler and interleaves source lines to try to show the correspondence with the original code.
% \item Les pourcentages indiquent la proportion des défauts de prédiction de branchement attribués à chaque instruction par rapport à l'ensemble du programme.
\item The percentages indicate the proportion of branch mispredictions attributed to each instruction relative to the entire program.
% \item Les défauts de branchement liés à la boucle \mintinline{c++}{while (bb)} de la ligne 5 du listing \ref{lst:random_games_perf2} représentent~: $9{,}24\% + 3{,}52\% = 12{,}76\%$.
\item The branch mispredictions related to the \mintinline{c++}{while (bb)} loop at line 5 of Listing~\ref{lst:random_games_perf2} represent: $9.24\% + 3.52\% = 12.76\%$.
% \item Les défauts de branchement liés à la boucle \mintinline{c++}{while (b)} de la ligne 8 du listing \ref{lst:random_games_perf2} représentent~: $4{,}50\% + 6{,}69\% + 67{,}28\% = 78{,}47\%$.
\item The branch mispredictions related to the \mintinline{c++}{while (b)} loop at line 8 of Listing~\ref{lst:random_games_perf2} represent: $4.50\% + 6.69\% + 67.28\% = 78.47\%$.
% \item La boucle \mintinline{c++}{while (b)} est donc celle qui génère le plus de défauts de branchement. Cela s'explique par le fait que l'historique des branchements pour cette boucle ne contient pas de motifs réguliers permettant de prédire les branchements futurs. En effet, le nombre d'itérations de cette boucle dépend du nombre de bits à 1 dans \mintinline{c++}{b}, qui représente les cases de destination possibles pour une pièce. Ce nombre varie selon la position des pièces et la configuration des obstacles sur le plateau, rendant toute prédiction difficile pour le processeur.
\item The \mintinline{c++}{while (b)} loop is therefore the one generating the most branch mispredictions. This is explained by the fact that the branch history for this loop does not contain regular patterns that would allow predicting future branches. Indeed, the number of iterations of this loop depends on the number of set bits in \mintinline{c++}{b}, which represents the possible destination squares for a piece. This number varies depending on the positions of the pieces and the configuration of obstacles on the board, making any prediction difficult for the processor.
% \item La boucle \mintinline{c++}{while (bb)}, même si elle génère beaucoup moins de défauts de branchement, est simple à optimiser. En effet, nous savons pertinemment qu'il y aura toujours exactement quatre itérations, car chaque joueur possède quatre pièces. Pour optimiser cette boucle, nous allons la dérouler complètement afin d'éliminer tous les branchements associés. Ce déroulage devrait également offrir des opportunités de parallélisme au niveau des instructions (\gls{ilp}), car le processeur pourra exécuter simultanément les calculs indépendants pour chacune des quatre pièces.
\item The \mintinline{c++}{while (bb)} loop, even though it generates far fewer branch mispredictions, is simple to optimize. Indeed, we know for certain that there will always be exactly four iterations, since each player has four pieces. To optimize this loop, we will fully unroll it to eliminate all associated branches. This unrolling should also offer opportunities for instruction-level parallelism (\gls{ilp}), as the processor will be able to simultaneously execute the independent computations for each of the four pieces.
\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=5pt,innerrightmargin=5pt,innertopmargin=5pt,innerbottommargin=5pt]
{\small\ttfamily
\begin{tabular}{r@{\quad}c@{\quad}r@{\quad}l}
\multicolumn{4}{@{}l}{\textcolor{blue!70!black}{\textbf{Yolah::moves(unsigned char, MoveList\&) const:}}} \\[2pt]
\rowcolor{gray!10}
      & : & 408: & \textcolor{gray}{while (b) \{} \\
\rowcolor{yellow!30}
\makebox[3.5em][r]{\textcolor{black!90}{\textbf{4.50}}} & : & 8f2e: & and \%r10,\%rbp \\
\rowcolor{yellow!35}
\makebox[3.5em][r]{\textcolor{black!90}{\textbf{6.69}}} & : & 8f31: & je 8f65 \\
\rowcolor{gray!10}
      & : & 266: & \textcolor{gray}{: data((to << 6) + from) \{\}} \\
 0.00 & : & 8f33: & mov \%r9,\%r11 \\
\rowcolor{gray!10}
      & : & 407: & \textcolor{gray}{uint64\_t b = moves\_bb(from, occupied) \& \textasciitilde occupied;} \\
 0.00 & : & 8f36: & mov \%rbp,\%rcx \\
 0.00 & : & 8f39: & nopl 0x0(\%rax) \\
\rowcolor{gray!10}
      & : & 410: & \textcolor{gray}{std::\_\_countr\_zero:} \\
 0.00 & : & 8f40: & xor \%esi,\%esi \\
\rowcolor{gray!10}
      & : & 409: & \textcolor{gray}{*move\_list++ = Move(from, pop\_lsb(b));} \\
 0.00 & : & 8f42: & add \$0x2,\%r11 \\
 0.00 & : & 8f46: & tzcnt \%rcx,\%rsi \\
 0.00 & : & 8f4b: & shl \$0x6,\%esi \\
 0.00 & : & 8f4e: & add \%eax,\%esi \\
\rowcolor{gray!10}
      & : & 408: & \textcolor{gray}{while (b) \{} \\
 0.00 & : & 8f50: & blsr \%rcx,\%rcx \\
 0.00 & : & 8f55: & mov \%si,-0x2(\%r11) \\
\rowcolor{red!35}
\makebox[3.5em][r]{\textcolor{black!90}{\textbf{67.28}}} & : & 8f5a: & \textbf{jne 8f40} \\
 0.00 & : & 8f5c: & popcnt \%rbp,\%rbp \\
 0.00 & : & 8f61: & lea (\%r9,\%rbp,2),\%r9 \\
\rowcolor{gray!10}
      & : & 405: & \textcolor{gray}{while (bb) \{} \\
\rowcolor{orange!30}
\makebox[3.5em][r]{\textcolor{black!90}{\textbf{9.24}}} & : & 8f65: & test \%rdi,\%rdi \\
\rowcolor{orange!25}
\makebox[3.5em][r]{\textcolor{black!90}{\textbf{3.52}}} & : & 8f68: & jne 8ed8 \\
\end{tabular}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Résultats de \texttt{perf annotate} permettant de trouver les parties du code créant le plus de défauts de branchements. Les pourcentages indiquent la proportion des défauts de prédiction de branchement attribués à chaque instruction par rapport à l'ensemble du programme.}
\captionof{listing}{Results of \texttt{perf annotate} identifying the code sections causing the most branch mispredictions. The percentages indicate the proportion of branch mispredictions attributed to each instruction relative to the entire program.}
\label{lst:branch-misses-version1}
\end{mdframed}

% La nouvelle version de la fonction \mintinline{c++}{moves} du listing \ref{lst:random_games_perf2} avec la boucle \mintinline{c++}{while (bb)} déroulée (ligne 5), est donnée dans le listing \ref{lst:random_games_perf3}.

The new version of the \mintinline{c++}{moves} function from Listing~\ref{lst:random_games_perf2} with the \mintinline{c++}{while (bb)} loop (line 5) fully unrolled is given in Listing~\ref{lst:random_games_perf3}.
\begin{itemize}
% \item Aux lignes 6 à 9, nous récupérons les cases des quatre pièces du joueur.
\item At lines 6 to 9, we retrieve the squares of the player's four pieces.
% \item Aux lignes 11 à 14, nous obtenons les bitboards des mouvements possibles pour les quatre pièces du joueur.
\item At lines 11 to 14, we obtain the bitboards of possible moves for the player's four pieces.
% \item Aux lignes 16 à 18, nous créons les coups pour la pièce située dans la case \mintinline{c++}{from0}.
\item At lines 16 to 18, we create the moves for the piece located at square \mintinline{c++}{from0}.
% \item Aux lignes 19 à 21, nous créons les coups pour la pièce située dans la case \mintinline{c++}{from1}.
\item At lines 19 to 21, we create the moves for the piece located at square \mintinline{c++}{from1}.
% \item Aux lignes 22 à 24, nous créons les coups pour la pièce située dans la case \mintinline{c++}{from2}.
\item At lines 22 to 24, we create the moves for the piece located at square \mintinline{c++}{from2}.
% \item Aux lignes 25 à 27, nous créons les coups pour la pièce située dans la case \mintinline{c++}{from3}.
\item At lines 25 to 27, we create the moves for the piece located at square \mintinline{c++}{from3}.
\end{itemize}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
void moves(uint8_t player, MoveList& moves) const noexcept {
    Move* move_list = moves.move_list;
    uint64_t occupied = black | white | holes;
    uint64_t bb = player == BLACK ? black : white;

    Square from0 = pop_lsb(bb);
    Square from1 = pop_lsb(bb);
    Square from2 = pop_lsb(bb);
    Square from3 = pop_lsb(bb);
    
    uint64_t b0 = moves_bb(from0, occupied) & ~occupied;
    uint64_t b1 = moves_bb(from1, occupied) & ~occupied;
    uint64_t b2 = moves_bb(from2, occupied) & ~occupied;
    uint64_t b3 = moves_bb(from3, occupied) & ~occupied;
    
    while (b0) {
        *move_list++ = Move(from0, pop_lsb(b0));
    }
    while (b1) {
        *move_list++ = Move(from1, pop_lsb(b1));
    }
    while (b2) {
        *move_list++ = Move(from2, pop_lsb(b2));
    }
    while (b3) {
        *move_list++ = Move(from3, pop_lsb(b3));
    }
    if (move_list == moves.move_list) [[unlikely]] {
        *move_list++ = Move::none();
    }
    moves.last = move_list;
}
\end{minted}
% \captionof{listing}{Nouvelle version de la fonction \mintinline{c++}{moves} avec la première boucle \mintinline{c++}{while} déroulée.}
\captionof{listing}{New version of the \mintinline{c++}{moves} function with the first \mintinline{c++}{while} loop unrolled.}
\label{lst:random_games_perf3}
\end{mdframed}

% Nous exécutons de nouveau la commande suivante, et les résultats sont donnés dans le listing \ref{lst:perf_chapter02_2}.

We run the following command again, and the results are given in Listing~\ref{lst:perf_chapter02_2}.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim}
$ g++ -std=c++23 -O3 -march=native -Wall -Wpedantic chapter02.cpp\
-o chapter02
$ perf stat -r 10 -e cycles,instructions,branches,branch-misses,\
L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses,\
l1d_pend_miss.pending,l1d_pend_miss.pending_cycles ./chapter02
\end{verbatim}
}
\end{mdframed}

% Cette nouvelle version nous permet de réduire le temps d'exécution du programme de $1 - \frac{3{,}06}{4{,}23} \approx 27{,}7\%$. Nous pouvons observer dans le listing \ref{lst:perf_chapter02_2} que nous avons amélioré l'\gls{ipc}, qui passe de $1{,}38$ à $1{,}85$, que nous avons réduit le taux de défauts de branchement de $11{,}30\%$ à $10{,}16\%$, et que le taux de défauts de cache L1 est passé de $4{,}71\%$ à $4{,}12\%$. Le \gls{mlp}, qui mesure le nombre moyen de requêtes mémoire en vol simultanément, s'améliore également de $1{,}10$ à $1{,}35$, ce qui indique que le processeur exploite mieux le parallélisme mémoire pour masquer la latence des accès au cache. Le déroulage de la première boucle \mintinline{c++}{while} a donc permis de donner accès au processeur à plus d'instructions indépendantes et d'exécuter globalement plus d'instructions par cycle.

This new version allows us to reduce the program's execution time by $1 - \frac{3.06}{4.23} \approx 27.7\%$. We can observe in Listing~\ref{lst:perf_chapter02_2} that we improved the \gls{ipc}, which goes from $1.38$ to $1.85$, that we reduced the branch misprediction rate from $11.30\%$ to $10.16\%$, and that the L1 cache miss rate went from $4.71\%$ to $4.12\%$. The \gls{mlp}, which measures the average number of memory requests in flight simultaneously, also improves from $1.10$ to $1.35$, indicating that the processor better exploits memory-level parallelism to hide cache access latency. Unrolling the first \mintinline{c++}{while} loop thus allowed the processor to access more independent instructions and execute more instructions per cycle overall.


\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim} Performance counter stats for './chapter02' (10 runs):

    12 678 510 624      cycles                        ( +-  0.07% )
    23 599 166 797      instructions   # 1.85 IPC     ( +-  0.03% )
     2 329 596 530      branches                      ( +-  0.03% )
       236 669 629      branch-misses  # 10.16%       ( +-  0.04% )
     3 510 465 683      L1-dcache-loads               ( +-  0.04% )
       144 745 234      L1-dcache-load-misses # 4.12% ( +-  0.09% )
        51 642 976      LLC-loads                     ( +-  0.59% )
            11 608      LLC-load-misses # 0.02%       ( +- 12.06% )
     2 372 461 194      l1d_pend_miss.pending         ( +-  0.80% )
     1 756 784 236      l1d_pend_miss.pending_cycles  ( +-  0.77% )

           3.06 +- 0.01 seconds time elapsed
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Compteurs de performances pour le programme du listing \ref{lst:random_games_perf3}.}
\captionof{listing}{Performance counters for the program in Listing~\ref{lst:random_games_perf3}.}
\label{lst:perf_chapter02_2}
\end{mdframed}

% Nous verrons s'il est nécessaire d'essayer de continuer d'améliorer la fonction \mintinline{c++}{moves} par la suite. En effet, peut-être que le temps d'exécution de celle-ci sera négligeable par rapport au reste du programme dans les prochains chapitres. Par contre, nous aurons besoin d'exécuter des parties aléatoires pour certains joueurs artificiels. Il est donc intéressant d'en améliorer le temps d'exécution. Une façon très efficace d'optimiser un code, c'est de le supprimer~! Nous n'avons pas besoin de générer la liste de tous les coups, puis d'en choisir un aléatoirement seulement après cette génération. Nous pouvons choisir dès le début un coup aléatoirement. Cette génération de la liste de coups est aussi responsable de quasiment tous les défauts de branchement du programme. La fonction \mintinline{c++}{Move Yolah::random_move(mt19937& mt)} du listing~\ref{lst:random_games_perf4} retourne un coup aléatoire dans la position courante du jeu. Nous avons codé cette fonction de façon à éliminer un maximum de branchements. Ce style de programmation, dit \emph{branchless}, privilégie les opérations arithmétiques et logiques aux instructions conditionnelles, évitant ainsi les pénalités liées aux défauts de prédiction de branchement.

We will see later whether it is necessary to continue improving the \mintinline{c++}{moves} function. Indeed, its execution time may be negligible compared to the rest of the program in the following chapters. However, we will need to run random games for some artificial players. It is therefore worthwhile to improve its execution time. A very effective way to optimize code is to delete it! We do not need to generate the list of all moves and then choose one randomly only after this generation. We can choose a random move from the start. This move list generation is also responsible for nearly all the branch mispredictions in the program. The \mintinline{c++}{Move Yolah::random_move(mt19937& mt)} function in Listing~\ref{lst:random_games_perf4} returns a random move in the current game position. We coded this function to eliminate as many branches as possible. This programming style, called \emph{branchless}, favors arithmetic and logical operations over conditional instructions, thus avoiding the penalties associated with branch mispredictions.

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
Move Yolah::random_move(mt19937& mt) const noexcept {
    uint64_t occupied = black | white | holes;
    uint64_t player_bb = current_player() == BLACK ? black : white;
    Square from0 = pop_lsb(player_bb);
    Square from1 = pop_lsb(player_bb);
    Square from2 = pop_lsb(player_bb);
    Square from3 = pop_lsb(player_bb);
    uint64_t b0 = moves_bb(from0, occupied) & ~occupied;
    uint64_t b1 = moves_bb(from1, occupied) & ~occupied;
    uint64_t b2 = moves_bb(from2, occupied) & ~occupied;
    uint64_t b3 = moves_bb(from3, occupied) & ~occupied;
    int n0 = popcount(b0);
    int n1 = popcount(b1);
    int n2 = popcount(b2);
    int n3 = popcount(b3);
    int n = n0 + n1 + n2 + n3;
    if (n == 0) [[unlikely]] {
        return Move::none();
    }
    uniform_int_distribution<int> d(0, n - 1);
    int bit = d(mt);
    int bb_index = (bit >= n0) + (bit >= n0+n1) + (bit >= n0+n1+n2);
    bit -= (bb_index > 0)*n0 + (bb_index > 1)*n1 + (bb_index > 2)*n2;
    Square from = array{ from0, from1, from2, from3 }[bb_index];
    uint64_t bb = array{ b0, b1, b2, b3 }[bb_index];        
    Square to = Square(countr_zero(_pdep_u64(1ULL << bit, bb)));
    return Move(from, to);     
}
void play_random_games_fast(size_t nb_games, 
                            optional<uint64_t> seed = nullopt) {
    MoveList moves;
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    size_t black_wins = 0;
    size_t white_wins = 0;
    size_t draws = 0;
    size_t max_nb_moves = 0;
    for (size_t i = 0; i < nb_games; i++) {
        Yolah yolah;
        while (!yolah.game_over()) {
            Move m = yolah.random_move(mt);
            yolah.play(m);
        }
        auto [black_score, white_score] = yolah.score();
        if (black_score > white_score) {
            black_wins++;
        } else if (white_score > black_score) {
            white_wins++;
        } else {
            draws++;
        }
    }
    cout << format("\n=== Game Statistics ===\n");
    cout << format("Total games: {}\n", nb_games);
    cout << format("Black wins:  {} ({:.1f}%)\n", 
                    black_wins, 
                    100.0 * black_wins / nb_games);
    cout << format("White wins:  {} ({:.1f}%)\n", 
                    white_wins, 
                    100.0 * white_wins / nb_games);
    cout << format("Draws:       {} ({:.1f}%)\n", 
                    draws, 
                    100.0 * draws / nb_games);
}
int main() {
    init_all_magics();
    play_random_games_fast(1000000, 42);
}
\end{minted}
% \captionof{listing}{Génération d'un coup aléatoire sans générer auparavant toute la liste de coups.}
\captionof{listing}{Generating a random move without first generating the entire move list.}
\label{lst:random_games_perf4}
\end{mdframed}

\begin{itemize}
% \item Aux lignes 4 à 7, nous récupérons les cases des pièces du joueur courant.
\item At lines 4 to 7, we retrieve the squares of the current player's pieces.
% \item Aux lignes 8 à 11, nous obtenons les bitboards des coups possibles pour chacune des positions des pièces du joueur.
\item At lines 8 to 11, we obtain the bitboards of possible moves for each of the player's piece positions.
% \item Aux lignes 12 à 15, nous obtenons, grâce à la fonction \mintinline{c++}{popcount}, qui compte le nombre de bits à 1 dans un bitboard, le nombre de coups pour chacun des bitboards \mintinline{c++}{b0, b1, b2} et \mintinline{c++}{b3}.
\item At lines 12 to 15, we obtain, using the \mintinline{c++}{popcount} function which counts the number of set bits in a bitboard, the number of moves for each of the bitboards \mintinline{c++}{b0, b1, b2}, and \mintinline{c++}{b3}.
% \item Aux lignes 17 à 19, s'il n'y a aucun coup possible, nous passons notre tour.
\item At lines 17 to 19, if there are no possible moves, we pass our turn.
% \item Aux lignes 20 à 21, nous générons aléatoirement le numéro du coup dans la variable \mintinline{c++}{bit}, qui correspond à un des bits de \mintinline{c++}{b0, b1, b2} ou \mintinline{c++}{b3}.
\item At lines 20 to 21, we randomly generate the move number in the \mintinline{c++}{bit} variable, which corresponds to one of the bits of \mintinline{c++}{b0, b1, b2}, or \mintinline{c++}{b3}.
% \item À la ligne 22, nous récupérons l'index du bitboard ${\texttt b}_i$ où se trouve le coup \mintinline{c++}{bit}. Par exemple, si \mintinline{c++}{n0 == 5} et \mintinline{c++}{n1 == 12} et \mintinline{c++}{bit == 7}, il faut chercher le coup dans \mintinline{c++}{b1} et le coup correspondra au deuxième bit à 1 dans \mintinline{c++}{b1}. Notons que l'on calcule cet index sans aucun branchement conditionnel. Nous avons remplacé une cascade de \mintinline{c++}{if/else if} par une somme de comparaisons~: chaque comparaison \mintinline{c++}{(bit >= ...)} retourne \mintinline{c++}{0} ou \mintinline{c++}{1}, et leur somme donne directement l'index recherché.
\item At line 22, we retrieve the index of the bitboard ${\texttt b}_i$ where move \mintinline{c++}{bit} is located. For example, if \mintinline{c++}{n0 == 5} and \mintinline{c++}{n1 == 12} and \mintinline{c++}{bit == 7}, we need to look for the move in \mintinline{c++}{b1} and the move will correspond to the second set bit in \mintinline{c++}{b1}. Note that we compute this index without any conditional branch. We replaced a cascade of \mintinline{c++}{if/else if} with a sum of comparisons: each comparison \mintinline{c++}{(bit >= ...)} returns \mintinline{c++}{0} or \mintinline{c++}{1}, and their sum directly gives the desired index.
% \item À la ligne 23, nous calculons l'index du bit à 1 dans le bitboard sélectionné. Pour cela, il faut soustraire le nombre de bits à 1 dans les bitboards ${\texttt b}_i$ précédents. Là encore nous utilisons le style \emph{branchless}.
\item At line 23, we compute the index of the set bit within the selected bitboard. To do this, we subtract the number of set bits in the previous bitboards ${\texttt b}_i$. Here again we use the \emph{branchless} style.
% \item À la ligne 24, nous sélectionnons la case de départ correspondant au coup aléatoire.
\item At line 24, we select the source square corresponding to the random move.
% \item À la ligne 25, nous sélectionnons le bitboard ${\texttt b}_i$ correspondant au coup aléatoire.
\item At line 25, we select the bitboard ${\texttt b}_i$ corresponding to the random move.
% \item À la ligne 26, maintenant que nous avons la case départ du coup, le bitboard \mintinline{c++}{bb} et l'index du bit à 1 dans \mintinline{c++}{bb}, nous pouvons construire le coup aléatoire en construisant la case d'arrivée du coup. Pour calculer la case d'arrivée du coup, nous pourrions utiliser le code suivant.
\item At line 26, now that we have the move's source square, the bitboard \mintinline{c++}{bb}, and the index of the set bit in \mintinline{c++}{bb}, we can construct the random move by building the destination square. To compute the move's destination square, we could use the following code.
\begin{minted}[breaklines,fontsize=\small,frame=none]{c++}
Square to;
while (bb) {
    int tz = countr_zero(bb); // position of the rightmost set bit
    if (bit-- == 0) {
        to = Square(tz);
        break;
    }
    bb &= bb - 1; // clear rightmost set bit
}
\end{minted}
% Mais la fonction \mintinline{c++}{_pdep_u64} (Parallel Bits Deposit), qui est basée sur une instruction \gls{bmi2}\footnote{C'est une instruction x86-64 (Intel Haswell+, AMD Zen+).}, permet d'effectuer ce code plus efficacement. En effet, \mintinline{c++}{_pdep_u64(1ULL << bit, bb)} retourne un bitboard avec un seul bit à 1, situé à la position du \mintinline{c++}{bit}-ième bit à 1 de \mintinline{c++}{bb}.
However, the \mintinline{c++}{_pdep_u64} function (Parallel Bits Deposit), which is based on a \gls{bmi2} instruction\footnote{This is an x86-64 instruction (Intel Haswell+, AMD Zen+).}, allows this code to be performed more efficiently. Indeed, \mintinline{c++}{_pdep_u64(1ULL << bit, bb)} returns a bitboard with a single set bit, located at the position of the \mintinline{c++}{bit}-th set bit of \mintinline{c++}{bb}.
% \item À la ligne 41, dans la fonction \mintinline{c++}{play_random_games_fast}, nous utilisons la fonction \mintinline{c++}{random_move} pour générer directement un coup aléatoire, au lieu de créer tout d'abord toute la liste des coups possibles puis d'en sélectionner un au hasard dans cette dernière.
\item At line 41, in the \mintinline{c++}{play_random_games_fast} function, we use the \mintinline{c++}{random_move} function to directly generate a random move, instead of first creating the entire list of possible moves and then selecting one at random from it.

% nous utilisons l'instruction \mintinline{c++}{_pdep_u64} (Parallel Bits Deposit) pour trouver la case d'arrivée. Cette instruction \gls{bmi2} permet de déposer le bit numéro \mintinline{c++}{bit} parmi les bits à 1 du bitboard \mintinline{c++}{bb}, puis \mintinline{c++}{countr_zero} nous donne la position de ce bit.
\end{itemize}

% Nous testons de nouveau les caractéristiques de notre programme avec \texttt{perf}, les résultats sont donnés dans le listing \ref{lst:perf_chapter02_3}.

We test our program's characteristics again with \texttt{perf}; the results are given in Listing~\ref{lst:perf_chapter02_3}.

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim} 
$ g++ -std=c++23 -O3 -march=native -Wall -Wpedantic chapter02.cpp\
-o chapter02
$ perf stat -r 10 -e cycles,instructions,branches,branch-misses,\
L1-dcache-loads,L1-dcache-load-misses,LLC-loads,LLC-load-misses,\
l1d_pend_miss.pending,l1d_pend_miss.pending_cycles ./chapter02

Performance counter stats for './chapter02' (10 runs):

     6 293 794 538      cycles                        ( +-  0.22% )
    15 430 554 773      instructions   # 2.43 IPC     ( +-  0.05% )
       792 545 398      branches                      ( +-  0.05% )
         2 354 243      branch-misses  # 0.30%        ( +-  0.26% )
     3 499 135 163      L1-dcache-loads               ( +-  0.07% )
       144 657 644      L1-dcache-load-misses # 4.14% ( +-  0.11% )
        52 835 597      LLC-loads                     ( +-  0.90% )
            11 787      LLC-load-misses # 0.02%       ( +-  8.82% )
     2 329 553 474      l1d_pend_miss.pending         ( +-  0.87% )
     1 708 715 065      l1d_pend_miss.pending_cycles  ( +-  0.82% )

           1.53 +- 0.00 seconds time elapsed
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{Compteurs de performances pour le programme du listing \ref{lst:random_games_perf4}.}
\captionof{listing}{Performance counters for the program in Listing~\ref{lst:random_games_perf4}.}
\label{lst:perf_chapter02_3}
\end{mdframed}

% Cette dernière optimisation réduit le temps d'exécution de moitié, passant de $3{,}06$ à $1{,}53$ secondes. L'\gls{ipc} s'améliore de $1{,}85$ à $2{,}43$. Le résultat le plus notable concerne les défauts de branchement : le taux passe de $10{,}16\%$ à $0{,}30\%$. Cette quasi-élimination des défauts de branchement s'explique par le style de programmation \emph{branchless} adopté qui a pu être mis en place car nous n'avons pas à générer dans cette version toute la liste des coups. En remplaçant les structures conditionnelles \mintinline{c++}{if/else} par des expressions arithmétiques (sommes de comparaisons), nous avons supprimé les branchements imprévisibles que le prédicteur de branchement du processeur ne parvenait pas à anticiper. L'instruction \mintinline{c++}{_pdep_u64} contribue également à cette amélioration en évitant une boucle avec un nombre d'itérations variable.

This last optimization cuts the execution time in half, going from $3.06$ to $1.53$ seconds. The \gls{ipc} improves from $1.85$ to $2.43$. The most notable result concerns branch mispredictions: the rate drops from $10.16\%$ to $0.30\%$. This near-elimination of branch mispredictions is explained by the \emph{branchless} programming style adopted, which was made possible because we no longer need to generate the entire move list in this version. By replacing \mintinline{c++}{if/else} conditional structures with arithmetic expressions (sums of comparisons), we eliminated the unpredictable branches that the processor's branch predictor could not anticipate. The \mintinline{c++}{_pdep_u64} instruction also contributes to this improvement by avoiding a loop with a variable number of iterations.

% \begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
% \begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
% constexpr uint32_t NB_ITERATIONS = 1000;
% constexpr uint64_t SEED = 42;

% class PRNG {
%     uint64_t s;
%     uint64_t rand64() {
%         s ^= s >> 12, s ^= s << 25, s ^= s >> 27;
%         return s * 2685821657736338717ULL;
%     }
%    public:
%     PRNG(uint64_t seed) :
%         s(seed) {
%     }
%     uint64_t seed() {
%         return s;
%     }
%     template<typename T>
%     T rand() {
%         return T(rand64());
%     }
% };

% constexpr uint32_t reduce(uint32_t x, uint32_t N) {
%     return ((uint64_t) x * (uint64_t) N) >> 32;
% }

% uint32_t random_prng_modulo(uint32_t nb_iterations) {
%     uint32_t res = 0;
%     PRNG prng(SEED);
%     for (uint32_t i = 1; i <= nb_iterations; i++) {
%         res += prng.rand<uint32_t>() % i;
%     }
%     return res;
% }

% static void BM_random_prng_modulo(benchmark::State& state) {
%     for (auto _ : state) {
%         benchmark::DoNotOptimize(random_prng_modulo(NB_ITERATIONS));
%     }
%     state.SetItemsProcessed(state.iterations());
% }
% BENCHMARK(BM_random_prng_modulo);

% uint32_t random_prng_reduce(uint32_t nb_iterations) {
%     uint32_t res = 0;
%     PRNG prng(SEED);
%     for (uint32_t i = 1; i <= nb_iterations; i++) {
%         res += reduce(prng.rand<uint32_t>(), i);
%     }
%     return res;
% }

% static void BM_random_prng_reduce(benchmark::State& state) {
%     for (auto _ : state) {
%         benchmark::DoNotOptimize(random_prng_reduce(NB_ITERATIONS));
%     }
%     state.SetItemsProcessed(state.iterations());
% }
% BENCHMARK(BM_random_prng_reduce);

% uint32_t random_mt19937(uint32_t nb_iterations) {
%     uint32_t res = 0;
%     mt19937 mt(SEED);
%     for (uint32_t i = 1; i <= nb_iterations; i++) {        
%         res += uniform_int_distribution<uint32_t>{0, i - 1}(mt);
%     }
%     return res;
% }

% static void BM_random_mt19937(benchmark::State& state) {
%     for (auto _ : state) {
%         benchmark::DoNotOptimize(random_mt19937(NB_ITERATIONS));
%     }
%     state.SetItemsProcessed(state.iterations());
% }
% BENCHMARK(BM_random_mt19937);

% uint32_t random_mt19937_modulo(uint32_t nb_iterations) {
%     uint32_t res = 0;
%     mt19937 mt(SEED);
%     for (uint32_t i = 1; i <= nb_iterations; i++) {        
%         res += uniform_int_distribution<uint32_t>{}(mt) % i;
%     }
%     return res;
% }

% static void BM_random_mt19937_modulo(benchmark::State& state) {
%     for (auto _ : state) {
%         benchmark::DoNotOptimize(random_mt19937_modulo(NB_ITERATIONS));
%     }
%     state.SetItemsProcessed(state.iterations());
% }
% BENCHMARK(BM_random_mt19937_modulo);

% uint32_t random_mt19937_reduce(uint32_t nb_iterations) {
%     uint32_t res = 0;
%     mt19937 mt(SEED);
%     for (uint32_t i = 1; i <= nb_iterations; i++) {        
%         res += reduce(uniform_int_distribution<uint32_t>{}(mt), i);
%     }
%     return res;
% }

% static void BM_random_mt19937_reduce(benchmark::State& state) {
%     for (auto _ : state) {
%         benchmark::DoNotOptimize(random_mt19937_reduce(NB_ITERATIONS));
%     }
%     state.SetItemsProcessed(state.iterations());
% }
% BENCHMARK(BM_random_mt19937_reduce);

% BENCHMARK_MAIN();
% \end{minted}
% \captionof{listing}{}
% \label{lst:random_generator_bench}
% \end{mdframed}

% \begin{mdframed}[skipabove=\baselineskip,hidealllines=true]
% \begin{minted}[fontsize=\footnotesize]{bash}
% $ g++ -std=c++23 -O3 -march=native -Wall -Wpedantic chapter02.cpp -o chapter02 -lbenchmark
% $ ./chapter02
% \end{minted}
% \end{mdframed}

% \begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
% {\small
% \begin{verbatim}
% Run on (12 X 4400 MHz CPU s)
% CPU Caches:
%   L1 Data 32 KiB (x6)
%   L1 Instruction 32 KiB (x6)
%   L2 Unified 256 KiB (x6)
%   L3 Unified 12288 KiB (x1)
% Load Average: 0.79, 0.91, 1.05
% -----------------------------------------------------------------------------------
% Benchmark                         Time             CPU   Iterations UserCounters...
% -----------------------------------------------------------------------------------
% BM_random_prng_modulo          2651 ns         2651 ns       258011 items_per_second=377.285k/s
% BM_random_prng_reduce          1667 ns         1667 ns       417675 items_per_second=599.745k/s
% BM_random_mt19937              5114 ns         5114 ns       122426 items_per_second=195.541k/s
% BM_random_mt19937_modulo       6069 ns         6068 ns       116983 items_per_second=164.794k/s
% BM_random_mt19937_reduce       4868 ns         4868 ns       146061 items_per_second=205.41k/s
% \end{verbatim}
% }
% \end{mdframed}
% %\vspace{-0.5\baselineskip}
% \begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% \captionof{listing}{}
% \label{lst:}
% \end{mdframed}

\section{What's Next}

% Nous avons maintenant à notre disposition une implémentation de Yolah efficace, dont tout le code est donné dans la section suivante. Grâce à cette implémentation, nous allons pouvoir développer des joueurs artificiels de plus en plus compétents pour notre jeu dans la suite de l'ouvrage.

We now have at our disposal an efficient implementation of Yolah, whose complete code is given in the following section. With this implementation, we will be able to develop increasingly capable artificial players for our game in the remainder of this book.

\section{Complete Board Game Code}

% Original French (corrected): Le listing complet du code du plateau est donné dans les listings \ref{lst:board_code_1}, \ref{lst:board_code_2}, \ref{lst:board_code_3} et \ref{lst:board_code_4}. Le résultat de l'exécution du programme est donné dans le listing \ref{lst:chapter02_exec}. On peut voir que, sur un million de parties aléatoires, les noirs semblent avoir l'avantage. Notons que cela ne prouve pas que le jeu est gagnant pour les noirs.

The complete board code is given in listings \ref{lst:board_code_1}, \ref{lst:board_code_2}, \ref{lst:board_code_3}, and \ref{lst:board_code_4}. The program execution result is given in listing \ref{lst:chapter02_exec}. We can see that over one million random games, black appears to have the advantage. Note that this does not prove that the game is winning for black.

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
#include <algorithm>
#include <array>
#include <bit>
#include <cstdint>
#include <format>
#include <iostream>
#include <optional>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <string_view>
#include <utility>
#include <vector>
#include <immintrin.h>
using namespace std;

// 8  56   57   58   59   60   61   62   63
// 7  48   49   50   51   52   53   54   55
// 6  40   41   42   43   44   45   46   47
// 5  32   33   34   35   36   37   38   39
// 4  24   25   26   27   28   29   30   31
// 3  16   17   18   19   20   21   22   23
// 2   8    9   10   11   12   13   14   15
// 1   0    1    2    3    4    5    6    7
//     a    b    c    d    e    f    g    h
enum Square : int8_t {
    SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
    SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
    SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
    SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
    SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
    SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
    SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
    SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
    SQ_NONE,
    SQUARE_ZERO = 0,
    SQUARE_NB   = 64
};

// 8  56     57     58     59     60     61     62     63
// 7  48     49     50     51     52     53     54     55
// 6  40     41     42     43     44     45     46     47
// 5  32     33     34     35     36     37     38     39
// 4  24     25     26     27     28     29     30     31
// 3  16     17     18     19     20     21     22     23
// 2   8      9     10     11     12     13     14     15
// 1   0      1      2      3      4      5      6      7
//  FILE_A FILE_B FILE_C FILE_D FILE_E FILE_F FILE_G FILE_H
enum File : uint8_t {
    FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, 
    FILE_F, FILE_G, FILE_H, FILE_NB
};

//  RANK_8 | 56  57  58  59  60  61  62  63
//  RANK_7 | 48  49  50  51  52  53  54  55
//  RANK_6 | 40  41  42  43  44  45  46  47
//  RANK_5 | 32  33  34  35  36  37  38  39
//  RANK_4 | 24  25  26  27  28  29  30  31
//  RANK_3 | 16  17  18  19  20  21  22  23
//  RANK_2 |  8   9  10  11  12  13  14  15
//  RANK_1 |  0   1   2   3   4   5   6   7
//            a   b   c   d   e   f   g   h
enum Rank : uint8_t {
    RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, 
    RANK_6, RANK_7, RANK_8, RANK_NB
};

// Directions from sq = 27 (d4):
//
//   +------+------+------+------+------+------+------+------+
// 8 |  56  |  57  |  58  |  59  |  60  |  61  |  62  |  63  |
//   +------+------+------+------+------+------+------+------+
// 7 |  48  |  49  |  50  |  51  |  52  |  53  |  54  |  55  |
//   +------+------+------+------+------+------+------+------+
// 6 |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |
//   +------+------+------+------+------+------+------+------+
// 5 |  32  |  33  |NW 34 |N  35 |NE 36 |  37  |  38  |  39  |
//   +------+------+------+------+------+------+------+------+
// 4 |  24  |  25  |W  26 |>>27<<|E  28 |  29  |  30  |  31  |
//   +------+------+------+------+------+------+------+------+
// 3 |  16  |  17  |SW 18 |S  19 |SE 20 |  21  |  22  |  23  |
//   +------+------+------+------+------+------+------+------+
// 2 |   8  |   9  |  10  |  11  |  12  |  13  |  14  |  15  |
//   +------+------+------+------+------+------+------+------+
// 1 |   0  |   1  |   2  |   3  |   4  |   5  |   6  |   7  |
//   +------+------+------+------+------+------+------+------+
//      a      b      c      d      e      f      g      h
enum Direction : int8_t {
    NORTH = 8,
    EAST  = 1,
    SOUTH = -NORTH, // -8
    WEST  = -EAST,  // -1
    NORTH_EAST = NORTH + EAST, // 9
    SOUTH_EAST = SOUTH + EAST, // -7
    SOUTH_WEST = SOUTH + WEST, // -9
    NORTH_WEST = NORTH + WEST  // 7
};

// ORTHOGONAL moves from d4:         DIAGONAL moves from d4:
//
// 8  .  .  .  *  .  .  .  .         .  .  .  .  .  .  .  *
// 7  .  .  .  *  .  .  .  .         *  .  .  .  .  .  *  .
// 6  .  .  .  *  .  .  .  .         .  *  .  .  .  *  .  .
// 5  .  .  .  *  .  .  .  .         .  .  *  .  *  .  .  .
// 4  *  *  * sq  *  *  *  *         .  .  . sq  .  .  .  .
// 3  .  .  .  *  .  .  .  .         .  .  *  .  *  .  .  .
// 2  .  .  .  *  .  .  .  .         .  *  .  .  .  *  .  .
// 1  .  .  .  *  .  .  .  .         *  .  .  .  .  .  *  .
//    a  b  c  d  e  f  g  h         a  b  c  d  e  f  g  h
enum MoveType {
    ORTHOGONAL,
    DIAGONAL
};

// Black player
constexpr uint8_t BLACK = 0;
// White Player
constexpr uint8_t WHITE = 1;
// Square is destroyed
constexpr uint8_t HOLE  = 2;
// Square is free
constexpr uint8_t FREE  = 3;

// FileABB: bitboard for file A, bits on file A are set to 1,
// all other bits are set to 0. Other file bitboards are derived
// by shifting FileABB to the left.
//
//    FileABB           FileBBB           FileCBB
// 8  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 7  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 6  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 5  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 4  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 3  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 2  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
// 1  1 . . . . . . .   . 1 . . . . . .   . . 1 . . . . .
//    a b c d e f g h   a b c d e f g h   a b c d e f g h
//
//    FileDBB           FileEBB           FileFBB
// 8  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 7  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 6  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 5  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 4  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 3  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 2  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
// 1  . . . 1 . . . .   . . . . 1 . . .   . . . . . 1 . .
//    a b c d e f g h   a b c d e f g h   a b c d e f g h
//
//    FileGBB           FileHBB
// 8  . . . . . . 1 .   . . . . . . . 1
// 7  . . . . . . 1 .   . . . . . . . 1
// 6  . . . . . . 1 .   . . . . . . . 1
// 5  . . . . . . 1 .   . . . . . . . 1
// 4  . . . . . . 1 .   . . . . . . . 1
// 3  . . . . . . 1 .   . . . . . . . 1
// 2  . . . . . . 1 .   . . . . . . . 1
// 1  . . . . . . 1 .   . . . . . . . 1
//    a b c d e f g h   a b c d e f g h
constexpr uint64_t FileABB = 0x0101010101010101;
constexpr uint64_t FileBBB = FileABB << 1;
constexpr uint64_t FileCBB = FileABB << 2;
constexpr uint64_t FileDBB = FileABB << 3;
constexpr uint64_t FileEBB = FileABB << 4;
constexpr uint64_t FileFBB = FileABB << 5;
constexpr uint64_t FileGBB = FileABB << 6;
constexpr uint64_t FileHBB = FileABB << 7;

// Rank1BB: bitboard for rank 1, bits on rank 1 are set to 1,
// all other bits are set to 0. Other rank bitboards are derived
// by shifting Rank1BB to the left by multiples of 8.
//
//    Rank1BB           Rank2BB           Rank3BB
// 8  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 7  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 6  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 5  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 4  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 3  . . . . . . . .   . . . . . . . .   1 1 1 1 1 1 1 1
// 2  . . . . . . . .   1 1 1 1 1 1 1 1   . . . . . . . .
// 1  1 1 1 1 1 1 1 1   . . . . . . . .   . . . . . . . .
//    a b c d e f g h   a b c d e f g h   a b c d e f g h
//
//    Rank4BB           Rank5BB           Rank6BB
// 8  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 7  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 6  . . . . . . . .   . . . . . . . .   1 1 1 1 1 1 1 1
// 5  . . . . . . . .   1 1 1 1 1 1 1 1   . . . . . . . .
// 4  1 1 1 1 1 1 1 1   . . . . . . . .   . . . . . . . .
// 3  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 2  . . . . . . . .   . . . . . . . .   . . . . . . . .
// 1  . . . . . . . .   . . . . . . . .   . . . . . . . .
//    a b c d e f g h   a b c d e f g h   a b c d e f g h
//
//    Rank7BB           Rank8BB
// 8  . . . . . . . .   1 1 1 1 1 1 1 1
// 7  1 1 1 1 1 1 1 1   . . . . . . . .
// 6  . . . . . . . .   . . . . . . . .
// 5  . . . . . . . .   . . . . . . . .
// 4  . . . . . . . .   . . . . . . . .
// 3  . . . . . . . .   . . . . . . . .
// 2  . . . . . . . .   . . . . . . . .
// 1  . . . . . . . .   . . . . . . . .
//    a b c d e f g h   a b c d e f g h
constexpr uint64_t Rank1BB = 0xFF;
constexpr uint64_t Rank2BB = Rank1BB << (8 * 1);
constexpr uint64_t Rank3BB = Rank1BB << (8 * 2);
constexpr uint64_t Rank4BB = Rank1BB << (8 * 3);
constexpr uint64_t Rank5BB = Rank1BB << (8 * 4);
constexpr uint64_t Rank6BB = Rank1BB << (8 * 5);
constexpr uint64_t Rank7BB = Rank1BB << (8 * 6);
constexpr uint64_t Rank8BB = Rank1BB << (8 * 7);

// Initial positions: Black starts at a1, d4, e5, h8.
// White starts at a8, d5, e4, h1.
//
// BLACK_INITIAL_POSITION       WHITE_INITIAL_POSITION
//
// 8  .  .  .  .  .  .  .  B    W  .  .  .  .  .  .  .
// 7  .  .  .  .  .  .  .  .    .  .  .  .  .  .  .  .
// 6  .  .  .  .  .  .  .  .    .  .  .  .  .  .  .  .
// 5  .  .  .  .  B  .  .  .    .  .  .  W  .  .  .  .
// 4  .  .  .  B  .  .  .  .    .  .  .  .  W  .  .  .
// 3  .  .  .  .  .  .  .  .    .  .  .  .  .  .  .  .
// 2  .  .  .  .  .  .  .  .    .  .  .  .  .  .  .  .
// 1  B  .  .  .  .  .  .  .    .  .  .  .  .  .  .  W
//    a  b  c  d  e  f  g  h    a  b  c  d  e  f  g  h
constexpr uint64_t BLACK_INITIAL_POSITION =
0b10000000'00000000'00000000'00001000'00010000'00000000'00000000'00000001;
constexpr uint64_t WHITE_INITIAL_POSITION =
0b00000001'00000000'00000000'00010000'00001000'00000000'00000000'10000000;
\end{minted}
\captionof{listing}{Complete game board code (part 1/4 -- types, constants and bitboards)}
\label{lst:board_code_1}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, firstnumber=234, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
// Returns the square at rank i, file j
constexpr Square square_of(int i, int j) {
    return Square(i * 8 + j);
}

// Checks whether a square is within the valid range [A1, H8]
constexpr bool is_ok(Square s) {
    return s >= SQ_A1 && s <= SQ_H8;
}

// Extracts the file (column) from a square: s % 8
constexpr File file_of(Square s) {
    return File(s & 7);
}

// Extracts the rank (row) from a square: s / 8
constexpr Rank rank_of(Square s) {
    return Rank(s >> 3);
}

// Returns a bitboard with all bits set on rank r
constexpr uint64_t rank_bb(Rank r) {
    return Rank1BB << (8 * r);
}

// Returns a bitboard with all bits set on the rank of square s
constexpr uint64_t rank_bb(Square s) {
    return rank_bb(rank_of(s));
}

// Returns a bitboard with all bits set on file f
constexpr uint64_t file_bb(File f) {
    return FileABB << f;
}

// Returns a bitboard with all bits set on the file of square s
constexpr uint64_t file_bb(Square s) {
    return file_bb(file_of(s));
}

// Returns a bitboard with only the bit corresponding to square s set
constexpr uint64_t square_bb(Square s) {
    return uint64_t(1) << s;
}

// Moves a square in a given direction
constexpr Square operator+(Square s, Direction d) {
    return Square(int(s) + int(d));
}

// Pre-increment operator to iterate over squares
Square& operator++(Square& d) {
    return d = Square(int(d) + 1);
}

// Returns the least significant bit as a Square (index 
// of first set bit)
constexpr Square lsb(uint64_t b) {
    return Square(std::countr_zero(b));
}

// Extracts and clears the least significant bit, returns it as 
// a Square
Square pop_lsb(uint64_t& b) {
    const Square s = lsb(b);
    b &= b - 1;
    return s;
}

// Computes the Manhattan distance (|rank1 - rank2| + |file1 - file2|)
int manhattan_distance(Square sq1, Square sq2) {
    int d_rank = std::abs(rank_of(sq1) - rank_of(sq2));
    int d_file = std::abs(file_of(sq1) - file_of(sq2));
    return d_rank + d_file;
}

// Shifts all bits of a bitboard in direction D. For horizontal and
// diagonal shifts, bits on the edge file are masked out to prevent 
// wrapping around the board (e.g., a piece on file H shifted east 
// would appear on file A)
template<Direction D>
constexpr uint64_t shift(uint64_t b) {
    if constexpr (D == NORTH)
        return b << NORTH;
    else if constexpr (D == SOUTH)
        return b >> -SOUTH;
    else if constexpr (D == EAST)
        return (b & ~FileHBB) << EAST;
    else if constexpr (D == WEST)
        return (b & ~FileABB) >> -WEST;
    else if constexpr (D == NORTH_EAST)
        return (b & ~FileHBB) << NORTH_EAST;
    else if constexpr (D == NORTH_WEST)
        return (b & ~FileABB) << NORTH_WEST;
    else if constexpr (D == SOUTH_EAST)
        return (b & ~FileHBB) >> -SOUTH_EAST;
    else if constexpr (D == SOUTH_WEST)
        return (b & ~FileABB) >> -SOUTH_WEST;
    else return 0;
}

// Computes all squares reachable from sq by sliding in the given move 
// type (orthogonal or diagonal), stopping at occupied squares or
// board edges. Used during magic bitboard initialization to build the 
// move tables
uint64_t reachable_squares(MoveType mt, Square sq, 
                           uint64_t occupied) {
    uint64_t  moves    = 0;
    Direction o_dir[4]={NORTH, SOUTH, EAST, WEST};
    Direction d_dir[4]={NORTH_EAST,SOUTH_EAST,SOUTH_WEST,NORTH_WEST};
    for (Direction d : (mt == ORTHOGONAL ? o_dir : d_dir)) {
        Square s = sq;
        while (true) {
            Square to = s + d;
            if (!is_ok(to) || manhattan_distance(s, to) > 2) break;
            uint64_t bb = square_bb(to);
            if ((bb & occupied) != 0) break;
            moves |= bb;
            s = to;
        }
    }
    return moves;
}

// Magic bitboard entry for one square. The mask isolates the relevant
// occupancy bits, the magic number maps them to a unique index, and 
// the moves pointer references the precomputed move bitboards in the 
// table
struct Magic {
    uint64_t  mask;   // relevant occupancy mask (edges excluded)
    uint64_t  magic;  // magic multiplier for this square
    uint64_t* moves;  // pointer into the move lookup table
    uint32_t  shift;  // right shift amount = 64 - popcount(mask)

    // Computes the table index for a given occupancy configuration
    uint32_t index(uint64_t occupied) const {
        return uint32_t( ((occupied & mask) * magic) >> shift );
    }
};

// Precomputed move lookup tables for all squares
uint64_t orthogonalTable[102400];
uint64_t diagonalTable[5248];

// Magic bitboard entries for each square
Magic orthogonalMagics[SQUARE_NB];
Magic diagonalMagics[SQUARE_NB];

// Combines orthogonal and diagonal magic table lookups to return a 
// bitboard of all squares that a piece on sq can reach, given the 
// board occupancy
uint64_t moves_bb(Square sq, uint64_t occupied) {
    uint32_t idx_omoves = orthogonalMagics[sq].index(occupied);
    uint32_t idx_dmoves = diagonalMagics[sq].index(occupied);
    return orthogonalMagics[sq].moves[idx_omoves] | diagonalMagics[sq].moves[idx_dmoves];
}

// Initializes magic bitboard tables for a given move type (orthogonal 
// or diagonal). For each square, enumerates all possible occupancy 
// patterns using the Carry-Rippler trick, computes the corresponding 
// reachable squares, and stores them in the lookup table indexed by 
// the magic hash
void init_magics(MoveType mt, uint64_t table[], Magic magics[]) {
    static constexpr uint64_t O_MAGIC[64] = {
        0x80011040002082,   0x40022002100040,   0x1880200081181000,
        0x2080240800100080, 0x8080024400800800, 0x4100080400024100,
        0xc080028001000a00, 0x80146043000080,   0x8120802080034004,
        0x8401000200240,    0x202001282002044,  0x81010021000b1000,
        0x808044000800,     0x300080800c000200, 0x8c000268411004,
        0x810080058020c100, 0xc248608010400080, 0x30024040002000,
        0x9001010042102000, 0x210009001002,     0xa0061d0018001100,
        0x2410808004000600, 0x6400240008025001, 0xc10600010340a4,
        0x628080044011,     0x4810014040002000, 0x380200080801000,
        0x10018580080010,   0x101040080180180,  0x9208020080040080,
        0x10400a21008,      0x6800104200010484, 0x21400280800020,
        0x9400402008401001, 0x8430006800200400, 0x8104411202000820,
        0x8010171000408,    0x1202000402001008, 0x881100904002208,
        0x15a0800a49802100, 0x224001808004,     0x4420201002424000,
        0xc04500020008080,  0x2503009004210008, 0x42801010010,
        0x2000400090100,    0x8080011810040002, 0x44401c008046000d,
        0x4000800521104100, 0x82000b080400080,  0x10821022420200,
        0x9488a82104100100, 0x1004800041100,    0x81600a0034008080,
        0xa00056210280400,  0x5124088200,       0x4210410010228202,
        0x1802230840001081, 0x1002102000400901, 0x1100c46010000901,
        0x281000408001003,  0xc001001c00028809, 0x10020008008c4102,
        0x280005008c014222,
    };
    static constexpr uint64_t D_MAGIC[64] = {
        0x811100100408200,  0x412100401044020,  0x404044c00408002,
        0xa0c070200010102,  0x104042001400008,  0x8802013008080000,
        0x1001008860080080, 0x20220044202800,   0x2002610802080160,
        0x4080800808610,    0x91c2800a10a0132,  0x400242401822000,
        0x8530040420040001, 0x142010c210048,    0x8841820801241004,
        0x804212084108801,  0x2032402094100484, 0x40202110010210a2,
        0x8010000800202020, 0x800240421a800,    0x62200401a00444,
        0x224082200820845,  0x106021492012000,  0x8481020082849000,
        0x40a110c59602800,  0x10020108020400,   0x208c020844080010,
        0x2000480004012020, 0x8001004004044000, 0xa044104128080200,
        0x1108008015cc1400, 0x8284004801844400, 0x8180a020c2004,
        0x9101004080100,    0x8840264108800c0,  0xc004200900200900,
        0x8040008020020020, 0x20010802e1920200, 0x80204000480a0,
        0xc0a80a100008400,  0x4018808114000,    0x90092200b9000,
        0x80020c0048000400, 0x6018005500,       0x80a0204110a00,
        0x4018808407201,    0x6050040806500280, 0x108208400c40180,
        0x803081210840480,  0x201210402200200,  0x200010400920042,
        0x902000a884110010, 0x851002021004,     0x43c08020120,
        0x6140500501010044, 0x200a04440400c028, 0x14a002084046000,
        0x10002409041040,   0x100022020500880b, 0x1000000000460802,
        0x21084104410,      0x8000001053300104, 0x4000182008c20048,
        0x112088105020200,
    };
    int size = 0;
    vector<uint64_t> occupancies;
    vector<uint64_t> possible_moves;
    for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
        occupancies.clear();
        possible_moves.clear();
        Magic& m = magics[sq];
        uint64_t edges = ((Rank1BB | Rank8BB) & ~rank_bb(sq)) |
                            ((FileABB | FileHBB) & ~file_bb(sq));
        uint64_t moves_bb = reachable_squares(mt, sq, 0) & ~edges;
        m.mask = moves_bb;
        m.shift = 64 - popcount(m.mask);
        m.magic = (mt == ORTHOGONAL ? O_MAGIC : D_MAGIC)[sq];
        m.moves = table + size;
        uint64_t b = 0;
        do {
            occupancies.push_back(b);
            possible_moves.push_back(reachable_squares(mt, sq, b));
            b = (b - moves_bb) & moves_bb;
            size++;
        } while (b);
        for (size_t j = 0; j < occupancies.size(); j++) {
            int32_t index = m.index(occupancies[j]);
            m.moves[index] = possible_moves[j];
        }
    }
}

// Initializes both orthogonal and diagonal magic bitboard tables
void init_all_magics() {
    init_magics(ORTHOGONAL, orthogonalTable, orthogonalMagics);
    init_magics(DIAGONAL, diagonalTable, diagonalMagics);
}
\end{minted}
\captionof{listing}{Complete game board code (part 2/4 -- utility functions and magic bitboards)}
\label{lst:board_code_2}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, firstnumber=472, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
// Compact move representation: packs source and destination squares 
// into a 16-bit integer (6 bits each). Move::none() encodes a 
// pass (data = 0, i.e., from = a1, to = a1), used when a player has
// no legal move
class Move {
    uint16_t data;
public:
    constexpr Move() noexcept = default;
    constexpr explicit Move(uint16_t d) noexcept : data(d) {}
    constexpr explicit Move(Square from, Square to) noexcept
        : data((to << 6) + from) {}
    constexpr Square from_sq() const noexcept {
        return Square(data & 0x3F);
    }
    constexpr Square to_sq() const noexcept {
        return Square((data >> 6) & 0x3F);
    }
    constexpr uint16_t raw() const noexcept { return data; }
    static constexpr Move none() noexcept { return Move(0); }
    constexpr bool operator==(const Move& m) const noexcept {
        return data == m.data;
    }
    constexpr bool operator!=(const Move& m) const noexcept {
        return data != m.data;
    }
    constexpr bool operator<(const Move& m) const noexcept {
        return make_pair(from_sq(), to_sq()) < 
               make_pair(m.from_sq(), m.to_sq());
    }
    constexpr explicit operator bool() const noexcept { 
        return data != 0; 
    }
};

// Prints a move in "from:to" notation (e.g., "d4:d7")
ostream& operator<<(ostream& os, const Move& m) {
    static constexpr std::string_view square2string[SQUARE_NB] = {
        "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1",
        "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
        "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
        "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
        "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
        "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
        "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
        "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
    };
    os << square2string[m.from_sq()] << ':' 
       << square2string[m.to_sq()];
    return os;
}

// Stack-allocated move list with a fixed capacity. Avoids heap 
// allocation during move generation. 
// Over millions of random games, the observed maximum number of 
// moves never exceeded 73; 75 is a safe upper bound
static constexpr uint16_t MAX_NB_MOVES = 75;
class MoveList {
    Move move_list[MAX_NB_MOVES], *last;
public:
    constexpr MoveList() noexcept : last(move_list) {}
    constexpr const Move* begin() const noexcept { return move_list; }
    constexpr const Move* end() const noexcept { return last; }
    constexpr Move* begin() noexcept { return move_list; }
    constexpr Move* end() noexcept { return last; }
    constexpr size_t size() const noexcept { 
        return last - move_list; 
    }
    constexpr const Move& operator[](size_t i) const { 
        return move_list[i]; 
    }
    constexpr Move& operator[](size_t i) { return move_list[i]; }
    constexpr Move* data() noexcept { return move_list; }
    friend class Yolah;
};

// Forward declaration of test function
namespace test {
    void random_games(size_t nb_games, 
                      optional<uint64_t> seed = nullopt);
}
struct YolahWithMoves;

// Board game. Uses three bitboards (black, white, holes) to 
// represent the board. Each player starts with 4 pieces. On each 
// turn, a piece slides orthogonally or diagonally to a free square; 
// the departure square becomes a hole. The game ends when no piece 
// can move. The player with the most moves wins
class Yolah {
    uint64_t black = BLACK_INITIAL_POSITION;
    uint64_t white = WHITE_INITIAL_POSITION;
    uint64_t holes = 0;        // destroyed squares
    uint8_t black_score = 0;   // number of moves played by black
    uint8_t white_score = 0;   // number of moves played by white
    uint8_t ply = 0;           // current ply (0 = black's first turn)
public:
    // The game is over when no piece of either player has an adjacent 
    // free square
    constexpr bool game_over() const noexcept {
        uint64_t possible = ~holes & ~black & ~white;
        uint64_t players  = black | white;
        uint64_t around_players = shift<NORTH>(players) |
            shift<SOUTH>(players) | shift<EAST>(players) |
            shift<WEST>(players) | shift<NORTH_EAST>(players) |
            shift<NORTH_WEST>(players) | shift<SOUTH_EAST>(players) |
            shift<SOUTH_WEST>(players);
        return (around_players & possible) == 0;
    }

    // Returns BLACK (0) or WHITE (1) based on parity of ply
    constexpr uint8_t current_player() const noexcept {
        return ply & 1;
    }

    constexpr uint8_t nb_plies() const noexcept {
        return ply;
    }

    constexpr pair<uint8_t, uint8_t> score() const noexcept {
        return {black_score, white_score};
    }

    // Returns the content of a square: BLACK, WHITE, HOLE, or FREE
    constexpr uint8_t get(Square sq) const noexcept {
        uint64_t bb = square_bb(sq);
        if (holes & bb) return HOLE;
        if (black & bb) return BLACK;
        if (white & bb) return WHITE;
        return FREE;
    }

    constexpr uint8_t get(int i, int j) const noexcept {        
        return get(square_of(i, j));
    }

    // Generates all legal moves for the given player into the 
    // provided MoveList. Since each player always has exactly 
    // 4 pieces, the first loop is fully unrolled (version 2) 
    // to avoid branch mispredictions. If no move is available,
    // a single Move::none() is added
    void moves(uint8_t player, MoveList& moves) const noexcept {
        Move* move_list = moves.move_list;
        uint64_t occupied = black | white | holes;
        uint64_t bb = player == BLACK ? black : white;

        // Version 1: generic loop (commented out, kept for reference)
        // while (bb) {
        //     Square from = pop_lsb(bb);
        //     uint64_t b = moves_bb(from, occupied) & ~occupied;
        //     while (b) {
        //         *move_list++ = Move(from, pop_lsb(b));
        //     }
        // }

        // Version 2: unrolled loop for the 4 pieces
        Square from0 = pop_lsb(bb);
        Square from1 = pop_lsb(bb);
        Square from2 = pop_lsb(bb);
        Square from3 = pop_lsb(bb);

        uint64_t b0 = moves_bb(from0, occupied) & ~occupied;
        uint64_t b1 = moves_bb(from1, occupied) & ~occupied;
        uint64_t b2 = moves_bb(from2, occupied) & ~occupied;
        uint64_t b3 = moves_bb(from3, occupied) & ~occupied;

        while (b0) {
            *move_list++ = Move(from0, pop_lsb(b0));
        }
        while (b1) {
            *move_list++ = Move(from1, pop_lsb(b1));
        }
        while (b2) {
            *move_list++ = Move(from2, pop_lsb(b2));
        }
        while (b3) {
            *move_list++ = Move(from3, pop_lsb(b3));
        }
        if (move_list == moves.move_list) [[unlikely]] {
            *move_list++ = Move::none();
        }

        moves.last = move_list;
    }

    // Generates moves for the current player
    void moves(MoveList& moves) const noexcept {
        this->moves(current_player(), moves);
    }

    // Selects a uniformly random legal move without allocating a
    // move list while minimizing branches
    Move random_move(mt19937& mt) const noexcept {
        uint64_t occupied = black | white | holes;
        uint64_t player_bb = 
            current_player() == BLACK ? black : white;
        Square from0 = pop_lsb(player_bb);
        Square from1 = pop_lsb(player_bb);
        Square from2 = pop_lsb(player_bb);
        Square from3 = pop_lsb(player_bb);
        uint64_t b0 = moves_bb(from0, occupied) & ~occupied;
        uint64_t b1 = moves_bb(from1, occupied) & ~occupied;
        uint64_t b2 = moves_bb(from2, occupied) & ~occupied;
        uint64_t b3 = moves_bb(from3, occupied) & ~occupied;
        int n0 = popcount(b0);
        int n1 = popcount(b1);
        int n2 = popcount(b2);
        int n3 = popcount(b3);
        int n = n0 + n1 + n2 + n3;
        if (n == 0) [[unlikely]] {
            return Move::none();
        }
        uniform_int_distribution<int> d(0, n - 1);
        int bit = d(mt);
        int bb_index = (bit >= n0) + (bit >= n0 + n1) + 
                       (bit >= n0 + n1 + n2);
        bit -= (bb_index > 0) * n0 + (bb_index > 1) * n1 + 
               (bb_index > 2) * n2;
        Square from = array{from0, from1, from2, from3}[bb_index];
        uint64_t bb = array{ b0, b1, b2, b3 }[bb_index];        
        // _pdep_u64 extracts the bit-th destination from bb without
        // a loop. Example: bb = 0b01010100 (3 set bits), 
        // bit = 2 (3rd move):
        //   1ULL << 2           = 0b00000100
        //   _pdep_u64(0b100,bb) = 0b01000000  (the 3rd set bit of bb)
        //   countr_zero(...)    = 6           (square index)
        //
        // Without _pdep_u64, the equivalent code would be:
        // for (int i = 0; i < bit; i++) bb &= bb - 1; 
                                            // bb &= bb - 1 
                                            // clears the least
                                            // significant bit of bb 
        // Square to = countr_zero(bb);                          
        Square to = Square(countr_zero(_pdep_u64(1ULL << bit, bb)));
        return Move(from, to);
    }

    // Applies a move: moves the piece from source to destination, 
    // turns the source square into a hole, and increments the 
    // player's score.
    // For Move::none() (pass), only the ply counter is incremented
    void play(Move m) noexcept {
        if (m != Move::none()) [[likely]] {
            uint64_t pos1 = square_bb(m.from_sq());
            uint64_t pos2 = square_bb(m.to_sq());
            if (ply & 1) {
                white ^= pos1 | pos2;
                white_score++;
            } else {
                black ^= pos1 | pos2;
                black_score++;
            }
            holes |= pos1;
        }
        ply++;
    }

    // Reverses a move: restores the piece, removes the hole, 
    // decrements score
    void undo(Move m) noexcept {
        ply--;
        if (m != Move::none()) [[likely]] {
            uint64_t pos1 = square_bb(m.from_sq());
            uint64_t pos2 = square_bb(m.to_sq());
            if (ply & 1) {
                white ^= pos1 | pos2;
                white_score--;
            } else {
                black ^= pos1 | pos2;
                black_score--;
            }
            holes ^= pos1;
        }
    }

    // Equality: compares all state fields
    constexpr bool operator==(const Yolah& other) const noexcept {
        return black == other.black
            && white == other.white
            && holes == other.holes
            && black_score == other.black_score
            && white_score == other.white_score
            && ply == other.ply;
    }

    constexpr bool operator!=(const Yolah& other) const noexcept {
        return !(*this == other);
    }
};
\end{minted}
\captionof{listing}{Complete game board code (part 3/4 -- Move, MoveList and Yolah classes)}
\label{lst:board_code_3}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,topline=false,rightline=false,bottomline=false,leftline=false,linewidth=1pt,linecolor=gray!40,innerleftmargin=8pt]
\begin{minted}[linenos, firstnumber=742, breaklines,fontsize=\small,frame=none,tabsize=2]{c++}
// Pairs a Yolah board with its legal moves for display purposes
struct YolahWithMoves {
    const Yolah& yolah;
    const MoveList& moves;
    YolahWithMoves(const Yolah& y, 
                   const MoveList& m) : yolah(y), moves(m) {}
};

// Displays the board with Unicode box-drawing, marking 
// reachable squares
ostream& operator<<(ostream& os, const YolahWithMoves& ym) {
    char grid[8][8];
    const Yolah& yolah = ym.yolah;
    const MoveList& moves = ym.moves;
    static constexpr string_view players[] = {
        "Black player",
        "White player"
    };
    static constexpr char content[] = {'B', 'W', 'H', '.'};
    uint8_t player = yolah.current_player();
    os << players[player] << '\n';
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            Square dst = square_of(i, j);
            if (any_of(begin(moves), end(moves), [&](const Move& m) {
                return m.to_sq() == dst;
            })) {
                grid[i][j] = player == BLACK ? 'X' : 'x';
            }
            else grid[i][j] = content[yolah.get(dst)];
        }
    }
    os << "\n  ┌───┬───┬───┬───┬───┬───┬───┬───┐\n";
    for (int i = 7; i >= 0; i--) {
        os << i + 1 << " │";
        for (int j = 0; j < 8; j++) {
            char c = grid[i][j];
            if (c == 'B') os << " ○ ";
            else if (c == 'W') os << " ● ";
            else if (c == 'H') os << "   ";
            else if (c == '.') os << " · ";
            else os << ' ' << c << ' ';
            os << "│";
        }
        os << '\n';
        if (i > 0) os << "  ├───┼───┼───┼───┼───┼───┼───┼───┤\n";
    }
    os << "  └───┴───┴───┴───┴───┴───┴───┴───┘\n";
    os << "    a   b   c   d   e   f   g   h\n";
    const auto [black_score, white_score] = yolah.score();
    os << "score: " << int(black_score) << '/' 
       << int(white_score) << '\n';
    return os;
}

// Displays the board without move annotations
ostream& operator<<(ostream& os, const Yolah& yolah) {
    return os << YolahWithMoves(yolah, MoveList());    
}

// Plays random games using standard move generation. When 
// STEP_BY_STEP is true, prints board and moves at each turn 
// and waits for user input
template<bool STEP_BY_STEP = true>
void play_random_games(size_t nb_games, 
                       optional<uint64_t> seed = nullopt) {
    MoveList moves;
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    size_t black_wins = 0;
    size_t white_wins = 0;
    size_t draws = 0;

    for (size_t i = 0; i < nb_games; i++) {
        Yolah yolah;    
        while (!yolah.game_over()) {                 
            if constexpr (STEP_BY_STEP) cout << yolah << '\n';        
            yolah.moves(moves);
            if constexpr (STEP_BY_STEP) {
                sort(begin(moves), end(moves));
                cout << format("# moves: {}\n", moves.size());
                for (const auto& m : moves) {
                    cout << m << ' ';
                }
                cout << "\n\n";
                cout << YolahWithMoves(yolah, moves) << '\n';
            }
            uniform_int_distribution<int> d(0, moves.size() - 1);
            Move m = moves[d(mt)];
            if constexpr (STEP_BY_STEP) {
                cout << m << '\n';
                std::string _;
                std::getline(std::cin, _);
            }
            yolah.play(m);
        }
        if constexpr (STEP_BY_STEP) cout << yolah << '\n';
        
        auto [black_score, white_score] = yolah.score();
        if (black_score > white_score) {
            black_wins++;
        } else if (white_score > black_score) {
            white_wins++;
        } else {
            draws++;
        }
    }

    if constexpr (!STEP_BY_STEP) {
        cout << format("\n=== Game Statistics ===\n");
        cout << format("Total games: {}\n", nb_games);
        cout << format("Black wins:  {} ({:.1f}%)\n", black_wins, 
                       100.0 * black_wins / nb_games);
        cout << format("White wins:  {} ({:.1f}%)\n", white_wins, 
                       100.0 * white_wins / nb_games);
        cout << format("Draws:       {} ({:.1f}%)\n", draws, 
                       100.0 * draws / nb_games);
    }
}

// Plays random games using random_move (no move list allocation)
void play_random_games_fast(size_t nb_games, 
                            optional<uint64_t> seed = nullopt) {
    random_device rd;
    mt19937 mt(seed.value_or(rd()));
    size_t black_wins = 0;
    size_t white_wins = 0;
    size_t draws = 0;
    for (size_t i = 0; i < nb_games; i++) {
        Yolah yolah;
        while (!yolah.game_over()) {
            Move m = yolah.random_move(mt);
            yolah.play(m);
        }
        auto [black_score, white_score] = yolah.score();
        if (black_score > white_score) {
            black_wins++;
        } else if (white_score > black_score) {
            white_wins++;
        } else {
            draws++;
        }
    }
    cout << format("\n=== Game Statistics ===\n");
    cout << format("Total games: {}\n", nb_games);
    cout << format("Black wins:  {} ({:.1f}%)\n", black_wins, 
                   100.0 * black_wins / nb_games);
    cout << format("White wins:  {} ({:.1f}%)\n", white_wins, 
                   100.0 * white_wins / nb_games);
    cout << format("Draws:       {} ({:.1f}%)\n", draws, 
                   100.0 * draws / nb_games);
}

// Differential and property-based tests: differential testing 
// validates move generation by comparing against a naive reference 
// implementation; property-based testing checks invariants like undo 
// reversibility and game-over detection
namespace test {
    namespace {
        using std::format;

        constexpr string_view RED    = "\033[1;31m";
        constexpr string_view GREEN  = "\033[1;32m";
        constexpr string_view YELLOW = "\033[1;33m";
        constexpr string_view RESET  = "\033[0m";
        constexpr string_view BOLD   = "\033[1m";

        struct TestResult {
            bool passed;
            string message;
            operator bool() const { return passed; }
        };

        TestResult pass() { return {true, ""}; }
        TestResult fail(string msg) { 
            return {false, std::move(msg)}; 
        }

        // Reference move generator: brute-force loop over all 
        // squares/directions
        vector<Move> slow_moves_generation(const Yolah& yolah) {
            vector<Move> res;
            for (int i = 0; i < 8; i++) {
                for (int j = 0; j < 8; j++) {
                    Square from = square_of(i, j);
                    if (yolah.get(from) != yolah.current_player()) {
                        continue;
                    }
                    for (int di = -1; di <= 1; di++) {
                        for (int dj = -1; dj <= 1; dj++) {
                            if (di == 0 && dj == 0) continue;
                            int ii = i + di;
                            int jj = j + dj;
                            for(;;) {
                                if (ii < 0 || ii >= 8 || 
                                    jj < 0 || jj >= 8) break;
                                Square to = square_of(ii,jj);                                
                                if (yolah.get(to) != FREE) break;                                
                                res.emplace_back(from, to);
                                ii += di;
                                jj += dj;
                            }
                        }
                    }
                }
            }
            if (res.empty()) res.push_back(Move::none());
            return res;
        }

        // Verifies that magic and naive generators produce the same 
        // move count
        TestResult check_move_count(const MoveList& fast, 
                                    const vector<Move>& expected) {
            if (fast.size() != expected.size()) {
                return fail(format("# of moves: expected {} got {}", 
                                   expected.size(), fast.size()));
            }
            return pass();
        }

        // Sorts magic and naive lists and checks element-wise 
        // equality, reports differences
        TestResult check_move_lists_equal(MoveList& fast, 
                                          vector<Move>& expected, 
                                          const Yolah& yolah) {
            sort(begin(fast), end(fast));
            sort(begin(expected), end(expected));
            if (equal(begin(fast), end(fast), 
                      begin(expected), end(expected))) {
                return pass();
            }
            ostringstream oss;
            oss << "move lists differ\n" << yolah << '\n';
            vector<Move> only_in_fast, only_in_expected;
            set_difference(begin(fast), end(fast), begin(expected), 
                           end(expected), 
                           back_inserter(only_in_fast));
            set_difference(begin(expected), end(expected), begin(fast), 
                           end(fast), 
                           back_inserter(only_in_expected));
            if (!only_in_expected.empty()) {
                oss << "  Only in expected: ";
                for (const auto& m : only_in_expected) {
                    oss << m << ' ';
                }
                oss << '\n';
            }
            if (!only_in_fast.empty()) {
                oss << "  Only in fast: ";
                for (const auto& m : only_in_fast) oss << m << ' ';
                oss << '\n';
            }
            return fail(oss.str());
        }

        // Verifies that undo restores the board to its previous state
        TestResult check_undo(const Yolah& before, 
                              const Yolah& after) {
            if (before == after) return pass();
            ostringstream oss;
            oss << "undo failed\n  Previous state:\n" << before
                << "\n  State after undo:\n" << after << '\n';
            return fail(oss.str());
        }

        // When the game is over, the only legal move must be 
        // Move::none()
        TestResult check_game_over_moves(const Yolah& yolah, 
                                         const MoveList& moves) {
            if (moves.size() == 1 && moves[0] == Move::none()) {
                return pass();
            }
            ostringstream oss;
            oss << "only Move::none() should be available when"
                << " game is over\n"
                << YolahWithMoves(yolah, moves) << '\n';
            return fail(oss.str());
        }

        // Move::none() must not alter the board, only increment the 
        // ply counter
        TestResult check_none_move_execution(const Yolah& before, 
                                             const Yolah& after) {
            bool ok = true;
            for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
                if (before.get(sq) != after.get(sq)) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                return fail("Move::none() must not change the board content");
            }
            if (before.nb_plies() + 1 != after.nb_plies()) {
                return fail("Move::none() must increment the number of plies");
            }
            return pass();
        }

        // A regular move must: place a piece at 'to', create a hole 
        // at 'from', increment ply, and leave all other squares 
        // unchanged
        TestResult check_regular_move_execution(const Yolah& before, 
                                                const Yolah& after, 
                                                Move m) {
            Square from = m.from_sq();
            Square to = m.to_sq();
            bool ok = true;
            for (Square sq = SQ_A1; sq <= SQ_H8; ++sq) {
                if (sq == from || sq == to) continue;
                if (before.get(sq) != after.get(sq)) {
                    ok = false;
                    break;
                }
            }
            if (ok && before.nb_plies() + 1 == after.nb_plies() &&
                after.get(from) == HOLE && 
                after.get(to) == before.current_player()) {
                    return pass();
            }
            ostringstream oss;
            oss << "Move execution incorrect\n" << after 
                << "\n  Move: " << m << '\n';
            if (!ok) {
                oss << " Squares not concerned by the move must not change";
            }
            if (after.get(from) != HOLE) {
                oss << "  From square should be hole\n";
            }
            if (after.get(to) != before.current_player()) {
                oss << " To square should contain a piece from " 
                    << (before.current_player() == BLACK ? "black" : 
                                                           "white") 
                    << " player\n";
            }
            if (before.nb_plies() + 1 != after.nb_plies()) {
                oss << " The number of plies must be incremented\n";
            }
            return fail(oss.str());
        }
    }

    // Runs nb_games random games, testing move generation, play/undo, 
    // and game_over at each step
    void random_games(size_t nb_games, optional<uint64_t> seed) {
        MoveList fast_moves;
        random_device rd;
        mt19937 mt(seed.value_or(rd()));
        size_t total_tests = 0;
        size_t passed_tests = 0;

        auto run_test = [&](TestResult result) -> bool {
            total_tests++;
            if (result) {
                passed_tests++;
                return true;
            }
            cout << format("{}FAIL:{} {}\n", RED, RESET, 
                           result.message);
            return false;
        };
        
        cout << format("{}\n=== Running Random Games Tests ===\n{}", 
                       BOLD, RESET);

        for (size_t i = 0; i < nb_games; i++) {
            Yolah yolah;
            while (!yolah.game_over()) {
                yolah.moves(fast_moves);
                vector<Move> expected_moves = 
                    slow_moves_generation(yolah);
                if ( !run_test(
                         check_move_count(fast_moves, 
                                          expected_moves)) ) break;
                if ( !run_test(
                         check_move_lists_equal(fast_moves, 
                                                expected_moves, 
                                                yolah)) ) break;
                uniform_int_distribution<int> d(0,
                                                fast_moves.size()-1);
                Move m = fast_moves[d(mt)];
                Yolah before = yolah;
                yolah.play(m);
                if (m == Move::none()) {
                    if (!run_test(
                            check_none_move_execution(before, 
                                                      yolah))) break;
                } else {
                    if (!run_test(
                            check_regular_move_execution(before, 
                                                         yolah, 
                                                         m))) break;
                }
                yolah.undo(m);
                if (!run_test(check_undo(before, yolah))) break;
                yolah.play(m);
            }
            if (!yolah.game_over()) continue;
            yolah.moves(fast_moves);
            if (!run_test(
                    check_game_over_moves(yolah, 
                                          fast_moves))) continue;
            yolah.play(Move::none());
            yolah.moves(fast_moves);
            if (!run_test(
                    check_game_over_moves(yolah, 
                                          fast_moves))) continue;
        }

        cout << format("\n{}=== Test Summary ==={}\n", BOLD, RESET);
        cout << format("Total tests: {}\n", total_tests);
        cout << format("Passed: {}{}{}\n", GREEN, passed_tests, 
                       RESET);
        cout << format("Failed: {}{}{}\n", 
                        (passed_tests == total_tests ? GREEN : RED), 
                        total_tests - passed_tests, RESET);
        if (passed_tests == total_tests) {
            cout << format("{}All tests passed!{}\n", GREEN, RESET);
        } else {
            double pass_rate = 100.0 * passed_tests / total_tests;
            cout << format("{}Pass rate: {:.2f}%{}\n", YELLOW, 
                           pass_rate, RESET);
        }
    }
}

int main() {
    init_all_magics();    
    //play_random_games<true>(1000000, 42);
    play_random_games<false>(1000000, 42);
    //test::random_games(10000, 42);
    //play_random_games_fast(1000000, 42);
}
\end{minted}
% \captionof{listing}{Génération d'un coup aléatoire sans générer auparavant toute la liste de coups.}
\captionof{listing}{Complete game board code (part 4/4 -- display, random games, tests and main)}
\label{lst:board_code_4}
\label{lst:board_code}
\end{mdframed}

\begin{mdframed}[skipabove=\baselineskip,skipbelow=0pt,hidealllines=true,backgroundcolor=black!3,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=0pt,innerbottommargin=5pt]
{\small
\begin{verbatim} 
$ g++ -std=c++23 -O3 -march=native -Wall -Wpedantic chapter02.cpp\
-o chapter02
$ ./chapter02
=== Game Statistics ===
Total games: 1000000
Black wins:  499124 (49.9%)
White wins:  395468 (39.5%)
Draws:       105408 (10.5%)

real    0m3,075s
user    0m3,067s
sys     0m0,008s
\end{verbatim}
}
\end{mdframed}
%\vspace{-0.5\baselineskip}
\begin{mdframed}[skipabove=0pt,skipbelow=\baselineskip,hidealllines=true,innerleftmargin=10pt,innerrightmargin=5pt,innertopmargin=3pt,innerbottommargin=3pt]
% Original French (corrected): Résultats de l'exécution du programme du plateau (listings \ref{lst:board_code_1}--\ref{lst:board_code_4}).
\captionof{listing}{Results of executing the board code program (listings \ref{lst:board_code_1}--\ref{lst:board_code_4}).}
\label{lst:chapter02_exec}
\end{mdframed}


% \begin{importantbox}
% Efficient board representation is critical for performance. Every AI algorithm will access board state thousands or millions of times during search.
% \end{importantbox}

% \section{Move Generation}

% Move generation is the process of finding all legal moves from a given position. This is a critical component that affects both correctness and performance.

% \subsection{Algorithm}

% The move generation algorithm follows this structure:

% \begin{algorithmbox}
% \begin{algorithmic}[1]
% \Procedure{GenerateMoves}{$board$}
%     \State $moves \gets []$
%     \For{each position $(row, col)$ on $board$}
%         \If{position is empty}
%             \State $move \gets \textsc{CreateMove}(row, col)$
%             \If{$move$ is legal}
%                 \State $moves.\textsc{append}(move)$
%             \EndIf
%         \EndIf
%     \EndFor
%     \State \Return $moves$
% \EndProcedure
% \end{algorithmic}
% \end{algorithmbox}

% \section{Performance Considerations}

% When building a game engine, performance is paramount. Consider these key metrics:

% \begin{table}[H]
% \centering
% \begin{tabular}{lcc}
% \toprule
% \textbf{Operation} & \textbf{Target Time} & \textbf{Frequency} \\
% \midrule
% Move generation & $< 1$ ms & Every node \\
% Make/unmake move & $< 0.1$ ms & Every node \\
% Position evaluation & $< 5$ ms & Leaf nodes \\
% Legal move check & $< 0.01$ ms & Very frequent \\
% \bottomrule
% \end{tabular}
% \caption{Performance targets for engine operations}
% \label{tab:performance}
% \end{table}

% \begin{resultbox}
% Our optimized engine achieves over 100,000 nodes per second on modern hardware, enabling deep search within reasonable time constraints.
% \end{resultbox}


\chapter{AI Players}
\label{ch:ai}

% \section{Introduction to Minimax}

% The Minimax algorithm is the foundation of game-playing AI. It assumes both players play optimally and searches the game tree to find the best move.

% \subsection{Basic Concept}

% The algorithm alternates between:
% \begin{itemize}
%     \item \textbf{Maximizing} player tries to maximize score
%     \item \textbf{Minimizing} player tries to minimize score
% \end{itemize}

% This creates a mathematical framework for two-player zero-sum games.

% \section{Implementation}

% Here's a complete Minimax implementation:

% \begin{listing}[H]
% \begin{minted}[linenos, bgcolor=codebg]{python}
% def minimax(board, depth, maximizing_player):
%     """
%     Standard Minimax algorithm implementation.

%     Args:
%         board: Current game state
%         depth: Remaining search depth
%         maximizing_player: True if maximizing, False if minimizing

%     Returns:
%         Best evaluation score for this position
%     """
%     # Base case: terminal position or depth limit
%     if depth == 0 or board.is_game_over():
%         return evaluate(board)

%     if maximizing_player:
%         max_eval = float('-inf')
%         for move in board.generate_moves():
%             board.make_move(move)
%             eval = minimax(board, depth - 1, False)
%             board.undo_move()
%             max_eval = max(max_eval, eval)
%         return max_eval
%     else:
%         min_eval = float('inf')
%         for move in board.generate_moves():
%             board.make_move(move)
%             eval = minimax(board, depth - 1, True)
%             board.undo_move()
%             min_eval = min(min_eval, eval)
%         return min_eval
% \end{minted}
% \caption{Minimax algorithm implementation}
% \label{code:minimax}
% \end{listing}

% \section{Complexity Analysis}

% The time complexity of Minimax is:

% \begin{equation}
%     T(d) = O(b^d)
%     \label{eq:minimax_complexity}
% \end{equation}

% where $b$ is the branching factor and $d$ is the search depth.

% For Yolah with an average branching factor of 30:
% \begin{align}
%     \text{Nodes at depth 1} &= 30 \\
%     \text{Nodes at depth 2} &= 30^2 = 900 \\
%     \text{Nodes at depth 4} &= 30^4 = 810,000 \\
%     \text{Nodes at depth 6} &= 30^6 = 729,000,000
% \end{align}

% \begin{importantbox}
% The exponential growth of nodes makes deep search impractical without optimization techniques like Alpha-Beta pruning.
% \end{importantbox}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % EXAMPLE FIGURE
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \section{Visualizing Minimax}

% Figure~\ref{fig:minimax_tree} shows how Minimax explores the game tree.

% \begin{figure}[H]
% \centering
% \begin{tikzpicture}[
%     level distance=1.5cm,
%     level 1/.style={sibling distance=4cm},
%     level 2/.style={sibling distance=2cm},
%     every node/.style={circle, draw, minimum size=0.8cm}
% ]
% \node {Max}
%     child {node {Min}
%         child {node {5}}
%         child {node {3}}
%     }
%     child {node {Min}
%         child {node {7}}
%         child {node {2}}
%     }
%     child {node {Min}
%         child {node {4}}
%         child {node {6}}
%     };
% \end{tikzpicture}
% \caption{Minimax game tree example. The maximizing player chooses the move leading to the highest value.}
% \label{fig:minimax_tree}
% \end{figure}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % ADDITIONAL CHAPTERS
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \chapter{Alpha-Beta Pruning}
% \label{ch:alphabeta}

% Alpha-Beta pruning dramatically improves Minimax by eliminating branches that cannot affect the final decision.

% \section{The Pruning Principle}

% Your content here...

\chapter{Monte Carlo Player}
\label{ch:monte_carlo}

% MCTS revolutionized game AI by using random simulations instead of exhaustive search.

% \section{UCB1 Formula}

% The Upper Confidence Bound formula balances exploration and exploitation:

% \begin{equation}
%     UCB1 = \frac{w_i}{n_i} + c\sqrt{\frac{\ln N}{n_i}}
%     \label{eq:ucb1}
% \end{equation}

% where:
% \begin{itemize}
%     \item $w_i$ = wins for node $i$
%     \item $n_i$ = visits to node $i$
%     \item $N$ = total visits to parent
%     \item $c$ = exploration constant
% \end{itemize}

% Continue with more chapters...

\chapter{MCTS Player}
\label{ch:mcts}

% Your content here...

\chapter{Minmax Player}
\label{ch:minmax}

% Your content here...

\chapter{Minmax with Neural Network Player}
\label{ch:nnue}

% Your content here...

\chapter{AI Tournament}
\label{ch:tournament}

% Your content here...

\chapter{Conclusion}
\label{ch:conclusion}

% This book has taken you on a journey from classical game-playing algorithms to modern neural network approaches. The Yolah engine demonstrates that combining multiple techniques yields the best results.

% \section{Key Takeaways}

% \begin{enumerate}
%     \item Classical algorithms remain relevant and effective
%     \item Neural networks provide powerful evaluation functions
%     \item Hybrid approaches leverage the strengths of multiple methods
%     \item Performance optimization is critical for practical systems
% \end{enumerate}

% \section{Future Directions}

% Promising areas for future research include:
% \begin{itemize}
%     \item More efficient neural architectures
%     \item Better exploration strategies
%     \item Transfer learning across game domains
%     \item Real-time learning and adaptation
% \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACK MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\backmatter

% Appendix
\appendix

% \chapter{Installation Guide}
% \label{app:installation}

% \section{Requirements}

% To run the Yolah engine, you need:
% \begin{itemize}
%     \item Python 3.8 or higher
%     \item NumPy
%     \item TensorFlow or PyTorch
%     \item Additional dependencies listed in requirements.txt
% \end{itemize}

% \section{Setup Instructions}

% \begin{minted}[bgcolor=codebg]{bash}
% git clone https://github.com/yourusername/yolah.git
% cd yolah
% pip install -r requirements.txt
% python setup.py install
% \end{minted}

% Glossary
\printglossary[type=\acronymtype,title=Acronymes]
\printglossary[title=Glossaire]

% Bibliography
\printbibliography[heading=bibintoc]

% Index (if needed)
% \printindex

\end{document}
